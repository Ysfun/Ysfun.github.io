<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Https、ssh加密原理</title>
    <url>/2022/03/31/Https%E3%80%81ssh%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86%E4%B8%8E%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="1-Https与Http区别"><a href="#1-Https与Http区别" class="headerlink" title="1. Https与Http区别"></a>1. Https与Http区别</h2><p>相比于Http，Https采用了加密传输方式，可以有效防止网络攻击。可以近似理解为Https &#x3D; Http + SSL证书。</p>
<p>Http默认端口为8080，Https默认端口为443。</p>
<h2 id="2-Https加密原理"><a href="#2-Https加密原理" class="headerlink" title="2. Https加密原理"></a>2. Https加密原理</h2><p><img src="https://images.ysfun.cn/mac-img/Https%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86.png" alt="Https加密原理"></p>
<span id="more"></span>

<ol>
<li>客户端（浏览器）向服务端发起请求</li>
<li>服务端接收请求，并明文传输公钥A给客户端，为了证实服务端的身份，服务端会将CA证书一同传输给客户端（这个步骤是与ssh建立连接的区别所在）</li>
<li>客户端接收到公钥A，并用公钥A加密自己本地随机生成的对称加密密钥X</li>
<li>公钥A加密的信息只有通过私钥才能解密，因此只有服务端才能解密并获取对称密钥X</li>
<li>至此，服务端和客户端双方都持有对称密钥X，且第三方无法窃取，此后通过密钥X加密传输数据</li>
</ol>
<h2 id="3-SSH加密原理"><a href="#3-SSH加密原理" class="headerlink" title="3. SSH加密原理"></a>3. SSH加密原理</h2><p>SSH是一种网络协议，用于计算机之间的加密登录。如果一个用户从本地计算机，使用SSH协议登录另一台远程计算机，我们就可以认为，这种登录是安全的，即使被中途截获，密码也不会泄露。</p>
<p><img src="https://images.ysfun.cn/mac-img/ssh%E5%8A%A0%E5%AF%86%E5%8E%9F%E7%90%86.png"></p>
<p>SSH加密原理与https基本相同，唯一的区别在于ssh没有CA证书，容易收到中间人攻击（Man-in-the-middle attack）。客户端无法验证公钥有没有被篡改过，如果有人截取数据，并返回篡改后的假公钥给客户端，客户端通过假公钥加密后的密码信息被截取并解密，就会导致客户端密码信息泄漏。</p>
<ul>
<li>下图展示了SSH被攻击的情况</li>
</ul>
<p><img src="https://images.ysfun.cn/mac-img/ssh%E8%A2%AB%E6%94%BB%E5%87%BB.png" alt="ssh被攻击"></p>
<p>问题在于客户端无法验证公钥A是不是来自服务端真实的公钥，Https采用CA证书来验证服务端的身份，而SSH则没有。</p>
<h2 id="4-SSH解决中间人攻击的办法"><a href="#4-SSH解决中间人攻击的办法" class="headerlink" title="4. SSH解决中间人攻击的办法"></a>4. SSH解决中间人攻击的办法</h2><p>SSH的publish key和private key都是自己生成的，没法公证。只能通过Client端自己对公钥进行确认。</p>
<p>通常在第一次登录的时候，系统会出现下面提示信息：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">ssh user@host</span></span><br><span class="line">The authenticity of host &#x27;host (12.18.429.21)&#x27; can&#x27;t be established.</span><br><span class="line">RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.</span><br><span class="line">Are you sure you want to continue connecting (yes/no)?</span><br></pre></td></tr></table></figure>

<p>上面信息的意思是：无法确认主机host(12.18.429.21)的真实性，不过知道它的公钥指纹，询问你是否继续连接？</p>
<p>所谓”公钥指纹”，是指公钥长度较长（这里采用RSA算法，长达1024位），很难比对，所以对其进行MD5计算，将它变成一个128位的指纹。上例中是98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d，再进行比较，就容易多了。</p>
<p>之所以用fingerprint代替key，主要是key过于长（RSA算法生成的公钥有1024位），很难直接比较。所以，对公钥进行hash生成一个128位的指纹，这样就方便比较了。</p>
<p>很自然的一个问题就是，用户怎么知道远程主机的公钥指纹应该是多少？</p>
<p>回答是没有好办法，远程主机必须在自己的网站上贴出公钥指纹，以便用户自行核对，或者自己甄别host地址是否正确。</p>
<p>假定经过风险衡量以后（一般用户直接就选择yes吧），用户决定接受这个远程主机的公钥。<br>　　Are you sure you want to continue connecting (yes&#x2F;no)? yes<br>系统会出现一句提示，表示host主机已经得到认可。<br>　　Warning: Permanently added ‘host,12.18.429.21’ (RSA) to the list of known hosts.<br>然后，会要求输入密码。<br>　　Password: (enter password)<br>如果密码正确，就可以登录了。</p>
<p>当远程主机的公钥被接受以后，它就会被保存在文件$HOME&#x2F;.ssh&#x2F;known_hosts之中。下次再连接这台主机，系统就会认出它的公钥已经保存在本地了，从而跳过警告部分，直接提示输入密码。<br>每个SSH用户都有自己的known_hosts文件，此外系统也有一个这样的文件，通常是&#x2F;etc&#x2F;ssh&#x2F;ssh_known_hosts，保存一些对所有用户都可信赖的远程主机的公钥。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker常用命令</title>
    <url>/2021/11/22/Docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="帮助命令"><a href="#帮助命令" class="headerlink" title="帮助命令"></a>帮助命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看版本信息</span></span><br><span class="line">docker version</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">信息</span></span><br><span class="line">docker info</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看命令帮助信息</span></span><br><span class="line">docker 命令 --help</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<blockquote>
<p>Docker命令的帮助文档 <a href="https://docs.docker.com/reference/">Command-line-reference</a></p>
</blockquote>
<p><img src="https://images.ysfun.cn/mac-img/docker_command_diagram.jpeg"></p>
<h2 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">% </span><span class="language-bash">docker images</span></span><br><span class="line">REPOSITORY               TAG       IMAGE ID       CREATED       SIZE</span><br><span class="line">docker/getting-started   latest    b1bcd61774d8   10 days ago   27.2MB</span><br><span class="line">hello-world              latest    18e5af790473   8 weeks ago   9.14kB</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">解释</span></span><br><span class="line">REPOSITORY	镜像仓库源</span><br><span class="line">TAG					镜像的标签</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可选项</span></span><br><span class="line">  -a, --all             Show all images (default hides intermediate images)</span><br><span class="line">  -q, --quiet           Only show image IDs</span><br></pre></td></tr></table></figure>

<p><strong>docker search：镜像搜索命令</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">% </span><span class="language-bash">docker search mysql</span></span><br><span class="line">NAME                              DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">mysql                             MySQL is a widely used, open-source relation…   11712     [OK]       </span><br><span class="line">mariadb                           MariaDB Server is a high performing open sou…   4464      [OK]       </span><br><span class="line">mysql/mysql-server                Optimized MySQL Server Docker images. Create…   870                  [OK]</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可选项</span></span><br><span class="line">  -f, --filter filter   Filter output based on conditions provided</span><br><span class="line">      --format string   Pretty-print search using a Go template</span><br><span class="line">      --limit int       Max number of search results (default 25)</span><br><span class="line">      --no-trunc        Don&#x27;t truncate output</span><br><span class="line">例如：docker search mysql --filter=stars=3000  --&gt;  表示stars&gt;=3000的结果</span><br><span class="line"><span class="meta prompt_">% </span><span class="language-bash">docker search mysql --filter=stars=3000</span></span><br><span class="line">NAME      DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED</span><br><span class="line">mysql     MySQL is a widely used, open-source relation…   11712     [OK]       </span><br><span class="line">mariadb   MariaDB Server is a high performing open sou…   4464      [OK]   </span><br></pre></td></tr></table></figure>

<p><strong>docker pull：下载镜像</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载镜像 docker pull 镜像名 [:tag]</span></span><br><span class="line"><span class="meta prompt_">% </span><span class="language-bash">docker pull mysql/mysql-server:5.7</span></span><br><span class="line"></span><br><span class="line">5.7: Pulling from mysql/mysql-server</span><br><span class="line">b8aa102ba20a: Pull complete </span><br><span class="line">2ff679d72626: Pull complete </span><br><span class="line">ea45979059fe: Pull complete </span><br><span class="line">526a484cb892: Pull complete </span><br><span class="line">4436dc023066: Pull complete </span><br><span class="line">98b382a658b6: Pull complete </span><br><span class="line">17d3acf6ac1e: Pull complete </span><br><span class="line">c5ce8d5cf40e: Pull complete </span><br><span class="line">Digest: sha256:32aac4632baa157d24e9eb3e20d2d62e775f0a2630afb8dabf5ee8c086b09c2a</span><br><span class="line">Status: Downloaded newer image for mysql/mysql-server:5.7</span><br><span class="line">docker.io/mysql/mysql-server:5.7</span><br></pre></td></tr></table></figure>

<p><strong>docker rmi：删除镜像命令</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rmi -f 镜像id 镜像id  # 删除多个镜像</span><br><span class="line">docker rmi -f $(docker images -qa)  # 删除全部镜像</span><br><span class="line"><span class="meta prompt_">% </span><span class="language-bash">docker rmi -f 18e5af790473</span></span><br><span class="line"></span><br><span class="line">Untagged: hello-world:latest</span><br><span class="line">Untagged: hello-world@sha256:cc15c5b292d8525effc0f89cb299f1804f3a725c8d05e158653a563f15e4f685</span><br><span class="line">Deleted: sha256:18e5af7904737ba5ef7fbbd7d59de5ebe6c4437907bd7fc436bf9b3ef3149ea9</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">可选项</span></span><br><span class="line">  -f, --force      Force removal of the image</span><br><span class="line">      --no-prune   Do not delete untagged parents</span><br></pre></td></tr></table></figure>



<h2 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h2><p><strong>docker run：新建容器并启动</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run [可选参数] image</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">参数说明</span></span><br><span class="line">--name=&quot;Name&quot;			指定容器名字，用于区分容器</span><br><span class="line">-d								后台方式运行</span><br><span class="line">-it								使用交互方式运行，进入容器查看内容</span><br><span class="line">-p								指定容器的端口 - p 8080:8080</span><br><span class="line">		-p ip: 主机端口:容器端口</span><br><span class="line">		-p 主机端口:容器端口（常用）</span><br><span class="line">		-p 容器端口</span><br><span class="line">-P								随机指定端口</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动并进入容器</span></span><br><span class="line">hyunmin@HyunmindeMacBook-Air ~ % docker run -it centos /bin/bash</span><br><span class="line">[root@44e406af8256 /]# exit			# 退出容器</span><br></pre></td></tr></table></figure>

<p><strong>docker ps：查看运行中的容器</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">% </span><span class="language-bash">docker ps</span></span><br><span class="line">CONTAINER ID   IMAGE           COMMAND       CREATED        STATUS        PORTS     NAMES</span><br><span class="line">77128abd1e9c   centos:latest   &quot;/bin/bash&quot;   15 hours ago   Up 15 hours             objective_hellman</span><br></pre></td></tr></table></figure>

<p><strong>退出容器</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">退出并关闭容器</span></span><br><span class="line">exit</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">退出容器，不关闭，后台运行</span></span><br><span class="line">Ctrl+P+Q</span><br></pre></td></tr></table></figure>

<p><strong>docker rm：删除容器</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rm 容器id				# 删除指定容器，不能删除正在运行的容器，-f强制删除</span><br></pre></td></tr></table></figure>

<p><strong>启动和停止容器操作</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker start 容器id 				# 启动容器</span><br><span class="line">docker restart 容器id				# 重启容器</span><br><span class="line">docker stop 	容器id				# 停止当前正在运行的容器</span><br><span class="line">docker kill 容器id					# 强制停止当前容器</span><br></pre></td></tr></table></figure>

<h2 id="DockerFile"><a href="#DockerFile" class="headerlink" title="DockerFile"></a>DockerFile</h2><blockquote>
<p><strong>DockerFile常用命令</strong></p>
</blockquote>
<p><img src="https://images.ysfun.cn/mac-img/image-20211202100941535.png"> </p>
<blockquote>
<p> <strong>DockerFile构建流程</strong></p>
</blockquote>
<p><img src="https://images.ysfun.cn/mac-img/image-20211202101420768.png"> </p>
<blockquote>
<p>Docker file创建一个自己的centos</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. 编写一个自己的docker file</span></span><br><span class="line">FROM centos</span><br><span class="line">MAINTAINER hyunmin&lt;s_hyunmin@163.com&gt;</span><br><span class="line"></span><br><span class="line">ENV MY_PATH /usr/local</span><br><span class="line">WORKDIR $MY_PATH</span><br><span class="line"></span><br><span class="line">RUN yum -y install vim</span><br><span class="line">RUN yum -y install net-tools</span><br><span class="line"></span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line">CMD echo $MY_PATH</span><br><span class="line">CMD echo &quot;----end----&quot;</span><br><span class="line">CMD /bin/bash</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2. build镜像文件</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">build命令</span></span><br><span class="line">docker build -f dockerfile文件路径 -t 镜像名:[tag] 文件目录(.)</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">3. 镜像本地变更历史</span></span><br><span class="line">docker history docker镜像id</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis中SqlSession创建过程详解</title>
    <url>/2021/11/22/MyBatis%E4%B8%ADSqlSession%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="1、SqlSession接口介绍"><a href="#1、SqlSession接口介绍" class="headerlink" title="1、SqlSession接口介绍"></a>1、SqlSession接口介绍</h2><p>SqlSession是MyBatis的主要Java接口，通过这个接口可以执行命令、获取mappers、进行事务管理。</p>
<p>接口的主要方法有：</p>
<img src="/2021/11/22/MyBatis%E4%B8%ADSqlSession%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/hyunmin/Desktop/MyBatis中SqlSession创建过程详解/image-20210505134423383.png">

<p><strong>getMapper(Class<T>): T 规定了获取mapper的方法。</T></strong></p>
<p>实现类：</p>
 <img src="/2021/11/22/MyBatis%E4%B8%ADSqlSession%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/hyunmin/Desktop/MyBatis中SqlSession创建过程详解/image-20210505134944251.png">

<span id="more"></span>

<h2 id="2、SqlSessionFactory"><a href="#2、SqlSessionFactory" class="headerlink" title="2、SqlSessionFactory"></a>2、<code>SqlSessionFactory</code></h2><p>由<code>SqlSessionFactory</code>接口创建SqlSession，<code>SqlSessionFactory</code> 有一个唯一的必要属性：用于 JDBC 的 <code>DataSource</code>。这可以是任意的 <code>DataSource</code> 对象，它的配置方法和其它 Spring 数据库连接是一样的。</p>
<p>在基础的 MyBatis 用法中，是通过 <code>SqlSessionFactoryBuilder</code> 来创建 <code>SqlSessionFactory</code> 的。而在 MyBatis-Spring 中，则使用 <code>SqlSessionFactoryBean</code> 来创建。</p>
<p>示例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBatisConfig</span> &#123;</span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="keyword">public</span> SqlSessionFactory <span class="title function_">sqlSessionFactory</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">SqlSessionFactoryBean</span> <span class="variable">factoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">    factoryBean.setDataSource(dataSource());</span><br><span class="line">    <span class="keyword">return</span> factoryBean.getObject();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>SqlSessionFactoryBean</code>实现了Spring的<code>FactoryBean</code>接口。这意味着由Spring最终创建的bean并不是<code>SqlSessionFactoryBean</code>本身，而是工厂类(<code>SqlSessionFactoryBean</code>)的getObject()方法的返回结果。</p>
 <img src="/2021/11/22/MyBatis%E4%B8%ADSqlSession%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/hyunmin/Desktop/MyBatis中SqlSession创建过程详解/image-20210505142305469.png">

<h2 id="3、追踪mapper的创建过程"><a href="#3、追踪mapper的创建过程" class="headerlink" title="3、追踪mapper的创建过程"></a>3、追踪mapper的创建过程</h2><p>通过MapperFactoryBean创建mapper的bean对象</p>
<p>在容器注入MapperSessionFactoryBean</p>
<p>xml方式：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userMapper&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;mapperInterface&quot;</span> <span class="attr">value</span>=<span class="string">&quot;org.mybatis.spring.sample.mapper.UserMapper&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;sqlSessionFactory&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注解方式：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> MapperFactoryBean <span class="title function_">mapperFactoryBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception&#123;</span><br><span class="line">    <span class="type">MapperFactoryBean</span> <span class="variable">mapperFactoryBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MapperFactoryBean</span>(PersonMapper.class);</span><br><span class="line">    <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> SqlSessionFactory();</span><br><span class="line">    mapperFactoryBean.setSqlSessionFactory(sqlSessionFactory);</span><br><span class="line">    <span class="keyword">return</span> mapperFactoryBean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取mapper</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> UserMapper userMapper&#123;</span><br><span class="line">    <span class="keyword">return</span> (UserMapper)mapperFactoryBean.getObect();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><p><strong>MapperFactoryBean</strong>类：</p>
<p>继承自<code>SqlSessionDaoSupport</code></p>
<img src="/2021/11/22/MyBatis%E4%B8%ADSqlSession%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/hyunmin/Desktop/MyBatis中SqlSession创建过程详解/image-20210505144810017.png">

<p>通过构造器将<code>UserMapper</code>接口的类型赋给mapperInterface属性</p>
<img src="/2021/11/22/MyBatis%E4%B8%ADSqlSession%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/hyunmin/Desktop/MyBatis中SqlSession创建过程详解/image-20210505144207877.png">

<p>getObject()方法得到<code>UserMapper</code>接口的代理对象</p>
<img src="/2021/11/22/MyBatis%E4%B8%ADSqlSession%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/hyunmin/Desktop/MyBatis中SqlSession创建过程详解/image-20210505143732511.png">

<p>getSqlSession()方法是父类<code>SqlSessionDaoSupport</code>的方法</p>
<img src="/2021/11/22/MyBatis%E4%B8%ADSqlSession%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/hyunmin/Desktop/MyBatis中SqlSession创建过程详解/image-20210505145007415.png">

<img src="/2021/11/22/MyBatis%E4%B8%ADSqlSession%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/hyunmin/Desktop/MyBatis中SqlSession创建过程详解/image-20210505145140277.png">

<p>由上可知，<code>MapperFactoryBean.getObject()</code>方法的返回值等同于</p>
<p><code>new SqlSessionTemplate(sqlSessionFactory).getMapper(mapperInterface)</code>的返回值</p>
<p>注意：SqlSessionTemplate是SqlSession的实现类</p>
<p>SqlSessionTemplate.getMapper(type)方法</p>
<img src="/2021/11/22/MyBatis%E4%B8%ADSqlSession%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/hyunmin/Desktop/MyBatis中SqlSession创建过程详解/image-20210505153356044.png">

<p>Configuration.getMapper(type, sqlSession)方法</p>
<img src="/2021/11/22/MyBatis%E4%B8%ADSqlSession%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/hyunmin/Desktop/MyBatis中SqlSession创建过程详解/image-20210505153616988.png">

<p>MapperRegistry.getMapper(type, sqlSession)方法</p>
<img src="/2021/11/22/MyBatis%E4%B8%ADSqlSession%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/hyunmin/Desktop/MyBatis中SqlSession创建过程详解/image-20210505153935293.png">

<p>MapperProxyFactory.newInstance(sqlSession)方法，Proxy.newProxyInstance()是JDK动态代理的方法</p>
<img src="/2021/11/22/MyBatis%E4%B8%ADSqlSession%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/hyunmin/Desktop/MyBatis中SqlSession创建过程详解/image-20210505154127702.png">

<p>由此可追踪到，mapper是实际上就是通过动态代理创建的代理对象。</p>
<h2 id="3、mapper执行sql方法"><a href="#3、mapper执行sql方法" class="headerlink" title="3、mapper执行sql方法"></a>3、mapper执行sql方法</h2><p>MapperProxy.execute(sqlSession, args)方法</p>
<img src="/2021/11/22/MyBatis%E4%B8%ADSqlSession%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/hyunmin/Desktop/MyBatis中SqlSession创建过程详解/image-20210505155455637.png">

<p>上图中的<code>sqlSession</code>为<code>SqlSessionTemplate</code>，SqlSessionTemplate.insert(statement, parameter)方法：</p>
<img src="/2021/11/22/MyBatis%E4%B8%ADSqlSession%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/hyunmin/Desktop/MyBatis中SqlSession创建过程详解/image-20210505155648618.png">

<p>SqlSessionProxy的创建，SqlSessionProxy是SqlSession接口的代理对象：</p>
<img src="/2021/11/22/MyBatis%E4%B8%ADSqlSession%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/hyunmin/Desktop/MyBatis中SqlSession创建过程详解/image-20210505160016131.png">

<p>SqlSessionTemplate.SqlSessionInterceptor.invoke()方法中完成事务事务管理<img src="/2021/11/22/MyBatis%E4%B8%ADSqlSession%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E8%AF%A6%E8%A7%A3/hyunmin/Desktop/MyBatis中SqlSession创建过程详解/image-20210505160517366.png"></p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo博客安装Icarus主题</title>
    <url>/2021/11/28/hexo%E5%8D%9A%E5%AE%A2%E5%AE%89%E8%A3%85Icarus%E4%B8%BB%E9%A2%98/</url>
    <content><![CDATA[<p><strong>官方链接：</strong><a href="https://ppoffice.github.io/hexo-theme-icarus/Configuration/icarus%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97-%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/">Icarus用户指南-主题配置</a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ol>
<li>下载，在博客根目录下执行</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus --depth 1</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改博客根目录下的<code>_config.yml</code>文件，把主题设置为<code>icarus</code></li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">icarus</span></span><br></pre></td></tr></table></figure>

<p>或使用hexo命令修改主题为Icarus: </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo config theme icarus</span><br></pre></td></tr></table></figure>

<p>最后，使用如下命令来启动Hexo本地测试服务器并开始创作。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<p>注意：这个时候，可能会报如下错误</p>
<p><img src="http://images.ysfun.cn/mac-img/image-20211128153749506.png"></p>
<p>这个错误原因就是有一些依赖插件没有安装，如果出现这个错误把下面的提示命令复制执行即可！</p>
<p>第一次部署博客时可能会有创建配置文件（根目录下<code>_config.icarus.yml</code>为Icarus主题的配置文件）提示，按照提示执行即可。</p>
<p>友情链接：<a href="https://ppoffice.github.io/hexo-theme-icarus/uncategorized/icarus%E5%BF%AB%E9%80%9F%E4%B8%8A%E6%89%8B/#install-source">Icarus快速上手</a></p>
<h2 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h2><h3 id="皮肤-amp-图标"><a href="#皮肤-amp-图标" class="headerlink" title="皮肤&amp;图标"></a>皮肤&amp;图标</h3><p>配置文件<code>_config.icarus.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 主题皮肤</span></span><br><span class="line"><span class="attr">variant:</span> <span class="string">default</span>	<span class="comment"># default或cyberpunk</span></span><br><span class="line"><span class="comment"># Favicon</span></span><br><span class="line"><span class="attr">head:</span></span><br><span class="line">  <span class="attr">favicon:</span> <span class="string">/img/favicon.svg</span>  <span class="comment"># 后面附图片转svg在线链接</span></span><br></pre></td></tr></table></figure>

<p><a href="https://www.bejson.com/convert/image_to_svg/">在线jpg,png图片转svg</a></p>
<p><a href="https://v1.hitokoto.cn/">懿言推荐</a></p>
<h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><p>如果你已在Hexo中启用了代码高亮功能，你可以通过<code>article</code>中的<code>highlight</code>设置来自定义代码块。 请从<a href="https://github.com/highlightjs/highlight.js/tree/9.18.1/src/styles">highlight.js&#x2F;src&#x2F;styles</a>下列出的所有主题中 选择一个主题。 然后，复制文件名(不带<code>.css</code>后缀)到<code>theme</code>设置项中。</p>
<p>如要隐藏复制代码按钮，将<code>clipboard</code>设置为<code>false</code>。 如果你希望折叠或展开所有代码块，将<code>fold</code>设置为<code>&quot;folded&quot;</code>或<code>&quot;unfolded&quot;</code>。 你也可以将<code>fold</code>设置为空来禁止代码块折叠。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 代码高亮</span></span><br><span class="line"><span class="attr">article:</span></span><br><span class="line">    <span class="attr">highlight:</span></span><br><span class="line">        <span class="comment"># 代码高亮主题</span></span><br><span class="line">        <span class="comment"># https://github.com/highlightjs/highlight.js/tree/master/src/styles</span></span><br><span class="line">        <span class="attr">theme:</span> <span class="string">atom-one-light</span>  <span class="comment"># atelier-lakeside-dark</span></span><br><span class="line">        <span class="comment"># 显示复制代码按钮</span></span><br><span class="line">        <span class="attr">clipboard:</span> <span class="literal">true</span></span><br><span class="line">        <span class="comment"># 代码块的默认折叠状态。可以是&quot;&quot;, &quot;folded&quot;, &quot;unfolded&quot;</span></span><br><span class="line">        <span class="attr">fold:</span> <span class="string">unfolded</span></span><br></pre></td></tr></table></figure>

<p>此外，你可以在Markdown文件中使用下面的语法来折叠单独的代码块：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;% codeblock &quot;可选文件名&quot; lang:代码语言 &gt;folded %&#125;</span><br><span class="line">...代码块内容...</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure>

<h3 id="封面-amp-缩略图"><a href="#封面-amp-缩略图" class="headerlink" title="封面&amp;缩略图"></a>封面&amp;缩略图</h3><p>若要为文章添加封面图，请在文章的front-matter中添加<code>cover</code>选项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">post.md</span><br><span class="line"></span><br><span class="line">title: Icarus快速上手</span><br><span class="line">cover: /gallery/covers/cover.jpg</span><br><span class="line">---</span><br><span class="line">Post content...</span><br></pre></td></tr></table></figure>

<p>类似地，你也可以在文章的front-matter中为文章设置缩略图：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">post.md</span><br><span class="line"></span><br><span class="line">title: Icarus快速上手</span><br><span class="line">thumbnail: /gallery/thumbnails/thumbnail.jpg</span><br><span class="line">---</span><br><span class="line">Post content...</span><br></pre></td></tr></table></figure>

<p>文章的缩略图会显示在归档页面和最新文章挂件中。</p>
<p>如果你在front-matter中使用的是图片的路径，你需要确保它是绝对或者相对于你的source目录的路径。 例如，为使用<code>&lt;your blog&gt;/source/gallery/image.jpg</code>作为缩略图，你需要在front-matter中使用<code>/gallery/image.jpg</code>作为图片路径。</p>
<h3 id="挂件"><a href="#挂件" class="headerlink" title="挂件"></a>挂件</h3><p><strong>官方链接：<a href="https://ppoffice.github.io/hexo-theme-icarus/Widgets/icarus%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97-%E6%8C%82%E4%BB%B6/">Icarus用户指南-挂件</a></strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">&lt;链接名称&gt;:</span></span><br><span class="line">    <span class="attr">icon:</span> <span class="string">&lt;FontAwesome5_图标的_HTML_class名称&gt;</span></span><br><span class="line">    <span class="attr">url:</span> <span class="string">&lt;链接的URL地址&gt;</span></span><br></pre></td></tr></table></figure>

<p><a href="https://fontawesome.com/v5.15/icons?d=gallery&p=1">Font Awesome图标库</a></p>
<p><strong>点击发送邮件：</strong><code>mailto:youname.xxx.com</code></p>
<blockquote>
<p>文章目录</p>
</blockquote>
<p>若要展示文章目录，请在主题配置中添加如下挂件配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">_config.icarus.yml</span><br><span class="line"></span><br><span class="line">widgets:</span><br><span class="line">    -</span><br><span class="line">        type: toc</span><br><span class="line">        position: left</span><br><span class="line">        # 是否显示目录项目的序号</span><br><span class="line">        index: true</span><br></pre></td></tr></table></figure>

<p>然后，在需要开启目录的文章头部加入<code>toc: true</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Post.md</span><br><span class="line"></span><br><span class="line">title: 一篇有目录的文章</span><br><span class="line">toc: true</span><br><span class="line">---</span><br><span class="line">文章内容...</span><br></pre></td></tr></table></figure>

<h3 id="内容折叠-amp-分页"><a href="#内容折叠-amp-分页" class="headerlink" title="内容折叠&amp;分页"></a>内容折叠&amp;分页</h3><h4 id="内容折叠"><a href="#内容折叠" class="headerlink" title="内容折叠"></a>内容折叠</h4><p>使用<code>more</code>语法可以使标记一下的内容进行折叠</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&lt;!-- more --&gt;</span><br></pre></td></tr></table></figure>

<h4 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h4><p>修改<code>_config.yml</code>文件</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 主页每页显示文章数</span></span><br><span class="line"><span class="attr">index_generator:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="number">10</span></span><br><span class="line">  <span class="attr">order_by:</span> <span class="string">-date</span></span><br></pre></td></tr></table></figure>

<h4 id="新建文章时创建年份月份文件夹"><a href="#新建文章时创建年份月份文件夹" class="headerlink" title="新建文章时创建年份月份文件夹"></a>新建文章时创建年份月份文件夹</h4><p>修改<code>_config.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">new_post_name:</span> <span class="string">&#x27;:year/:month/:title.md&#x27;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>教程</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>mac上使用Homebrew安装mysql</title>
    <url>/2021/11/24/mac%E4%B8%8A%E4%BD%BF%E7%94%A8Homebrew%E5%AE%89%E8%A3%85mysql/</url>
    <content><![CDATA[<p>注意⚠️：本教程是采用Homebrew安装mysql，引用官方的一句话：Homebrew是Mac OS 不可或缺的套件管理器。执行一下命令即可安装Homebrew：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">安装Homebrew</span></span><br><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://cdn.jsdelivr.net/gh/ineo6/homebrew-install/install)&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看版本信息</span></span><br><span class="line"><span class="meta prompt_">% </span><span class="language-bash">brew -v</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">出现下面版本信息，则表明安装成功</span></span><br><span class="line">Homebrew 3.3.4</span><br><span class="line">Homebrew/homebrew-core (git revision 4605f7a940f; last commit 2021-11-21)</span><br></pre></td></tr></table></figure>

<h2 id="安装mysql"><a href="#安装mysql" class="headerlink" title="安装mysql"></a>安装mysql</h2><blockquote>
<ol>
<li>使用Homebrew搜索mysql版本</li>
</ol>
</blockquote>
<span id="more"></span>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">% </span><span class="language-bash">brew search mysql</span></span><br><span class="line"></span><br><span class="line">==&gt; Formulae</span><br><span class="line">automysqlbackup          mysql-client             mysql-sandbox            mysql@5.7</span><br><span class="line">mysql                    mysql-client@5.7         mysql-search-replace     mysqltuner</span><br><span class="line">mysql++                  mysql-connector-c++      mysql@5.6                qt-mysql</span><br><span class="line"></span><br><span class="line">==&gt; Casks</span><br><span class="line">homebrew/cask/mysql-connector-python               homebrew/cask/navicat-for-mysql</span><br><span class="line">homebrew/cask/mysql-shell                          homebrew/cask/sqlpro-for-mysql</span><br><span class="line">homebrew/cask/mysql-utilities</span><br></pre></td></tr></table></figure>

<blockquote>
<ol start="2">
<li>安装<a href="mailto:&#109;&#121;&#115;&#x71;&#108;&#64;&#53;&#46;&#55;">&#109;&#121;&#115;&#x71;&#108;&#64;&#53;&#46;&#55;</a></li>
</ol>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">% </span><span class="language-bash">brew install mysql@5.7</span></span><br><span class="line"></span><br><span class="line">==&gt; Downloading https://ghcr.io/v2/homebrew/core/mysql/5.7/manifests/5.7.36</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">####################################################################### 100.0%</span></span></span><br><span class="line">==&gt; Downloading https://ghcr.io/v2/homebrew/core/mysql/5.7/blobs/sha256:e23df0f6e8bfc83fe2e982ec60e8</span><br><span class="line">==&gt; Downloading from https://pkg-containers.githubusercontent.com/ghcr1/blobs/sha256:e23df0f6e8bfc83</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash"><span class="comment">####################################################################### 100.0%</span></span></span><br><span class="line">==&gt; Pouring mysql@5.7--5.7.36.arm64_big_sur.bottle.tar.gz</span><br><span class="line">==&gt; /opt/homebrew/Cellar/mysql@5.7/5.7.36/bin/mysqld --initialize-insecure --user=hyunmin --basedir=</span><br><span class="line">==&gt; Caveats</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<blockquote>
<ol start="3">
<li>配置环境变量</li>
</ol>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">1. bash shell</span></span><br><span class="line"><span class="meta prompt_">% </span><span class="language-bash">vim ~/.bash_profile</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">2. zsh shell</span></span><br><span class="line"><span class="meta prompt_">% </span><span class="language-bash">vim ~/.zshrc</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">在配置文件中加入</span></span><br><span class="line">export PATH=&quot;/opt/homebrew/opt/mysql@5.7/bin:$PATH&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">% </span><span class="language-bash"><span class="built_in">source</span> ~/.bash_profile</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">或</span></span><br><span class="line"><span class="meta prompt_">% </span><span class="language-bash"><span class="built_in">source</span> ~/.zshrc</span></span><br></pre></td></tr></table></figure>

<p><img src="http://images.ysfun.cn/mac-img/image-20211124170144671.png"></p>
<blockquote>
<ol start="4">
<li>启动MySQL服务</li>
</ol>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">% </span><span class="language-bash">mysql.server start</span></span><br><span class="line"></span><br><span class="line">Starting MySQL</span><br><span class="line">. SUCCESS! </span><br></pre></td></tr></table></figure>

<blockquote>
<ol start="5">
<li>MySQL初始化配置</li>
</ol>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">% </span><span class="language-bash">mysql_secure_installation</span></span><br></pre></td></tr></table></figure>

<p><img src="http://images.ysfun.cn/mac-img/image-20211124204756469.png"></p>
<blockquote>
<ol start="6">
<li>登陆测试</li>
</ol>
</blockquote>
<p><img src="http://images.ysfun.cn/mac-img/image-20211124204950548.png"></p>
]]></content>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>mac上安装halo</title>
    <url>/2021/11/22/mac%E4%B8%8A%E5%AE%89%E8%A3%85halo/</url>
    <content><![CDATA[<h2 id="1-环境"><a href="#1-环境" class="headerlink" title="1. 环境"></a>1. 环境</h2><ul>
<li>操作系统：macOS</li>
<li>java环境：openjdk 11</li>
<li>halo版本：1.4.13</li>
</ul>
<h2 id="2-下载并安装"><a href="#2-下载并安装" class="headerlink" title="2. 下载并安装"></a>2. 下载并安装</h2><p>halo首页地址：<a href="https://halo.run/">halo首页</a><br>halo Github地址：<a href="https://github.com/halo-dev/halo">halo github地址</a></p>
<p><a href="https://docs.halo.run/getting-started/install/docker/">Docker安装halo</a></p>
<span id="more"></span>

<h3 id="2-1-安装brew"><a href="#2-1-安装brew" class="headerlink" title="2.1 安装brew"></a>2.1 安装brew</h3><p>Homebrew是 mac的包管理器，仅需执行相应的命令,就能下载安装需要的软件包，可以省掉自己去下载、解压、拖拽(安装)等繁琐的步骤。 比如安装服务器 nginx，打开终端执行以下命令即可安装:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">brew install nginx</span><br></pre></td></tr></table></figure>

<p>mac终端运行下面命令安装brew，镜像地址下载安装，速度快</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/usr/bin/ruby -e &quot;$(curl -fsSL https://cdn.jsdelivr.net/gh/ineo6/homebrew-install/install)&quot;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-安装wget"><a href="#2-2-安装wget" class="headerlink" title="2.2 安装wget"></a>2.2 安装wget</h3><p>mac终端运行下面命令</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">brew install wget</span><br></pre></td></tr></table></figure>

<h3 id="2-3-下载安装halo"><a href="#2-3-下载安装halo" class="headerlink" title="2.3 下载安装halo"></a>2.3 下载安装halo</h3><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">wget https://dl.halo.run/release/halo-1.4.13.jar</span><br><span class="line">java -jar halo-1.4.13.jar</span><br></pre></td></tr></table></figure>

<h3 id="2-4-访问halo"><a href="#2-4-访问halo" class="headerlink" title="2.4 访问halo"></a>2.4 访问halo</h3><ul>
<li>注意⚠️：在访问halo期间，运行halo程序的终端不能关闭</li>
</ul>
<p>查看halo web页面，浏览器访问：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:8090</span><br></pre></td></tr></table></figure>

<p>查看halo管理页面，浏览器访问：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1:8090/admin</span><br></pre></td></tr></table></figure>

<h3 id="2-5-说明"><a href="#2-5-说明" class="headerlink" title="2.5 说明"></a>2.5 说明</h3><p>初次运行halo程序，会在 ~ 目录下创建一个.halo的文件夹，里面包含了博客内容以及账号信息，切记不要轻易删除此文件夹，否则账号信息以及博客内容都会被删除。</p>
]]></content>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>mac使用技巧</title>
    <url>/2021/12/02/mac%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h3 id="1-Mac终端"><a href="#1-Mac终端" class="headerlink" title="1. Mac终端"></a>1. Mac终端</h3><p><a href="https://support.apple.com/zh-cn/HT208050">Mac终端官方文档</a></p>
<p>从 macOS Catalina 版开始，您的 Mac 将使用 zsh 作为默认登录 Shell 和交互式 Shell。您还可以在较低版本的 macOS 中将 zsh 设置为默认 Shell。</p>
<span id="more"></span>

<p>默认情况下，您的 Mac 使用 zsh 或 bash 作为登录 Shell 和交互式 Shell 的命令行解释器：</p>
<ul>
<li>从 macOS Catalina 版开始，<strong>zsh</strong> (Z shell) 是所有新建用户帐户的默认 Shell。</li>
<li><strong>bash</strong> 是 <a href="https://support.apple.com/zh-cn/HT201260">macOS Mojave 及更低版本</a>中的默认 Shell。</li>
</ul>
<p>zsh 与 Bourne Shell (sh) 高度兼容，并且与 bash 基本兼容，但存在一些差别。要进一步了解 zsh 及其全面的命令行完成系统，请在“终端”中输入 <code>man zsh</code>。</p>
<h4 id="从命令行中更改默认shell"><a href="#从命令行中更改默认shell" class="headerlink" title="从命令行中更改默认shell"></a>从命令行中更改默认shell</h4><p>在“终端”中，输入 <code>$ chsh -s path</code>，其中的 path 是 &#x2F;etc&#x2F;shells 中列出的某个 Shell 路径，例如 &#x2F;bin&#x2F;zsh、&#x2F;bin&#x2F;bash、&#x2F;bin&#x2F;csh、&#x2F;bin&#x2F;dash、&#x2F;bin&#x2F;ksh、&#x2F;bin&#x2F;sh 或 &#x2F;bin&#x2F;tcsh。</p>
<h4 id="终端高亮显示"><a href="#终端高亮显示" class="headerlink" title="终端高亮显示"></a>终端高亮显示</h4><p>修改配置文件，<code>~/.bash_profile</code>或<code>~/.zshrc</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export CLICOLOR=1</span><br><span class="line">export LSCOLORS=gxfxaxdxcxegedabagacad</span><br></pre></td></tr></table></figure>

<h3 id="2-Mac版IDEA快捷键"><a href="#2-Mac版IDEA快捷键" class="headerlink" title="2. Mac版IDEA快捷键"></a>2. Mac版IDEA快捷键</h3><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line"># 更多操作，如导包，引入变量</span><br><span class="line">Option+Enter</span><br><span class="line"># 将当前行复制一行到下一行</span><br><span class="line">Command+D</span><br><span class="line"># 返回上一次编辑的地方</span><br><span class="line">Command+Option+⬅️ 或 Command+[</span><br><span class="line"># 全局搜索类</span><br><span class="line">Command+O</span><br><span class="line"># 删除当前行</span><br><span class="line">Command+Delete</span><br><span class="line"># 大小写切换</span><br><span class="line">Command+Shift+U</span><br><span class="line"># 查看类的继承结构</span><br><span class="line">Ctrl+h</span><br></pre></td></tr></table></figure>

<h3 id="3-给Mac命令添加别名"><a href="#3-给Mac命令添加别名" class="headerlink" title="3. 给Mac命令添加别名"></a>3. 给Mac命令添加别名</h3><ol>
<li>修改.bash_profile（或.zshrc，取决于使用的哪个bash，新版本macOS默认是zsh）文件</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim ~/.zshrc</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 在.zshrc文件中添加alias语句 </span><br><span class="line">alias ll=&quot;ls -alF&quot;</span><br></pre></td></tr></table></figure>

<p><img src="https://images.ysfun.cn/mac-img/image-20220516164058025.png"></p>
<ol start="2">
<li>刷新文件</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure>

<h3 id="4-Mac环境变量"><a href="#4-Mac环境变量" class="headerlink" title="4. Mac环境变量"></a>4. Mac环境变量</h3><ol>
<li>Mac中环境变量加载顺序如下</li>
</ol>
<blockquote>
<p>a. 	&#x2F;etc&#x2F;profile<br>b. 	&#x2F;etc&#x2F;paths<br>c. 	~&#x2F;.bash_profile<br>d. 	~&#x2F;.bash_login<br>e. 	~&#x2F;.profile<br>f. 	~&#x2F;.bashrc</p>
</blockquote>
<p>其中a, b是系统级别</p>
<ol start="2">
<li>添加步骤</li>
</ol>
<p>推荐在c层级添加，对于最新版的Mac由于默认使用zsh shell，因此环境变量在<code>~/.zshrc</code>里修改</p>
<p>基本语法：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export PATH=&quot;$PATH:&lt;path1&gt;:&lt;path2&gt;&quot;</span><br></pre></td></tr></table></figure>

<p>其中<code>path1</code>和<code>path2</code>是自定义环境变量，多个环境变量使用<code>:</code>进行分隔。</p>
<p>注意要加上<code>$PATH</code>，否则会导致一些系统内置的命令失效。</p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>mac上使用SublimeText</title>
    <url>/2021/12/11/mac%E4%B8%8A%E4%BD%BF%E7%94%A8SublimeText/</url>
    <content><![CDATA[<blockquote>
<p>官网地址：<a href="https://www.sublimetext.com/">Sublime Text</a></p>
</blockquote>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><a href="https://www.sublimetext.com/download">官方下载地址</a></p>
<p><a href="https://www.sublimetext.com/docs/index.html">Sublime Text文档</a></p>
<span id="more"></span>

<h2 id="使用技巧"><a href="#使用技巧" class="headerlink" title="使用技巧"></a>使用技巧</h2><h3 id="在Sublime-Text上运行Java程序"><a href="#在Sublime-Text上运行Java程序" class="headerlink" title="在Sublime Text上运行Java程序"></a>在Sublime Text上运行Java程序</h3><ol>
<li>编译</li>
</ol>
<p><code>command+B</code></p>
<ol start="2">
<li>安装JDK环境</li>
<li>打开 Sublime Text -&gt; Tools -&gt;Build System -&gt; New Build System…</li>
<li>复制下面代码，并保存文件为java.sublime-build到默认的User文件夹即可</li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;shell_cmd&quot;</span><span class="punctuation">:</span> <span class="string">&quot;javac \&quot;$file\&quot; &amp;&amp; java \&quot;$file_base_name\&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;file_regex&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^(...*?):([0-9]*):?([0-9]*)&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;selector&quot;</span><span class="punctuation">:</span> <span class="string">&quot;source.java&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<ol start="5">
<li>选择Tools -&gt; Build System -&gt; java</li>
</ol>
<img src="https://images.ysfun.cn/mac-img/image-20211211145804287.png" style="zoom:50%;" align="left">

<p>Mac破解最新版Typora：<a href="https://www.macwk.com/soft/typora">macwk-typora</a></p>
<blockquote>
<p>声明：建议有能力者支持正版软件</p>
</blockquote>
]]></content>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>typora图片左对齐</title>
    <url>/2021/11/28/typora%E5%9B%BE%E7%89%87%E5%B7%A6%E5%AF%B9%E9%BD%90/</url>
    <content><![CDATA[<p>typora图片默认是剧中对齐的方式：</p>
<p><img src="http://images.ysfun.cn/mac-img/image-20211128142529931.png"> </p>
<p>但很多情况下我们其实更倾向于图片左对齐，网上很多办法都更改typora的默认对齐方式，即更改github.css文件，但这种方式会让我们所有的图片都变成左对齐的方式，实际情况下我们有的时候只需要一张图片左对齐。其实在typora中实现图片左对齐的方法非常简单，只需要<strong>在图片链接后加一个空格即可</strong>：</p>
<span id="more"></span>

<p><img src="http://images.ysfun.cn/mac-img/image-20211128143120575.png"></p>
<hr>
<h3 id="设置任意对齐方式"><a href="#设置任意对齐方式" class="headerlink" title="设置任意对齐方式"></a>设置任意对齐方式</h3><p>在<code>typora</code>中图片的默认格式为<code>![图片标题](图片url)</code></p>
<p><img src="http://images.ysfun.cn/mac-img/image-20211128151604005.png"></p>
<p>实际上markdown是兼容<code>&lt;img src=&quot;&quot;&gt;</code>图片格式的，采用img标签就可以利用<code>align</code>属性设置图片对齐方式。</p>
<p>下面介绍一种可以快速将图片格式从<code>![图片标题](图片url)</code>变为<code>&lt;img src=&quot;&quot;&gt;</code>格式，选中图片，右键，选择缩放图片，任意选择一个不是100%缩放比例（如果选择100%不会有任何变化，如果不想改变图片大小，设置<code>zoom:100</code>即可，即<code>style=&quot;zoom:100%;&quot;</code>），缩放完毕就可以发现图片格式进行自动转换，在<code>img标签中</code>添加<code>align</code>属性即可。</p>
<p><img src="http://images.ysfun.cn/mac-img/image-20211128152513094.png"></p>
]]></content>
      <tags>
        <tag>教程</tag>
        <tag>Typora</tag>
      </tags>
  </entry>
  <entry>
    <title>springBoot2中-Configuration注解新增的proxyBeanMehtods属性详解</title>
    <url>/2021/11/22/springBoot2%E4%B8%AD-Configuration%E6%B3%A8%E8%A7%A3%E6%96%B0%E5%A2%9E%E7%9A%84proxyBeanMehtods%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h2 id="Configuration-proxyBeanMethods-x3D-true-x2F-false"><a href="#Configuration-proxyBeanMethods-x3D-true-x2F-false" class="headerlink" title="@Configuration(proxyBeanMethods &#x3D; true&#x2F;false)"></a>@Configuration(proxyBeanMethods &#x3D; true&#x2F;false)</h2><h3 id="1、Full模式（proxyBeanMethods-x3D-true）"><a href="#1、Full模式（proxyBeanMethods-x3D-true）" class="headerlink" title="1、Full模式（proxyBeanMethods&#x3D;true）"></a>1、Full模式（proxyBeanMethods&#x3D;true）</h3><p>proxyBeanMethods&#x3D;true 为Full模式（默认为true），此时在spring IOC容器中的<strong>此配置类是一个CGLIB代理类</strong>，并且调用此配置类的@Bean方法产生的bean是单例的，即<strong>每次调用标有@Bean注解方法都会检查IOC容器中是否有该bean组件</strong>，如果没有则调用方法创建，否则就直接从IOC容器中获取。</p>
<h4 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h4><span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyBeanMethodTest</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">run</span> <span class="operator">=</span> SpringApplication.run(MainApplication.class, args);</span><br><span class="line">        <span class="type">ProxyBeanMethodTest</span> <span class="variable">bean</span> <span class="operator">=</span> run.getBean(ProxyBeanMethodTest.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;配置类：&quot;</span>+bean);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> bean.user();</span><br><span class="line">        <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> bean.user();</span><br><span class="line">        System.out.println(<span class="string">&quot;第一次调用配置类中的@Bean注解方法得到的bean组件：&quot;</span>+user1);</span><br><span class="line">        System.out.println(<span class="string">&quot;第二次调用配置类中的@Bean注解方法得到的bean组件：&quot;</span>+user2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h4><h4 id><a href="#" class="headerlink" title></a><img src="/2021/11/22/springBoot2%E4%B8%AD-Configuration%E6%B3%A8%E8%A7%A3%E6%96%B0%E5%A2%9E%E7%9A%84proxyBeanMehtods%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3/hyunmin/Desktop/springBoot2中-Configuration注解新增的proxyBeanMehtods属性详解/image-20210427140058050.png"></h4><p><strong>两次调用user()方法得到的是同一个user对象</strong></p>
<h3 id="2、Lite模式（proxyBeanMethods-x3D-false）"><a href="#2、Lite模式（proxyBeanMethods-x3D-false）" class="headerlink" title="2、Lite模式（proxyBeanMethods&#x3D;false）"></a>2、Lite模式（proxyBeanMethods&#x3D;false）</h3><p>proxyBeanMethods&#x3D;false 为Lite模式，此时在spring IOC容器中<strong>此配置类就是一个普通的类</strong>，每次调用此配置类中标有@Bean注解的方法时都会在IOC容器中注册新的bean组件，调用@Bean方法时无需检查IOC容器中是否存在该bean组件，<strong>可以提高效率，加速容器启动</strong></p>
<h4 id="测试代码-1"><a href="#测试代码-1" class="headerlink" title="测试代码"></a>测试代码</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = false)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyBeanMethodTest</span> &#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApplication</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">run</span> <span class="operator">=</span> SpringApplication.run(MainApplication.class, args);</span><br><span class="line">        <span class="type">ProxyBeanMethodTest</span> <span class="variable">bean</span> <span class="operator">=</span> run.getBean(ProxyBeanMethodTest.class);</span><br><span class="line">        System.out.println(<span class="string">&quot;配置类：&quot;</span>+bean);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> bean.user();</span><br><span class="line">        <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> bean.user();</span><br><span class="line">        System.out.println(<span class="string">&quot;第一次调用配置类中的@Bean注解方法得到的bean组件：&quot;</span>+user1);</span><br><span class="line">        System.out.println(<span class="string">&quot;第二次调用配置类中的@Bean注解方法得到的bean组件：&quot;</span>+user2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="运行结果-1"><a href="#运行结果-1" class="headerlink" title="运行结果"></a>运行结果</h4><h4 id="-1"><a href="#-1" class="headerlink" title></a><img src="/2021/11/22/springBoot2%E4%B8%AD-Configuration%E6%B3%A8%E8%A7%A3%E6%96%B0%E5%A2%9E%E7%9A%84proxyBeanMehtods%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3/hyunmin/Desktop/springBoot2中-Configuration注解新增的proxyBeanMehtods属性详解/image-20210427141917861.png"></h4><p><strong>两次调用user()方法得到的是不同的User对象</strong></p>
<h3 id="3、Full模式和Lite模式优劣比较"><a href="#3、Full模式和Lite模式优劣比较" class="headerlink" title="3、Full模式和Lite模式优劣比较"></a>3、Full模式和Lite模式优劣比较</h3><p><strong>Full模式</strong>可以很好地处理<strong>组件之间相互依赖</strong>的问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyBeanMethodTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setDog(dog());</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Dog <span class="title function_">dog</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">run</span> <span class="operator">=</span> SpringApplication.run(MainApplication.class, args);</span><br><span class="line">        </span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> run.getBean(User.class);</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog1</span> <span class="operator">=</span> user.getDog();</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog2</span> <span class="operator">=</span> run.getBean(Dog.class);</span><br><span class="line">        System.out.println(dog1 == dog2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由以上结果可以看出，IOC容器中的Dog与User的属性Dog是同一个对象，也更加印证了当为User对象注入Dog属性时，此Dog是从IOC容器中获取的，而并非重新调用了dog()方法。从上面的测试代码中也可以看出，使用Full模式可以确保IOC容器中同一类型的对象始终是同一个，可以很好的处理组件依赖问题。</p>
<p><strong>Lite模式</strong>免去了每次调用方法前去IOC容器中检查的过程，可以有效加速容器启动过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration(proxyBeanMethods = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyBeanMethodTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">user</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setDog(dog());</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Dog <span class="title function_">dog</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Dog</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainApplication</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ConfigurableApplicationContext</span> <span class="variable">run</span> <span class="operator">=</span> SpringApplication.run(MainApplication.class, args);</span><br><span class="line">        </span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> run.getBean(User.class);</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog1</span> <span class="operator">=</span> user.getDog();</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog2</span> <span class="operator">=</span> run.getBean(Dog.class);</span><br><span class="line">        System.out.println(dog1 == dog2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2021/11/22/springBoot2%E4%B8%AD-Configuration%E6%B3%A8%E8%A7%A3%E6%96%B0%E5%A2%9E%E7%9A%84proxyBeanMehtods%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3/hyunmin/Desktop/springBoot2中-Configuration注解新增的proxyBeanMehtods属性详解/image-20210427144808890.png" align="left"><br></p>
<h3 id="4、结论"><a href="#4、结论" class="headerlink" title="4、结论"></a>4、结论</h3><ul>
<li>配置类组件之间无依赖关系时使用Lite模式，可以省去检查容器中是否已经存在同类型组件的过程，加速容器启动</li>
<li>配置类组件之间有依赖关系，使用Full模式，方法调用得到容器中的单实例组件</li>
</ul>
<br>

<h4 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h4><p>视频讲解内容可参考尚硅谷-SpringBoot2讲解视频：<a href="https://www.bilibili.com/video/BV19K4y1L7MT?p=8">https://www.bilibili.com/video/BV19K4y1L7MT?p=8</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>vim常用命令</title>
    <url>/2021/11/28/vim%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><ol>
<li>查找命令</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查找命令</span></span><br><span class="line">/xxx</span><br><span class="line">n  # 下一个</span><br><span class="line">N  # 上一个</span><br><span class="line">:set hls  # 高亮查找</span><br><span class="line">:set nohls  # 关闭高亮查找</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>显示行号</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:set nu		# 显示行号</span><br><span class="line">:set nonu		# 取消显示行号</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<ol start="3">
<li>跳转命令</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">跳转行尾</span></span><br><span class="line"><span class="meta prompt_">$</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"><span class="comment"># 跳转行首</span></span></span><br><span class="line">0</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">光标行尾编辑</span></span><br><span class="line">A</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">光标行首编辑</span></span><br><span class="line">I</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下一行编辑</span></span><br><span class="line">o</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>高亮显示</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">:syntax on	# 开启高亮</span><br><span class="line">:syntax off		# 关闭高亮</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>代码块注释</li>
</ol>
<blockquote>
<p>行首添加注释</p>
</blockquote>
<p>ctrl+v 进入列编辑模式,向下或向上移动光标,把需要注释的行的开头标记起来,然后按大写的I,再插入注释符,比如”#”,再按Esc,就会全部注释。</p>
<blockquote>
<p>行首删除注释符号</p>
</blockquote>
<p>先按v,进入visual模式,横向选中列的个数(如单个”#”注释符号),再按Esc,再按ctrl+v 进入列编辑模式,向下或向上移动光标,选中注释部分,然后按d, 就会删除注释符号（#）。</p>
<p>个人理解就是按v的时候，横向确定代码块宽度（列数），C-v的时候纵向确定了代码块长度（行首）</p>
<ol start="6">
<li>缩进</li>
</ol>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line"># 设置Tab键的宽度为4</span><br><span class="line">:set tabstop=4</span><br><span class="line"># 自动缩进</span><br><span class="line">set autoindent</span><br></pre></td></tr></table></figure>

<ol start="7">
<li>复制粘贴</li>
</ol>
<h2 id="修改默认设置"><a href="#修改默认设置" class="headerlink" title="修改默认设置"></a>修改默认设置</h2><p>在当前用户<code>home</code>目录下创建一个.<code>vimrc</code>文件</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">&#x27;&#x27; 语法高亮</span><br><span class="line">syntax on</span><br><span class="line">&#x27;&#x27; 显示行号</span><br><span class="line">set nu</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>教程</tag>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>刷题分享：LeetCode139.单词拆分【字典树，动态规划】</title>
    <url>/2022/05/24/%E5%88%B7%E9%A2%98%E5%88%86%E4%BA%AB%EF%BC%9ALeetCode139-%E5%8D%95%E8%AF%8D%E6%8B%86%E5%88%86%E3%80%90%E5%AD%97%E5%85%B8%E6%A0%91%EF%BC%8C%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E3%80%91/</url>
    <content><![CDATA[<p><img src="https://images.ysfun.cn/mac-img/leetcode-logo.jpg"></p>
<p>题目对应<code>LeetCode</code><a href="https://leetcode.cn/problems/word-break/">139. 单词拆分</a></p>
<span id="more"></span>

<h3 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h3><p>给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。</p>
<p>注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。</p>
<blockquote>
<p>示例 1：</p>
<p>输入: s &#x3D; “leetcode”, wordDict &#x3D; [“leet”, “code”]<br>输出: true<br>解释: 返回 true 因为 “leetcode” 可以由 “leet” 和 “code” 拼接成。</p>
<p>示例 2：</p>
<p>输入: s &#x3D; “applepenapple”, wordDict &#x3D; [“apple”, “pen”]<br>输出: true<br>解释: 返回 true 因为 “applepenapple” 可以由 “apple” “pen” “apple” 拼接成。<br>     注意，你可以重复使用字典中的单词。</p>
<p>示例 3：</p>
<p>输入: s &#x3D; “catsandog”, wordDict &#x3D; [“cats”, “dog”, “sand”, “and”, “cat”]<br>输出: false</p>
</blockquote>
<h3 id="2-代码分析"><a href="#2-代码分析" class="headerlink" title="2. 代码分析"></a>2. 代码分析</h3><p>【动态规划】+【字典树】</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">wordBreak</span><span class="params">(String s, List&lt;String&gt; wordDict)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">root</span> <span class="operator">=</span> build(wordDict);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="comment">// 动态规划，转移方程：dp[i] = dp[i-k] &amp;&amp; (s[i-k,i] in wordDict)</span></span><br><span class="line">        <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            List&lt;Integer&gt; list = check(s, root, i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> idx : list) &#123;</span><br><span class="line">                <span class="comment">// 可能有多个位置匹配，只要存在一个k满足 dp[i-k] &amp;&amp; (s[i-k,i] in wordDict) == true，则dp[i]为true</span></span><br><span class="line">                <span class="keyword">if</span> (idx==<span class="number">0</span> || dp[idx-<span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 判断是否满足最右匹配</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">check</span><span class="params">(String s, Trie root, <span class="type">int</span> lastIndex)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (lastIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> s.charAt(lastIndex) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node.children[index] == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.children[index];</span><br><span class="line">            <span class="keyword">if</span> (node.isEnd) &#123;</span><br><span class="line">                <span class="comment">// 如果满足最右匹配，且到达单词末尾，将该Index加入List</span></span><br><span class="line">                list.add(lastIndex);</span><br><span class="line">            &#125;</span><br><span class="line">            lastIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 建立字典树，建立字典树的基本套路</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> Trie <span class="title function_">build</span><span class="params">(List&lt;String&gt; wordDict)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">        <span class="keyword">for</span> (String s : wordDict) &#123;</span><br><span class="line">            <span class="type">Trie</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">            <span class="comment">// 这里需要注意，单词尾部向头部遍历，方便check时的最右匹配</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=s.length()-<span class="number">1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> s.charAt(i)-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (node.children[idx] == <span class="literal">null</span>) &#123;</span><br><span class="line">                    node.children[idx] = <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.children[idx];</span><br><span class="line">            &#125;</span><br><span class="line">            node.isEnd = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 字典树的典型结构</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span>&#123;</span><br><span class="line">    Trie[] children;</span><br><span class="line">    <span class="type">boolean</span> isEnd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        children = <span class="keyword">new</span> <span class="title class_">Trie</span>[<span class="number">26</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://images.ysfun.cn/mac-img/image-20220524165305435.png"></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法题</tag>
      </tags>
  </entry>
  <entry>
    <title>孤儿进程和僵尸进程</title>
    <url>/2022/05/25/%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<p><img src="/2022/05/25/%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E5%92%8C%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/linux-1.jpg"></p>
<h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h2><p>操作系统允许一个进程创建另一个进程，而且允许子进程继承父进程所拥有的资源，当子进程被终止时，其在父进程处继承的资源应当还给父进程。同时，终止父进程时同时也会终止其所有的子进程。</p>
<span id="more"></span>

<blockquote>
<p> 注意：Linux 操作系统对于终止有子进程的父进程，会把子进程交给 1 号进程接管。</p>
</blockquote>
<p>正常情况下：子进程由父进程创建，子进程再创建新的进程。父子进程是一个<strong>异步过程</strong>，父进程永远无法预测子进程的结束，所以，当子进程结束后，它的父进程会调用wait()或waitpid()取得子进程的终止状态，回收掉子进程的资源。</p>
<h3 id="1-孤儿进程"><a href="#1-孤儿进程" class="headerlink" title="1. 孤儿进程"></a>1. 孤儿进程</h3><p><strong>孤儿进程</strong>：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</p>
<h3 id="2-僵尸进程"><a href="#2-僵尸进程" class="headerlink" title="2. 僵尸进程"></a>2. 僵尸进程</h3><p><strong>僵尸进程</strong>：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵死进程。</p>
<h2 id="2-问题危害"><a href="#2-问题危害" class="headerlink" title="2. 问题危害"></a>2. 问题危害</h2><p>注意：unix提供了一种保证父进程知道子进程状态信息的机制。</p>
<p>这种机制是：在每个进程退出的时候，内核会释放所有的资源，包括打开的文件，占用的内存等。但是仍保留一部分信息(进程号PID，退出状态，运行时间等)。直到父进程通过wait或waitpid来取时才释放。</p>
<p><strong>暴露的问题：如果父进程不调用wait或waitpid的话，那么保留的那部分信息就不会释放，进程号一直被占用着。但是系统所能使用的进程号是有限的，如果大量产生僵死进程，将因没有可用的进程号而导致系统无法产生新的进程，这就是僵尸进程的危害。</strong></p>
<p>孤儿进程是没有父进程的进程，它由init进程循环的wait()回收资源，init进程充当父进程。因此孤儿进程并没有什么危害。</p>
<blockquote>
<p>补充：任何一个子进程(init除外)在exit()之后，并非马上就消失掉，而是留下一个称为僵尸进程的数据结构，等待父进程去处理。如果父进程在子进程exit()之后，没有及时处理，出现僵尸进程，并可以用ps命令去查看，它的状态是“Z”。</p>
</blockquote>
<p>如果父进程能及时处理，可能用<code>ps</code>命令就来不及看到子进程的僵尸状态，但这并不等于子进程不经过僵尸状态。  <strong>如果父进程在子进程结束之前退出，则子进程将由init接管。init将会以父进程的身份对僵尸状态的子进程进行处理。</strong></p>
<h2 id="3-解决方案"><a href="#3-解决方案" class="headerlink" title="3. 解决方案"></a>3. 解决方案</h2><ol>
<li>kill杀死元凶父进程（一般不用）</li>
</ol>
<p>严格的说，僵尸进程并不是问题的根源，罪魁祸首是产生大量僵死进程的父进程。因此，我们可以直接除掉元凶，通过kill发送SIGTERM或者SIGKILL信号。元凶死后，僵尸进程进程变成孤儿进程，由init充当父进程，并回收资源。</p>
<ol start="2">
<li>父进程用wait或waitpid去回收资源（方案不好）</li>
</ol>
<p>父进程通过wait或waitpid等函数去等待子进程结束，但是不好，会导致父进程一直等待被挂起，相当于一个进程在干活，没有起到多进程的作用。</p>
<ol start="3">
<li>通过信号机制，在处理函数中调用wait，回收资源</li>
</ol>
<p>通过信号机制，子进程退出时向父进程发送SIGCHLD信号，父进程调用signal(SIGCHLD,sig_child)去处理SIGCHLD信号，在信号处理函数sig_child()中调用wait进行处理僵尸进程。什么时候得到子进程信号，什么时候进行信号处理，父进程可以继续干其他活，不用去阻塞等待。</p>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>将hexo博客部署到个人服务器</title>
    <url>/2022/05/18/%E5%B0%86hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0%E4%B8%AA%E4%BA%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<p>本人之前的<code>Hexo</code>博客一直都是部署在<code>GitHub</code>上的，通过<code>github.io</code>域名后缀来访问，但是国内访问<code>GitHub</code>网络一直不太稳定，因此考虑自己购买一台服务器，将个人博客部署到自己的服务器。</p>
<p><strong>主要步骤有：</strong></p>
<ul>
<li>购买服务器、域名</li>
<li>在服务器上创建<code>git</code>仓库</li>
<li>配置<code>nginx</code></li>
<li>修改本地<code>hexo</code>配置</li>
</ul>
<span id="more"></span>



<h3 id="1-购买服务器、域名"><a href="#1-购买服务器、域名" class="headerlink" title="1. 购买服务器、域名"></a>1. 购买服务器、域名</h3><p>这部分没啥技术含量，有钱就行！</p>
<p>购买服务器（各大云厂商都有免费试用活动，可以先免费试用一段时间再考虑续费），我是购买了阿里云的服务器，<a href="https://www.aliyun.com/">阿里云官网</a>，刚开始购买最低配置的应该就够了，后面有需求可以升级；购买域名，我购买的域名是(ysfun.ink)，用来部署博客的是(blogs.ysfun.ink)。</p>
<h3 id="2-在服务器上创建git仓库"><a href="#2-在服务器上创建git仓库" class="headerlink" title="2. 在服务器上创建git仓库"></a>2. 在服务器上创建git仓库</h3><p>安装<code>git</code>和<code>nginx</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum install -y nginx git</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>配置ssh免密</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">切换到root账号根目录，网上有很多教程创建新用户，后面部署的时候容易出现权限不足的情况，因此我直接用root账号</span></span><br><span class="line">cd /root</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">将本地的~/id_rsa.pub公钥内容复制到/root/.ssh/authorized_keys文件中</span></span><br><span class="line">vim /root/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>初始化<code>git</code>仓库</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建git仓库，我创建在/var/repo目录下</span></span><br><span class="line">mkdir /var/repo</span><br><span class="line">cd /var/repo</span><br><span class="line">git init --bare myblog.git</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">新建钩子文件</span></span><br><span class="line">vim /var/repo/myblog.git/hooks/post-receive</span><br></pre></td></tr></table></figure>

<p><code>post-receive</code>文件加入如下内容，注意<code>/home/blog</code>目录可自行定义，这个目录是后面网站部署的文件根目录</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">git --work-tree=/home/blog --git-dir=/var/repo/myblog.git checkout -f</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">给post-receive文件添加可执行权限</span></span><br><span class="line">chmod +x /var/repo/myblog.git/hooks/post-receive</span><br></pre></td></tr></table></figure>

<h3 id="3-配置nginx"><a href="#3-配置nginx" class="headerlink" title="3. 配置nginx"></a>3. 配置nginx</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看nginx配置文件位置</span></span><br><span class="line">nginx -t</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">修改nginx配置文件，只需要修改server_name（域名或ip地址）和root（网站文件的根目录，对应上面的/home/blog）即可</span></span><br><span class="line">vim /etc/nginx/nginx.conf</span><br></pre></td></tr></table></figure>

<p><img src="https://images.ysfun.cn/mac-img/image-20220518230056773.png"></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重启nginx</span></span><br><span class="line">systemctl restart nginx.service</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看nginx状态，看到绿色active(running)即为正常运行状态</span></span><br><span class="line">systemctl status nginx.service</span><br></pre></td></tr></table></figure>

<p><img src="https://images.ysfun.cn/mac-img/image-20220518230340561.png"></p>
<p>访问ip或者域名，如果出现<code>404</code>则表示配置失败，有问题，可以优先排查服务器是否安全组是否暴露相应端口，如<code>80, 443</code>；如果出现<code>403</code>则正常，因为目前<code>root</code>目录还没有任何文件。</p>
<p>可以在上面配置的<code>root</code>目录（对应<code>/home/blog</code>）加如下<code>index.html</code>文件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This is my Blog.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><img src="/%E5%B0%86hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0%E4%B8%AA%E4%BA%BA%E6%9C%8D%E5%8A%A1%E5%99%A8/image-20220518230659751.png"> </p>
<p>出现这样，即正常。</p>
<h3 id="4-本地修改hexo配置"><a href="#4-本地修改hexo配置" class="headerlink" title="4. 本地修改hexo配置"></a>4. 本地修改hexo配置</h3><p>修改博客根目录下的<code>_config.yml</code>，主要修改两处：<code>url</code>和<code>deploy</code></p>
<p><img src="https://images.ysfun.cn/mac-img/image-20220518230921771.png"></p>
<p>同时部署到两个仓库：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span></span><br><span class="line">    <span class="attr">github:</span> <span class="string">git@github.com:Ysfun/Ysfun.github.io.git</span></span><br><span class="line">    <span class="attr">aliyun:</span> <span class="string">root@47.110.56.85:/var/repo/myblog.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure>

<p><img src="https://images.ysfun.cn/mac-img/image-20220518231032865.png"></p>
<p>至此所有配置工作都完成了！</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">推送至个人服务器</span></span><br><span class="line">hexo g -d</span><br></pre></td></tr></table></figure>

<p>使用Ip或者域名就访问网站了！</p>
<p><img src="https://images.ysfun.cn/mac-img/image-20220518231252490.png"></p>
<p>如果想要通过域名访问，需要给域名备案，备案成功后就可以了，至此大功告成！！！</p>
<h3 id="5-启用SSL并部署"><a href="#5-启用SSL并部署" class="headerlink" title="5. 启用SSL并部署"></a>5. 启用SSL并部署</h3><ol>
<li>阿里云购买ssl证书，可以选择购买一年免费版的<a href="https://yundun.console.aliyun.com/?spm=5176.100251.top-nav.4.3d414f15HkmLHH&p=cas#/overview/cn-hangzhou">阿里云ssl证书</a></li>
<li>按照提示申请证书，申请完成后下载证书到本地</li>
<li>上传证书到远程服务器</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">scp nginx-ssl/* root@ip:/usr/local/nginx/conf/cert/  </span><br></pre></td></tr></table></figure>

<ol start="4">
<li>修改nginx配置文件</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 添加443端口server</span><br><span class="line"># Settings for a TLS enabled server.</span><br><span class="line">    server &#123;</span><br><span class="line">        listen       443 ssl http2 default_server;</span><br><span class="line">        listen       [::]:443 ssl http2 default_server;</span><br><span class="line">        server_name  www.ysfun.cn;</span><br><span class="line">        root         /home/blog;</span><br><span class="line"></span><br><span class="line">        ssl_certificate /usr/local/nginx/conf/cert/7872860_www.ysfun.cn.pem;</span><br><span class="line">        ssl_certificate_key /usr/local/nginx/conf/cert/7872860_www.ysfun.cn.key;</span><br><span class="line">#        ssl_certificate &quot;/etc/pki/nginx/server.crt&quot;;</span><br><span class="line">#        ssl_certificate_key &quot;/etc/pki/nginx/private/server.key&quot;;</span><br><span class="line">        ssl_session_cache shared:SSL:1m;</span><br><span class="line">        ssl_session_timeout  10m;</span><br><span class="line">        ssl_ciphers PROFILE=SYSTEM;</span><br><span class="line">        ssl_prefer_server_ciphers on;</span><br><span class="line"></span><br><span class="line">        # Load configuration files for the default server block.</span><br><span class="line">        include /etc/nginx/default.d/*.conf;</span><br><span class="line"></span><br><span class="line">        location / &#123;</span><br><span class="line">        &#125;</span><br><span class="line">                error_page 404 /404.html;</span><br><span class="line">            location = /40x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        error_page 500 502 503 504 /50x.html;</span><br><span class="line">            location = /50x.html &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">## http 80端口重定向</span><br><span class="line">    server &#123;</span><br><span class="line">        listen 80;</span><br><span class="line">        server_name www.ysfun.cn;</span><br><span class="line">        rewrite ^(.*)$ https://$host:443$1 permanent;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>重启nginx即可</p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>解决hexo搭建博客图片不显示问题</title>
    <url>/2021/11/28/%E8%A7%A3%E5%86%B3hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="1-问题描述"><a href="#1-问题描述" class="headerlink" title="1. 问题描述"></a>1. 问题描述</h2><p>最近使用hexo搭建博客时，使用typora编辑完博客，在hexo上部署时发现图片都不能正常显示。图片采用复制粘贴的方式插入到.md文件中，图片格式：</p>
<p><img src="http://images.ysfun.cn/mac-img/image-20211128140607589.png"></p>
<h2 id="2-初步探索"><a href="#2-初步探索" class="headerlink" title="2. 初步探索"></a>2. 初步探索</h2><ol>
<li>更改typora设置</li>
</ol>
<p>按照网上的教程，先修改typora图片插入设置，打开typora设置 -&gt; 图像，按照下面方法设置。</p>
<span id="more"></span>

<p><img src="http://images.ysfun.cn/mac-img/image-20211128141320644.png"></p>
<ol start="2">
<li>修改配置文件，打开资源文件管理功能</li>
</ol>
<p>把博客根目录下的_config.yml中的<code>post_asset_folder</code>: 设置为<code>true</code></p>
<p>Hexo将会在你每一次通过 <code>hexo new [layout] &lt;title&gt;</code> 命令创建新文章时自动创建一个文件夹。这个资源文件夹将会有与这个文章文件一样的名字。将所有与你的文章有关的资源放在这个关联文件夹中之后，你可以通过相对路径来引用它们，这样你就得到了一个更简单而且方便得多的工作流。</p>
<ol start="3">
<li>安装图片路径转换插件</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">**注意：插件不能安装最新的，安装老版本的**</span></span><br><span class="line">npm install https://github.com/EricGerry/hexo-asset-image-0.0.5.git --save</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">采用以下语句安装会出错</span></span><br><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure>

<p><img src="http://images.ysfun.cn/mac-img/image-20220531012440436.png"></p>
<p><strong>注意：按照<code>npm install https://github.com/EricGerry/hexo-asset-image-0.0.5.git --save</code>语句安装完成后无需进行后面的步骤！！！</strong></p>
<br>

<hr>
<p>执行完上述操作，按照网上大多数的说法都是可以正常显示图片的，但很无奈，经过这番配置后，重新部署仍出现这样的结果：</p>
<p><img src="/2021/11/28/%E8%A7%A3%E5%86%B3hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA%E9%97%AE%E9%A2%98/image-20211128145011881.png"></p>
<p>当场崩溃！！！ </p>
<p><img src="http://images.ysfun.cn/mac-img/038556f2580ddb0fc0ca3edb83219601.jpeg"></p>
<h2 id="3-大功告成"><a href="#3-大功告成" class="headerlink" title="3. 大功告成"></a>3. 大功告成</h2><p>经过一大番折腾，在网上查阅各种大佬的帖子，最后发现是是这个图片路径转换插件<code>hexo-asset-image</code>有问题，需要进行修改。把文件<code>/node_modules/hexo-asset-image/index.js</code>中的内容全部替换成下面的内容，其中<code>/</code>为博客根目录 。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"><span class="keyword">var</span> cheerio = <span class="built_in">require</span>(<span class="string">&#x27;cheerio&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// http://stackoverflow.com/questions/14480345/how-to-get-the-nth-occurrence-in-a-string</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getPosition</span>(<span class="params">str, m, i</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> str.<span class="title function_">split</span>(m, i).<span class="title function_">join</span>(m).<span class="property">length</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> version = <span class="title class_">String</span>(hexo.<span class="property">version</span>).<span class="title function_">split</span>(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">hexo.<span class="property">extend</span>.<span class="property">filter</span>.<span class="title function_">register</span>(<span class="string">&#x27;after_post_render&#x27;</span>, <span class="keyword">function</span>(<span class="params">data</span>)&#123;</span><br><span class="line">  <span class="keyword">var</span> config = hexo.<span class="property">config</span>;</span><br><span class="line">  <span class="keyword">if</span>(config.<span class="property">post_asset_folder</span>)&#123;</span><br><span class="line">    	<span class="keyword">var</span> link = data.<span class="property">permalink</span>;</span><br><span class="line">	<span class="keyword">if</span>(version.<span class="property">length</span> &gt; <span class="number">0</span> &amp;&amp; <span class="title class_">Number</span>(version[<span class="number">0</span>]) == <span class="number">3</span>)</span><br><span class="line">	   <span class="keyword">var</span> beginPos = <span class="title function_">getPosition</span>(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	   <span class="keyword">var</span> beginPos = <span class="title function_">getPosition</span>(link, <span class="string">&#x27;/&#x27;</span>, <span class="number">3</span>) + <span class="number">1</span>;</span><br><span class="line">	<span class="comment">// In hexo 3.1.1, the permalink of &quot;about&quot; page is like &quot;.../about/index.html&quot;.</span></span><br><span class="line">	<span class="keyword">var</span> endPos = link.<span class="title function_">lastIndexOf</span>(<span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>;</span><br><span class="line">    link = link.<span class="title function_">substring</span>(beginPos, endPos);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> toprocess = [<span class="string">&#x27;excerpt&#x27;</span>, <span class="string">&#x27;more&#x27;</span>, <span class="string">&#x27;content&#x27;</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; toprocess.<span class="property">length</span>; i++)&#123;</span><br><span class="line">      <span class="keyword">var</span> key = toprocess[i];</span><br><span class="line"> </span><br><span class="line">      <span class="keyword">var</span> $ = cheerio.<span class="title function_">load</span>(data[key], &#123;</span><br><span class="line">        <span class="attr">ignoreWhitespace</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">xmlMode</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">lowerCaseTags</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">decodeEntities</span>: <span class="literal">false</span></span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      $(<span class="string">&#x27;img&#x27;</span>).<span class="title function_">each</span>(<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">		<span class="keyword">if</span> ($(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&#x27;src&#x27;</span>))&#123;</span><br><span class="line">			<span class="comment">// For windows style path, we replace &#x27;\&#x27; to &#x27;/&#x27;.</span></span><br><span class="line">			<span class="keyword">var</span> src = $(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&#x27;src&#x27;</span>).<span class="title function_">replace</span>(<span class="string">&#x27;\\&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">			<span class="keyword">if</span>(!<span class="regexp">/http[s]*.*|\/\/.*/</span>.<span class="title function_">test</span>(src) &amp;&amp;</span><br><span class="line">			   !<span class="regexp">/^\s*\//</span>.<span class="title function_">test</span>(src)) &#123;</span><br><span class="line">			  <span class="comment">// For &quot;about&quot; page, the first part of &quot;src&quot; can&#x27;t be removed.</span></span><br><span class="line">			  <span class="comment">// In addition, to support multi-level local directory.</span></span><br><span class="line">			  <span class="keyword">var</span> linkArray = link.<span class="title function_">split</span>(<span class="string">&#x27;/&#x27;</span>).<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">elem</span>)&#123;</span><br><span class="line">				<span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">			  &#125;);</span><br><span class="line">			  <span class="keyword">var</span> srcArray = src.<span class="title function_">split</span>(<span class="string">&#x27;/&#x27;</span>).<span class="title function_">filter</span>(<span class="keyword">function</span>(<span class="params">elem</span>)&#123;</span><br><span class="line">				<span class="keyword">return</span> elem != <span class="string">&#x27;&#x27;</span> &amp;&amp; elem != <span class="string">&#x27;.&#x27;</span>;</span><br><span class="line">			  &#125;);</span><br><span class="line">			  <span class="keyword">if</span>(srcArray.<span class="property">length</span> &gt; <span class="number">1</span>)</span><br><span class="line">				srcArray.<span class="title function_">shift</span>();</span><br><span class="line">			  src = srcArray.<span class="title function_">join</span>(<span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">			  $(<span class="variable language_">this</span>).<span class="title function_">attr</span>(<span class="string">&#x27;src&#x27;</span>, config.<span class="property">root</span> + link + src);</span><br><span class="line">			  <span class="variable language_">console</span>.<span class="property">info</span>&amp;&amp;<span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&quot;update link as:--&gt;&quot;</span>+config.<span class="property">root</span> + link + src);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="variable language_">console</span>.<span class="property">info</span>&amp;&amp;<span class="variable language_">console</span>.<span class="title function_">info</span>(<span class="string">&quot;no src attr, skipped...&quot;</span>);</span><br><span class="line">			<span class="variable language_">console</span>.<span class="property">info</span>&amp;&amp;<span class="variable language_">console</span>.<span class="title function_">info</span>($(<span class="variable language_">this</span>));</span><br><span class="line">		&#125;</span><br><span class="line">      &#125;);</span><br><span class="line">      data[key] = $.<span class="title function_">html</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p>重新部署！图片正常显示！！！完美</p>
 <img src="http://images.ysfun.cn/mac-img/image-20211128150713000.png" style="zoom:67%;">
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>教程</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>BitMap应用：如何在2.5亿个无符号正整数中找出不重复的整数？</title>
    <url>/2022/05/12/BitMap%E5%BA%94%E7%94%A8%EF%BC%9A%E5%A6%82%E4%BD%95%E5%9C%A82-5%E4%BA%BF%E4%B8%AA%E6%97%A0%E7%AC%A6%E5%8F%B7%E6%AD%A3%E6%95%B4%E6%95%B0%E4%B8%AD%E6%89%BE%E5%87%BA%E4%B8%8D%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B4%E6%95%B0%EF%BC%9F/</url>
    <content><![CDATA[<h3 id="问题：如何在2-5亿个无符号正整数中找出不重复的整数，内存不足以容纳这2-5亿个整数"><a href="#问题：如何在2-5亿个无符号正整数中找出不重复的整数，内存不足以容纳这2-5亿个整数" class="headerlink" title="问题：如何在2.5亿个无符号正整数中找出不重复的整数，内存不足以容纳这2.5亿个整数"></a>问题：如何在2.5亿个无符号正整数中找出不重复的整数，内存不足以容纳这2.5亿个整数</h3><p>解法：采用BitMap，每个整数分配2个bit</p>
<blockquote>
<p>00	&#x3D;&gt; 0	表示没出现过</p>
<p>01	&#x3D;&gt; 1	表示出现过1次</p>
<p>10	&#x3D;&gt;2	表示出现过多次</p>
<p>11	&#x3D;&gt;3	表示无效数据。</p>
</blockquote>
<span id="more"></span>

<ul>
<li>内存分析</li>
</ul>
<p>每个无符号整数的取值范围为0~2^32-1，BitMap空间复杂度取决于MAX_VALUE，因此需要一个长度为2 ^ 32的BitMap，总占用空间为2^32 * 2bit &#x3D; 1 GB。</p>
<h3 id="使用Java程序进行实现："><a href="#使用Java程序进行实现：" class="headerlink" title="使用Java程序进行实现："></a>使用Java程序进行实现：</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BitMapTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * ---</span></span><br><span class="line"><span class="comment">     * 00 没出现过</span></span><br><span class="line"><span class="comment">     * 01 出现过1次</span></span><br><span class="line"><span class="comment">     * 10 出现过多次</span></span><br><span class="line"><span class="comment">     * 11 无效表示</span></span><br><span class="line"><span class="comment">     * ---</span></span><br><span class="line"><span class="comment">     * 1 byte = 8 bit，可分配四个数字，长度为1000可覆盖4000个数字，因此我们设置输入整数不超过4000</span></span><br><span class="line"><span class="comment">     * 真实情况下该数组的长度应该为 2.5亿/4，才能覆盖所有无符号整数，此处测试用较小数字进行</span></span><br><span class="line"><span class="comment">     * flags默认初始值都为0</span></span><br><span class="line"><span class="comment">     * |00 00 00 00|    |3 2 1 0| flag[0] 例如：10000100 表示3出现过多次, 2, 0都没有出现过，1出现过一次</span></span><br><span class="line"><span class="comment">     * |00 00 00 00|    |7 6 5 4| flag[1]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">byte</span>[] flags = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2000</span>];  <span class="comment">// 2000个测试输入数据</span></span><br><span class="line">        <span class="comment">// 验证结果的正确性</span></span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(nums.length);</span><br><span class="line">        <span class="type">Random</span> <span class="variable">random</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>();</span><br><span class="line">        System.out.println(<span class="string">&quot;原始数据：&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 填充随机数输入进行验证</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> random.nextInt(flags.length * <span class="number">4</span>);  <span class="comment">// flags长度为1000，整数最大只能为4000</span></span><br><span class="line">            nums[i] = num;</span><br><span class="line">            System.out.print(num + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            map.put(num, map.getOrDefault(num, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            setVal(num);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">        System.out.println(<span class="string">&quot;-------------------&quot;</span>);</span><br><span class="line">        List&lt;Integer&gt; bitMapAns = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; hashMapAns = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (getVal(nums[i]) == <span class="number">1</span>) &#123;</span><br><span class="line">                bitMapAns.add(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (map.getOrDefault(nums[i], <span class="number">0</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                hashMapAns.add(nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;只出现过一次的数据：&quot;</span>);</span><br><span class="line">        System.out.println(bitMapAns);</span><br><span class="line">        System.out.println(<span class="string">&quot;bitMapAns 是否和 hashMapAns相同：&quot;</span> + bitMapAns.equals(hashMapAns));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">setVal</span><span class="params">(<span class="type">int</span> idx)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> getVal(idx);</span><br><span class="line">        <span class="keyword">if</span> (val &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// 11 或 10 表示出现过多次，保持不变即可</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> idx / <span class="number">4</span>;  <span class="comment">// 确定在flags中的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">loc</span> <span class="operator">=</span> idx % <span class="number">4</span>;  <span class="comment">// 确定在一个byte中的位置</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        假设flags[0] = 0b10010100</span></span><br><span class="line"><span class="comment">        |00 00 00 00|    |3 2 1 0|</span></span><br><span class="line"><span class="comment">        idx = 2  =&gt; pos = 2/4 = 0;  loc = 2%4 = 2</span></span><br><span class="line"><span class="comment">        ~(3&lt;&lt;loc) =&gt; 11001111 即让2bit对应位置为0，其他都为1</span></span><br><span class="line"><span class="comment">        (flags[pos] &amp; ~(3&lt;&lt;loc)) =&gt; 效果就是让2bit对应位置置为00，其他为保持不变</span></span><br><span class="line"><span class="comment">        | ((val + 1) &lt;&lt; loc) =&gt; 效果就是让val+1的值填充2bit的位置</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">newVal</span> <span class="operator">=</span> (flags[pos] &amp; ~(<span class="number">3</span> &lt;&lt; (loc * <span class="number">2</span>))) | ((val + <span class="number">1</span>) &lt;&lt; (loc * <span class="number">2</span>));</span><br><span class="line">        flags[pos] = (<span class="type">byte</span>) newVal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getVal</span><span class="params">(<span class="type">int</span> idx)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pos</span> <span class="operator">=</span> idx / <span class="number">4</span>;  <span class="comment">// 确定在flags中的位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">loc</span> <span class="operator">=</span> idx % <span class="number">4</span>;  <span class="comment">// 确定在一个byte中的位置</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        假设flags[0] = 0b10010100</span></span><br><span class="line"><span class="comment">        |00 00 00 00|    |3 2 1 0|</span></span><br><span class="line"><span class="comment">        idx = 2  =&gt; pos = 2/4 = 0;  loc = 2%4 = 2</span></span><br><span class="line"><span class="comment">        flags[pos] &gt;&gt; (loc * 2)  =&gt; 00001001  (左边自动补0) 这个操作的效果是让2这个整数在bitmap中对应的两个bit移动到最右端</span></span><br><span class="line"><span class="comment">        拿上面的结果  (0b00001001) &amp; (byte)3  =&gt; (0b00001001) &amp; (0b00000011) =&gt; (0b00000001) 即可得到目标的两个bit对应的数字</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">val</span> <span class="operator">=</span> (flags[pos] &gt;&gt; (loc * <span class="number">2</span>)) &amp; (<span class="type">byte</span>) <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">return</span> val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行结果：</p>
<p><img src="https://images.ysfun.cn/mac-img/image-20220512221937915.png"></p>
<p>上述通过<code>HashMap</code>的方案可以检验<code>BitMap</code>的答案是正确的，并且成功节省了内存空间。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客Next主题安装配置教程</title>
    <url>/2022/05/31/Hexo%E5%8D%9A%E5%AE%A2Next%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/</url>
    <content><![CDATA[<p><img src="/2022/05/31/Hexo%E5%8D%9A%E5%AE%A2Next%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/apple-touch-icon-next.png"></p>
<p>链接直达：<a href="https://hexo.io/zh-cn/">Hexo主页</a>	<a href="https://github.com/next-theme/hexo-theme-next">Next主题地址</a>	<a href="https://theme-next.js.org/docs/getting-started/">Next文档地址</a></p>
<span id="more"></span>

<h2 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h2><table>
<thead>
<tr>
<th>版本</th>
<th>年份</th>
<th>仓库</th>
</tr>
</thead>
<tbody><tr>
<td>v5.1.4 或更低</td>
<td>2014 ~ 2017</td>
<td><a href="https://github.com/iissnan/hexo-theme-next">iissnan&#x2F;hexo-theme-next</a></td>
</tr>
<tr>
<td>v6.0.0 ~ v7.8.0</td>
<td>2018 ~ 2019</td>
<td><a href="https://github.com/theme-next/hexo-theme-next">theme-next&#x2F;hexo-theme-next</a></td>
</tr>
<tr>
<td>v8.0.0 或更高</td>
<td>2020</td>
<td><a href="https://github.com/next-theme/hexo-theme-next">next-theme&#x2F;hexo-theme-next</a></td>
</tr>
</tbody></table>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul>
<li><code>npm</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-theme-next</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用npm安装要求Hexo是5.0及以后的版本</p>
</blockquote>
<ul>
<li><code>git</code></li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/next-theme/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>

<p>指定版本安装：(以8.0.0版本为例)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-theme-next@8.0.0</span><br></pre></td></tr></table></figure>

<p><a href="https://github.com/next-theme/hexo-theme-next/releases">Next历史发行版本</a></p>
<p>Hexo及插件版本：</p>
<p><img src="https://images.ysfun.cn/mac-img/image-20220610105650366.png"></p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p><a href="https://theme-next.js.org/docs/getting-started/configuration.html">Next配置官方文档</a></p>
<ul>
<li>使用<code>Git</code>安装的配置文件位于<code>/themes/next/_config.yml</code></li>
<li>使用<code>npm</code>安装的配置文件位于<code>node_modules/hexo-theme-next/_config.yml _config.next.yml</code></li>
</ul>
<p>其中第一个&#96;&#x2F;表示博客根目录</p>
<h3 id="1-风格"><a href="#1-风格" class="headerlink" title="1. 风格"></a>1. 风格</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="comment"># scheme: Muse</span></span><br><span class="line"><span class="comment"># scheme: Mist</span></span><br><span class="line"><span class="comment"># scheme: Pisces</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Gemini</span></span><br></pre></td></tr></table></figure>

<h3 id="2-不蒜子访客统计"><a href="#2-不蒜子访客统计" class="headerlink" title="2. 不蒜子访客统计"></a>2. 不蒜子访客统计</h3><p>将<code>busuanzi_count.enable</code>设为<code>true</code>即可</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Show Views / Visitors of the website / page with busuanzi.</span></span><br><span class="line"><span class="comment"># For more information: http://ibruce.info/2015/04/04/busuanzi/</span></span><br><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_visitors:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_visitors_icon:</span> <span class="string">fa</span> <span class="string">fa-user</span></span><br><span class="line">  <span class="attr">total_views:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_views_icon:</span> <span class="string">fa</span> <span class="string">fa-eye</span></span><br><span class="line">  <span class="attr">post_views:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">post_views_icon:</span> <span class="string">far</span> <span class="string">fa-eye</span></span><br></pre></td></tr></table></figure>

<h3 id="3-代码高亮"><a href="#3-代码高亮" class="headerlink" title="3. 代码高亮"></a>3. 代码高亮</h3><figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="attr">codeblock:</span></span><br><span class="line">  <span class="comment"># Code Highlight theme</span></span><br><span class="line">  <span class="comment"># All available themes: https://theme-next.js.org/highlight/</span></span><br><span class="line">  <span class="attr">theme:</span></span><br><span class="line">    <span class="attr">light:</span> <span class="string">rainbow</span></span><br><span class="line">    <span class="attr">dark:</span> <span class="string">vs2015</span></span><br><span class="line">  <span class="attr">prism:</span></span><br><span class="line">    <span class="attr">light:</span> <span class="string">prism</span></span><br><span class="line">    <span class="attr">dark:</span> <span class="string">prism-dark</span></span><br><span class="line">  <span class="comment"># Add copy button on codeblock</span></span><br><span class="line">  <span class="attr">copy_button:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="comment"># Available values: default | flat | mac</span></span><br><span class="line">    <span class="attr">style:</span> <span class="string">default</span></span><br></pre></td></tr></table></figure>

<p>内置代码高亮样式在<code>/node_modules/highlight.js/styles</code>目录下，也可在<a href="https://theme-next.js.org/highlight/">NexT Highlight Theme Preview</a>进行预览。</p>
<h3 id="4-显示分类和标签"><a href="#4-显示分类和标签" class="headerlink" title="4. 显示分类和标签"></a>4. 显示分类和标签</h3><ol>
<li>文章<code>header</code>部分添加</li>
</ol>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">tags: Hexo</span><br><span class="line">categories: 教程</span><br></pre></td></tr></table></figure>

<p><img src="https://images.ysfun.cn/mac-img/image-20220531150131104.png"></p>
<ol start="2">
<li>新建<code>page</code></li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo n page tags</span><br><span class="line">hexo n page categories</span><br></pre></td></tr></table></figure>

<p>此时会在<code>/source</code>目录下新增两个文件夹<code>tags</code>和<code>categories</code>，且两个目录下都有一个<code>index.md</code>文件</p>
<ol start="3">
<li>修改<code>index.md</code></li>
</ol>
<p>分别在<code>tags</code>和<code>categories</code>两个文件夹的<code>index.md</code>文件头部添加<code>type</code></p>
<p><img src="https://images.ysfun.cn/mac-img/image-20220531150829131.png"> </p>
<p><img src="https://images.ysfun.cn/mac-img/image-20220531150748063.png"> </p>
<ol start="4">
<li>侧边栏显示标签和分类</li>
</ol>
<p>修改Next主题配置文件<code>_config.next.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Usage: `Key: /link/ || icon`</span></span><br><span class="line"><span class="comment"># Key is the name of menu item. If the translation for this item is available, the translated text will be loaded, otherwise the Key name will be used. Key is case-sensitive.</span></span><br><span class="line"><span class="comment"># Value before `||` delimiter is the target link, value after `||` delimiter is the name of Font Awesome icon.</span></span><br><span class="line"><span class="comment"># External url should start with http:// or https://</span></span><br><span class="line"><span class="attr">menu:</span></span><br><span class="line">  <span class="attr">home:</span> <span class="string">/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-home</span></span><br><span class="line">  <span class="comment">#about: /about/ || fa fa-user</span></span><br><span class="line">  <span class="attr">tags:</span> <span class="string">/tags/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-tags</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="string">/categories/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-th</span></span><br><span class="line">  <span class="attr">archives:</span> <span class="string">/archives/</span> <span class="string">||</span> <span class="string">fa</span> <span class="string">fa-archive</span></span><br><span class="line">  <span class="comment">#schedule: /schedule/ || fa fa-calendar</span></span><br><span class="line">  <span class="comment">#sitemap: /sitemap.xml || fa fa-sitemap</span></span><br><span class="line">  <span class="comment">#commonweal: /404/ || fa fa-heartbeat</span></span><br></pre></td></tr></table></figure>

<h3 id="5-背景配置"><a href="#5-背景配置" class="headerlink" title="5. 背景配置"></a>5. 背景配置</h3><h4 id="更改标题黑色背景"><a href="#更改标题黑色背景" class="headerlink" title="更改标题黑色背景"></a>更改标题黑色背景</h4><ol>
<li>打开<code>Hexo/themes/next/source/css/_schemes/Pisces/_header.styl</code>，找到<code>background</code>改为<code>background: $blue-bright;</code>。</li>
</ol>
<blockquote>
<p> 标题背景颜色默认为：<code>background: var(--theme-color);</code>，即默认为主题颜色，可直接在<code>_config.next.yml</code>配置文件中修改<code>theme_color:</code>即可改变背景颜色</p>
<p><a href="https://theme-next.js.org/docs/theme-settings/miscellaneous.html#Theme-Color">修改背景颜色官方文档</a></p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme_color:</span></span><br><span class="line">  <span class="attr">light:</span> <span class="string">&quot;#222&quot;</span></span><br><span class="line">  <span class="attr">dark:</span> <span class="string">&quot;#222&quot;</span></span><br></pre></td></tr></table></figure>

<p><a href="http://tools.jb51.net/static/colorpicker/">在线颜色选择器 | RGB颜色查询对照表</a></p>
<ol start="2">
<li><p>打开<code>Hexo\themes\next\source\css\_variables\Pisces.styl</code>，找到<code>subtitle-color</code>改为<code>$subtitle-color = $whitesmoke;</code></p>
</li>
<li><p>在<code>Hexo/themes/next/source/css/_variables/base.styl</code>里可以查看颜色设置。</p>
</li>
</ol>
<h4 id="添加图片背景"><a href="#添加图片背景" class="headerlink" title="添加图片背景"></a>添加图片背景</h4><ol>
<li>在hexo目录下的<code>source</code>文件夹下新建<code>_data</code>文件夹，不是主题next目录下的source文件夹。文件夹里新建文件<code>styles.styl</code>，添加如下内容：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//背景图片设置</span></span><br><span class="line">body &#123;</span><br><span class="line">    background-<span class="attr">image</span>: <span class="title function_">url</span>(<span class="regexp">/images/</span>background.<span class="property">jpg</span>); </span><br><span class="line">    background-<span class="attr">repeat</span>: no-repeat;</span><br><span class="line">    background-<span class="attr">attachment</span>: fixed;</span><br><span class="line">    background-<span class="attr">size</span>: <span class="number">100</span>% <span class="number">100</span>%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>background-image:url</code> 可以直接使用图片链接，也可以是图片路径（将自定义图片放入next\source\images） </p>
<p><code>background-repeat：</code>若果背景图片不能全屏，那么是否平铺显示，充满屏幕 </p>
<p><code>background-attachment：</code>背景是否随着网页上下滚动而滚动，fixed 为固定 </p>
<p><code>background-size：</code>图片展示大小，设置 100%，100% 的意义为：如果背景图片不能全屏，那么是否通过拉伸的方式将背景强制拉伸至全屏显示</p>
<ol>
<li>打开主题配置文件，找到<code>custom_file_path:</code>，修改如下：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">custom_file_path</span>:</span><br><span class="line">  <span class="attr">style</span>: source/_data/styles.<span class="property">styl</span></span><br></pre></td></tr></table></figure>

<h4 id="页面透明化"><a href="#页面透明化" class="headerlink" title="页面透明化"></a>页面透明化</h4><p>为了更好欣赏背景图片，可将博客页面透明化，在<code>source/_data/styles.styl</code>里添加如下内容：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//文章透明度设置</span></span><br><span class="line">.<span class="property">post</span>-block &#123;</span><br><span class="line">  <span class="attr">opacity</span>: <span class="number">0.9</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//侧边框的透明度设置</span></span><br><span class="line">.<span class="property">sidebar</span> &#123;</span><br><span class="line">  background-<span class="attr">color</span>: transparent;</span><br><span class="line">  <span class="attr">opacity</span>: <span class="number">0.9</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//菜单栏的透明度设置</span></span><br><span class="line">.<span class="property">header</span>-inner &#123;</span><br><span class="line">  <span class="attr">background</span>: <span class="title function_">rgba</span>(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>,<span class="number">0.9</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//搜索框（local-search）的透明度设置</span></span><br><span class="line">.<span class="property">popup</span> &#123;</span><br><span class="line">  <span class="attr">opacity</span>: <span class="number">0.9</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="边框圆角"><a href="#边框圆角" class="headerlink" title="边框圆角"></a>边框圆角</h4><ol>
<li>在hexo目录下的<code>source</code>文件夹下新建<code>_data</code>文件夹，文件夹中新建文件<code>variables.styl</code>，添加如下内容：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 圆角设置</span></span><br><span class="line">$border-radius-inner     = 20px 20px 20px 20px;</span><br><span class="line">$border-radius           = 20px;</span><br></pre></td></tr></table></figure>

<ol>
<li>打开主题配置文件，找到<code>custom_file_path:</code>，修改如下：</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">custom_file_path</span>:</span><br><span class="line">  <span class="attr">variable</span>: source/_data/variables.<span class="property">styl</span></span><br></pre></td></tr></table></figure>

<h3 id="6-字数统计"><a href="#6-字数统计" class="headerlink" title="6. 字数统计"></a>6. 字数统计</h3><ol>
<li>安装插件</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-word-counter</span><br></pre></td></tr></table></figure>

<p>配置查看<a href="https://theme-next.js.org/docs/theme-settings/posts.html#Post-Wordcount">字数统计文档</a></p>
<h3 id="7-fancybox"><a href="#7-fancybox" class="headerlink" title="7. fancybox"></a>7. fancybox</h3><p>fancybox 可以在点击图片时放大该图片，并且可以快速浏览当前文章的所有图片</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># FancyBox is a tool that offers a nice and elegant way to add zooming functionality for images.</span></span><br><span class="line"><span class="comment"># For more information: https://fancyapps.com/fancybox/</span></span><br><span class="line"><span class="attr">fancybox:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="8-版权声明"><a href="#8-版权声明" class="headerlink" title="8. 版权声明"></a>8. 版权声明</h3><p>NexT 内置了文章末尾增加版权声明，只需手动开启即可</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Creative Commons 4.0 International License.</span></span><br><span class="line"><span class="comment"># See: https://creativecommons.org/about/cclicenses/</span></span><br><span class="line"><span class="attr">creative_commons:</span></span><br><span class="line">  <span class="comment"># Available values: by | by-nc | by-nc-nd | by-nc-sa | by-nd | by-sa | cc-zero</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">by-nc-sa</span></span><br><span class="line">  <span class="comment"># Available values: big | small</span></span><br><span class="line">  <span class="attr">size:</span> <span class="string">small</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">post:</span> <span class="literal">true</span>  <span class="comment"># 将此处置为true即可</span></span><br><span class="line">  <span class="comment"># You can set a language value if you prefer a translated version of CC license, e.g. deed.zh</span></span><br><span class="line">  <span class="comment"># CC licenses are available in 39 languages, you can find the specific and correct abbreviation you need on https://creativecommons.org</span></span><br><span class="line">  <span class="attr">language:</span></span><br></pre></td></tr></table></figure>

<h3 id="9-置顶"><a href="#9-置顶" class="headerlink" title="9. 置顶"></a>9. 置顶</h3><p><img src="/2022/05/31/Hexo%E5%8D%9A%E5%AE%A2Next%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/image-20220531182846937.png"></p>
<p>文章<code>header</code>添加<code>sticky</code>，将会按照sticky值从大到小排序展示，默认为0</p>
<p><img src="https://images.ysfun.cn/mac-img/image-20220531183020834.png"></p>
<h3 id="10-更改字体"><a href="#10-更改字体" class="headerlink" title="10. 更改字体"></a>10. 更改字体</h3><p><code>_config.next.yml</code>中<code>font</code>配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Font Settings</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Find fonts on Google Fonts (https://fonts.google.com)</span></span><br><span class="line"><span class="comment"># All fonts set here will have the following styles:</span></span><br><span class="line"><span class="comment">#   light | light italic | normal | normal italic | bold | bold italic</span></span><br><span class="line"><span class="comment"># Be aware that setting too much fonts will cause site running slowly</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"><span class="comment"># Web Safe fonts are recommended for `global` (and `title`):</span></span><br><span class="line"><span class="comment"># Arial | Tahoma | Helvetica | Times New Roman | Courier New | Verdana | Georgia | Palatino | Garamond | Comic Sans MS | Trebuchet MS</span></span><br><span class="line"><span class="comment"># ---------------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line"><span class="attr">font:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Uri of fonts host, e.g. https://fonts.googleapis.com (Default).</span></span><br><span class="line">  <span class="attr">host:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font options:</span></span><br><span class="line">  <span class="comment"># `external: true` will load this font family from `host` above.</span></span><br><span class="line">  <span class="comment"># `family: Times New Roman`. Without any quotes.</span></span><br><span class="line">  <span class="comment"># `size: x.x`. Use `em` as unit. Default: 1 (16px)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Global font settings used for all elements inside &lt;body&gt;.</span></span><br><span class="line">  <span class="attr">global:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span> <span class="string">Noto</span> <span class="string">Serif</span> <span class="string">SC</span></span><br><span class="line">    <span class="comment">#family: Lato</span></span><br><span class="line">    <span class="attr">size:</span> <span class="number">0.8</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for site title (.site-title).</span></span><br><span class="line">  <span class="attr">title:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span></span><br><span class="line">    <span class="attr">size:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Font settings for headlines (&lt;h1&gt; to &lt;h6&gt;).</span></span><br><span class="line">  <span class="attr">headings:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span></span><br><span class="line">    <span class="attr">size:</span></span><br></pre></td></tr></table></figure>

<h3 id="11-相关文章"><a href="#11-相关文章" class="headerlink" title="11. 相关文章"></a>11. 相关文章</h3><p><a href="https://theme-next.js.org/docs/theme-settings/posts.html#Related-Popular-Posts">Related-Popular-Posts官方文档</a></p>
<ol>
<li>安装插件</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-related-posts</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改<code>_config.next.yml</code></li>
</ol>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">related_posts:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>相关文章只显示时间和标题，不显示内容</li>
</ol>
<p>修改<code>/themes/next/layout/_partials/post/post-related.njk</code>删除以下内容：</p>
<p><img src="/2022/05/31/Hexo%E5%8D%9A%E5%AE%A2Next%E4%B8%BB%E9%A2%98%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE%E6%95%99%E7%A8%8B/image-20220601000152152.png"></p>
<ol start="4">
<li>修复相关文章无法跳转问题</li>
</ol>
<p>查看跳转链接可以发现，相关文章的路径是基于当前文章的，说明跳转连接用的是相对路径导致这个问题的，因此只需要采用绝对路径进行跳转即可。</p>
<p><img src="https://images.ysfun.cn/mac-img/image-20220601114943783.png"></p>
<p>修改<code>/themes/next/layout/_partials/post/post-related.njk</code>，在跳转路径前面加上<code>/</code>即可</p>
<p><img src="https://images.ysfun.cn/mac-img/image-20220601114732112.png"></p>
<h3 id="12-Tags显示在文章头部"><a href="#12-Tags显示在文章头部" class="headerlink" title="12. Tags显示在文章头部"></a>12. Tags显示在文章头部</h3><p>默认标签是显示在文章尾部的：</p>
<p><img src="https://images.ysfun.cn/mac-img/image-20220601011651834.png"></p>
<p>但在文章尾部不容易观察到，现令其显示在文章头部，效果如图：</p>
<p><img src="https://images.ysfun.cn/mac-img/image-20220601010935179.png"></p>
<p>在<code>/themes/next/layout/_partials/post/post-meta.njk</code>文件中添加如下内容：</p>
<p><img src="https://images.ysfun.cn/mac-img/image-20220601011103847.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;# custom tags #&#125;</span><br><span class="line">&#123;%- if post.tags and post.tags.length %&#125;</span><br><span class="line">  &#123;%- set tag_indicate = &#x27;&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt;&#x27; if theme.tag_icon else &#x27;#&#x27; %&#125;</span><br><span class="line">  &lt;span class=&quot;post-meta-item&quot;&gt;</span><br><span class="line">    &#123;%- for tag in post.tags.toArray() %&#125;</span><br><span class="line">      &lt;a href=&quot;&#123;&#123; url_for(tag.path) &#125;&#125;&quot; rel=&quot;tag&quot;&gt;&#123;&#123; tag_indicate &#125;&#125; &#123;&#123; tag.name &#125;&#125;&lt;/a&gt;</span><br><span class="line">    &#123;%- endfor %&#125;</span><br><span class="line">  &lt;/span&gt;</span><br><span class="line">&#123;%- endif %&#125;</span><br></pre></td></tr></table></figure>

<p>想要tag标签不在文章末尾显示，删除<code>/themes/next/layout/_macro/post.njk</code>文件中的如下内容即可：</p>
<p><img src="https://images.ysfun.cn/mac-img/image-20220601011527075.png"></p>
<h3 id="13-back-to-top"><a href="#13-back-to-top" class="headerlink" title="13. back to top"></a>13. back to top</h3><p><a href="https://theme-next.js.org/docs/theme-settings/miscellaneous.html?highlight=back2#Back-To-Top">Back To Top文档</a></p>
<p><code>_config.next.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">back2top:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Back to top in sidebar.</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Scroll percent label in b2t button.</span></span><br><span class="line">  <span class="attr">scrollpercent:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h4 id="修改滚轮的大小，默认太小了，不易观察"><a href="#修改滚轮的大小，默认太小了，不易观察" class="headerlink" title="修改滚轮的大小，默认太小了，不易观察"></a>修改滚轮的大小，默认太小了，不易观察</h4><p><img src="https://images.ysfun.cn/mac-img/image-20220601014140701.png"></p>
<p>滚轮样式定义在<code>/themes/next/source/css/_common/components/back-to-top.styl</code>文件中，查看该文件发现具体的大小有变量表示，其值定义在<code>/themes/next/source/css/_variables/base.styl</code>文件中</p>
<p><img src="https://images.ysfun.cn/mac-img/image-20220601014407611.png"></p>
<p>默认大小为<code>12px</code>，现将其改为<code>16px</code></p>
<p><img src="https://images.ysfun.cn/mac-img/image-20220601014550281.png"></p>
<p>查看效果：</p>
<p><img src="https://images.ysfun.cn/mac-img/image-20220601014711402.png"></p>
<h3 id="14-添加备案信息"><a href="#14-添加备案信息" class="headerlink" title="14. 添加备案信息"></a>14. 添加备案信息</h3><p>修改<code>_config.next.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Beian ICP and gongan information for Chinese users. See: https://beian.miit.gov.cn, http://www.beian.gov.cn</span></span><br><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="attr">beian:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">icp:</span>   <span class="comment"># 备案号</span></span><br><span class="line">    <span class="comment"># The digit in the num of gongan beian.</span></span><br><span class="line">    <span class="attr">gongan_id:</span>   <span class="comment"># 公安备案号</span></span><br><span class="line">    <span class="comment"># The full num of gongan beian.</span></span><br><span class="line">    <span class="attr">gongan_num:</span>   <span class="comment"># 备案链接</span></span><br><span class="line">    <span class="comment"># The icon for gongan beian. See: http://www.beian.gov.cn/portal/download</span></span><br><span class="line">    <span class="attr">gongan_icon_url:</span>   <span class="string">公安备案图标</span></span><br></pre></td></tr></table></figure>

<h3 id="15-首页和归档页单页显示数量"><a href="#15-首页和归档页单页显示数量" class="headerlink" title="15. 首页和归档页单页显示数量"></a>15. 首页和归档页单页显示数量</h3><p><code>_config.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Home page setting</span></span><br><span class="line"><span class="comment"># path: Root path for your blogs index page. (default = &#x27;&#x27;)</span></span><br><span class="line"><span class="comment"># per_page: Posts displayed per page. (0 = disable pagination)</span></span><br><span class="line"><span class="comment"># order_by: Posts order. (Order by date descending by default)</span></span><br><span class="line"><span class="attr">index_generator:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="number">5</span></span><br><span class="line">  <span class="attr">order_by:</span> <span class="string">-date</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 归档页面</span></span><br><span class="line"><span class="attr">archive_generator:</span></span><br><span class="line">  <span class="attr">per_page:</span> <span class="number">50</span></span><br><span class="line">  <span class="attr">yearly:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">monthly:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

<h3 id="16-添加Waline评论系统"><a href="#16-添加Waline评论系统" class="headerlink" title="16. 添加Waline评论系统"></a>16. 添加<code>Waline</code>评论系统</h3><p><a href="https://blog.csdn.net/jiunian_2761/article/details/122621667?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-2-122621667-null-null.pc_agg_new_rank&utm_term=next%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F&spm=1000.2123.3001.4430">配置教程</a>  <a href="https://waline.js.org/guide/get-started.html">Waline快速上手</a></p>
<p><a href="https://console.leancloud.app/apps/h0soSuJNhU2GGHG4pTu7Le4d-MdYXbMMI/">LearnCloud地址</a></p>
<p><a href="https://waline.js.org/">Waline地址</a></p>
<p><a href="https://vercel.com/">Vercel地址</a></p>
<p><strong>评论管理 (管理端)</strong></p>
<ol>
<li>部署完成后，请访问 <code>&lt;serverURL&gt;/ui/register</code> 进行注册。首个注册的人会被设定成管理员。</li>
<li>管理员登陆后，即可看到评论管理界面。在这里可以修改、标记或删除评论。</li>
<li>用户也可通过评论框注册账号，登陆后会跳转到自己的档案页。</li>
</ol>
<p><code>Hexo-waline-next</code>插件使用<a href="https://github.com/rqh656418510">rqh656418510</a>&#x2F;<strong><a href="https://github.com/rqh656418510/hexo-waline-next">hexo-waline-next</a></strong></p>
<p>安装插件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">npm install hexo-waline-next --save</span><br></pre></td></tr></table></figure>

<h3 id="17-自定义Page"><a href="#17-自定义Page" class="headerlink" title="17. 自定义Page"></a>17. 自定义Page</h3><ol>
<li>生成page</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new page &quot;xxx&quot;</span><br></pre></td></tr></table></figure>

<p>会自动生成&#x2F;source&#x2F;xxx&#x2F;index.md</p>
<ol start="2">
<li>启用page</li>
</ol>
<p>修改<code>_config.next.yml</code>文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  精选: /recommend/ || fa fa-star</span><br></pre></td></tr></table></figure>

<p><a href="https://fontawesome.dashgame.com/">图标库地址</a></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL:InnoDB存储引擎和MyISAM的区别？</title>
    <url>/2022/05/13/MySQL-Innodb%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%92%8CMyisam%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/</url>
    <content><![CDATA[<p><img src="/2022/05/13/MySQL-Innodb%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%92%8CMyisam%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F/mysql-logo-800-400.jpg"></p>
<p>本文从<strong>事务</strong>，<strong>外键</strong>，<strong>索引</strong>， <strong>存储文件</strong>，<strong>日志</strong>，<strong>count行数</strong>，<strong>锁</strong>，<strong>主键</strong>八个方面系统地对比了在<code>MySQL</code>中<code>InnoDB</code>存储引擎和<code>MyISAM</code>存储引擎的区别。</p>
<span id="more"></span>

<h3 id="1-事务"><a href="#1-事务" class="headerlink" title="1. 事务"></a>1. 事务</h3><ul>
<li><p><code>InnoDB</code>：支持事务。</p>
</li>
<li><p><code>MyISAM</code>：不支持事务，强调的是性能，每次查询具有原子性，一般情况下其查询数度比<code>InnoDB</code>更快，但是不提供事务支持。</p>
</li>
</ul>
<blockquote>
<p>一般情况下<code>MyISAM</code>查询速度比<code>InnoDB</code>快的原因：</p>
<p>答：在查询的时候，InnoDB要维护的东西比MyISAM多很多，具体以下几点：</p>
<ul>
<li>InnoDB缓存数据块，MyISAM只缓存索引块， 这中间还有换进换出的减少；</li>
<li>InnoDB寻址要映射到块，再到行，MyISAM记录的直接是文件的OFFSET，定位比InnoDB要快 </li>
<li>InnoDB还需要维护MVCC一致； 虽然你的场景没有，但他还是需要去检查和维护</li>
</ul>
</blockquote>
<h3 id="2-外键"><a href="#2-外键" class="headerlink" title="2. 外键"></a>2. 外键</h3><ul>
<li><code>InnoDB</code>：支持外键</li>
<li><code>MyISAM</code>：不支持外键，对一个包含外键的InnoDB表转为MyISAM会失败</li>
</ul>
<h3 id="3-索引"><a href="#3-索引" class="headerlink" title="3. 索引"></a>3. 索引</h3><ul>
<li><code>InnoDB</code>：聚集索引，数据文件和索引存储在一起，必须要有主键，通过主键查询效率很高，一次查询即可得到完整的行数据。辅助索引存储的数据是对应的主键索引的值，通过辅助索引查询需要两次查询，根据辅助索引查询到对应的主键索引，再根据主键索引查询到对应的行数据（这一过程称之为<strong>回表</strong>）。</li>
<li><code>MyISAM</code>：非聚集索引，索引和数据文件分开保存，索引保存的是数据文件的指针。主键索引和辅助索引相互独立。</li>
</ul>
<blockquote>
<p>InnoDB的B+树主键索引的叶子节点就是数据文件，辅助索引的叶子节点是主键的值；而MyISAM的B+树主键索引和辅助索引的叶子节点都是数据文件的地址指针。</p>
</blockquote>
<p><img src="https://images.ysfun.cn/mac-img/image-20220513130213185.png"></p>
<p><img src="https://images.ysfun.cn/mac-img/image-20220513130322302.png"></p>
<h3 id="4-存储文件"><a href="#4-存储文件" class="headerlink" title="4. 存储文件"></a>4. 存储文件</h3><ul>
<li><code>InnoDB</code>：存储文件有<strong>frm、ibd</strong>，<strong>frm</strong>是表定义文件，<strong>ibd</strong>是数据文件。</li>
<li><code>MyISAM</code>：存储文件有<strong>frm、myd、myi</strong>，<strong>frm</strong>是表定义文件，<strong>myd</strong>是数据文件，<strong>myi</strong>是索引文件。</li>
</ul>
<h3 id="5-日志"><a href="#5-日志" class="headerlink" title="5. 日志"></a>5. 日志</h3><ul>
<li><code>InnoDB</code>：有<code>redo log</code>，使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态，这个恢复的过程依赖于 <code>redo log</code> 。 <code>redo log</code> 保证事务的持久性， <code>undo log</code> 保证事务的原子性。</li>
<li><code>MyISAM</code>：没有<code>redo log</code>，不支持数据库异常崩溃后的安全恢复。</li>
</ul>
<h3 id="6-count"><a href="#6-count" class="headerlink" title="6. count"></a>6. count</h3><ul>
<li><code>InnoDB</code>：不保存表的具体行数，如果使用<code>select count(*) from table</code>，就会遍历整个表，消耗相当大，但是在加了<code>where</code>条件后，myisam和innodb处理的方式都一样。</li>
<li><code>MyISAM</code>：使用一个变量保存整个表的行数，如果使用<code>select count(*) from table</code>，会直接读取该变量。</li>
</ul>
<blockquote>
<p> 因为InnoDB的事务特性，在同一时刻表中的行数对于不同的事务而言是不一样的，因此count统计会计算对于当前事务而言可以统计到的行数，而不是将总行数储存起来方便快速查询。</p>
</blockquote>
<h3 id="7-锁"><a href="#7-锁" class="headerlink" title="7. 锁"></a>7. 锁</h3><ul>
<li><code>InnoDB</code>：支持行级锁和表锁。行锁是基于索引实现的，如果没有命中索引，也无法使用行锁，会退化到表锁。</li>
<li><code>MyISAM</code>：仅支持表锁，不支持行锁。</li>
</ul>
<h3 id="8-主键"><a href="#8-主键" class="headerlink" title="8. 主键"></a>8. 主键</h3><ul>
<li><code>InnoDB</code>：如果没有设定主键，会自动生成一个6字节的隐藏主键（用户不可见），数据保存在主键索引的叶子节点上。</li>
<li><code>MyISAM</code>：允许不含有主键。</li>
</ul>
<blockquote>
<p>删除部分自增主键后，二者的区别？</p>
<ol>
<li>不重启服务器</li>
</ol>
<p>初始有自增主键<code>1,2,3,4,5</code>，删除<code>4,5</code>后，插入一行新的数据，无论是<code>InnoDB</code>还是<code>MyISAM</code>都会从<code>6</code>开始插入。</p>
<ol start="2">
<li>重启服务器</li>
</ol>
<p>初始有自增主键<code>1,2,3,4,5</code>，删除<code>4,5</code>后，重启服务器，再插入一行新的数据，<code>InnoDB</code>主键会从<code>4</code>开始插入，而<code>MyISAM</code>会从<code>6</code>开始插入。</p>
<blockquote>
<p>原因：Innodb表把自增主键的最大ID记录到内存中，重启数据库后，都会导致最大自增ID重置；MyISAM表会把自增主键的最大ID记录到数据文件里，重启MySQL自增主键的最大ID也不会丢失。</p>
</blockquote>
<p><strong>说明：mysql8.0版本，重启数据库后，不会导致最大自增ID重置</strong></p>
<p><strong>原因：</strong>在 MySQL 8.0 中，<code>AUTO_INCREMENT</code>计数器的逻辑变了，每当计数器的值有变，InnoDB 会将其写入 redo log，保存到引擎专用的系统表中。MySQL 正常关闭后重启：从系统表中获取计数器的值。MySQL 故障后重启：从系统表中获取计数器的值；从最后一个检查点开始扫描 redo log 中记录的计数器值；取这两者的最大值作为新值。</p>
</blockquote>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL:事务&amp;MVCC详解</title>
    <url>/2022/05/30/MySQL-%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<p><img src="/2022/05/30/MySQL-%E4%BA%8B%E5%8A%A1/mysql-logo-800-400.jpg"></p>
<p><strong>数据库事务（transaction）</strong>是访问并可能操作各种数据项的一个数据库操作序列，这些操作要么全部执行,要么全部不执行，是一个不可分割的工作逻辑单元。</p>
<span id="more"></span>

<h2 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="事务的四大特性"></a>事务的四大特性</h2><ul>
<li><p><strong>原子性（Atomicity）：</strong>一个事务中的所有操作，要么都执行，要么都失败，不存在中间状态，一旦事务执行过程中发生了错误，事务会进行回滚，恢复到事务开始之前的状态，就像这个事务从来没有执行过一样。</p>
</li>
<li><p><strong>一致性（Consistency）：</strong>数据库的完整性不会因为事务的执行而受到破坏，一个事务执行之前和执行之后都必须处于一致状态。比如表中有一个字段为姓名，它有唯一约束，也就是表中姓名不能重复，如果一个事务对姓名字段进行了修改，但是在事务提交后，表中的姓名变得非唯一性了，这就破坏了事务的一致性要求，这时数据库就要撤销该事务，返回初始化的状态。再比如用户A和用户B两者的钱加起来一共是1000，那么不管A和B之间如何转账、转几次账，事务结束后两个用户的钱相加起来应该还得是1000，这就是事务的一致性。</p>
</li>
<li><p><strong>隔离性（Isolation）：</strong>数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以保证多个事务在并发执行的过程中互相隔离，互不干扰，从而避免并发事务交叉执行时带来的数据不一致问题。</p>
</li>
<li><p><strong>持久性（Durability）：</strong>事务结束后，对数据的修改是永久的，即便发生系统故障也不会对丢失。</p>
</li>
</ul>
<p><strong><code>InnoDB</code>引擎如何保证事务的四大特性？</strong></p>
<p>持久性通过<code>redo log</code>（重做日志）来保证的</p>
<p>原子性通过<code>undo log</code>（回滚日志）来保证的</p>
<p>隔离性通过<code>mvcc</code>（多版本并发控制）或锁机制来保证的</p>
<p>一致性通过持久性+原子性+隔离性来保证的</p>
<h2 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h2><h3 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h3><p><strong>一个事务读到了另一个「未提交事务修改的数据」，如果该数据发生回滚，则读到的数据就是错误的数据，就意味着发生了「脏读」现象。</strong></p>
<p><img src="https://images.ysfun.cn/mac-img/10b513008ea35ee880c592a88adcb12f.png"></p>
<p>因为事务 A 是还没提交事务的，也就是它随时可能发生回滚操作，<strong>如果在上面这种情况事务 A 发生了回滚，那么事务 B 刚才得到的数据就是过期的数据，这种现象就被称为脏读。</strong></p>
<h3 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h3><p><strong>在一个事务内多次读取同一个数据，如果前后两次读到的数据不一致，就意味着发生了「不可重复读」现象。</strong></p>
<p><img src="https://images.ysfun.cn/mac-img/f5b4f8f0c0adcf044b34c1f300a95abf.png"></p>
<p>事务B第一读取余额为100万，第二次读取余额变为200万，两次读同一条数据结果却不一致。</p>
<h3 id="幻读"><a href="#幻读" class="headerlink" title="幻读"></a>幻读</h3><p><strong>在一个事务中多次查询符合特定条件的记录数量，如果前后两次查询到的记录数量不同，就意味着发生了「幻读」。</strong></p>
<p><img src="https://images.ysfun.cn/mac-img/d19a1019dc35dfe8cfe7fbff8cd97e31-20220601203800758.png"></p>
<p>事务B第一次查询大于100万的记录有5条，第二次查询同样条件结果却变成了6条，出现了幻读。</p>
<blockquote>
<p>MySQL针对「脏读，不可重复读，幻读」等现象，采取了什么措施应对？</p>
<p>答：隔离级别</p>
</blockquote>
<h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><p>SQL标准规定了四种隔离级别：</p>
<ul>
<li><strong>读未提交（Read Uncommitted）</strong>，一个事务可以读取到其他未提交事务变更过的数据；</li>
<li><strong>读已提交（Read Committed）</strong>，一个事务只能读取到其他已经提交多的事务变更的数据，<code>Oracle</code>数据库默认采用这种隔离级别；</li>
<li><strong>不可重复读（Repeatable Read）</strong>，一个事务执行过程中读取到的数据始终和事务开始时读到的数据一致，<code>MySQL</code>数据库默认采用这种隔离级别；</li>
<li><strong>串行化（Serializable）</strong>，会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；</li>
</ul>
<p>按「隔离水平」从高到低排序：</p>
<p><img src="https://images.ysfun.cn/mac-img/cce766a69dea725cd8f19b90db2d0430.png"></p>
<p>针对不同隔离级别，并发事务时可能发生的现象：</p>
<p><img src="https://images.ysfun.cn/mac-img/4e98ea2e60923b969790898565b4d643.png"></p>
<p>解决脏读现象，就要升级到「读提交」以上的隔离级别；要解决不可重复读现象，就要升级到「可重复读」的隔离级别。</p>
<p>不过，要解决幻读现象不建议将隔离级别升级到「串行化」，因为这样会导致数据库在并发事务时性能很差。</p>
<p><strong>MySQL的默认隔离级别是「不可重复读」，但是它采用<code>Next-Key Lock</code>锁（行锁和间隙锁的组合），来锁住记录本身以及记录的“间隙”，防止其他事务在记录之间插入新的记录，从而可以有效避免幻读。</strong></p>
<h3 id="四种隔离级别是如何实现的？"><a href="#四种隔离级别是如何实现的？" class="headerlink" title="四种隔离级别是如何实现的？"></a>四种隔离级别是如何实现的？</h3><ul>
<li>对于「读未提交」，因为可以读到为其他未提交事务修改的数据，所以直接读取最新数据；</li>
<li>对于「串行化」，通过加<strong>读写锁</strong>的方式来避免并行访问；</li>
<li>对于「读已提交」和「不可重复读」，它们都是通过<code>Read View</code>来实现的，它们的区别在于创建<code>Read View</code>的时机不同，<code>Read View</code>可以理解为一个快照数据，类似于相机拍的照片，记录的是某一时刻的风景。「读已提交」是在<strong>每个读语句执行前</strong>都会重新创建一个新的<code>Read View</code>；而「不可重复读」则是在<strong>事务开启前</strong>创建一个<code>Read View</code>，然后整个事务执行期间都使用这个<code>Read View</code>。</li>
</ul>
<blockquote>
<p>Read View是MVCC工作的核心，下面来详细讲讲MVCC（多版本并发控制）。</p>
</blockquote>
<h2 id="MVCC（Multi-Version-Concurrency-Control）"><a href="#MVCC（Multi-Version-Concurrency-Control）" class="headerlink" title="MVCC（Multi-Version Concurrency Control）"></a>MVCC（Multi-Version Concurrency Control）</h2><p>MVCC最大的好处就是：读不加锁，读写不冲突。相比基于锁的并发控制，在读多写少的场景下，MVCC极大地提升了系统的并发性能。</p>
<p>在MVCC并发控制中，读操作可以分为两类：快照读（Snapshot Read）和当前读（Current Read）。快照读，读取的是记录的可见版本（可能是历史版本），不用加锁；当前读，读取的是记录的最新版本，并且当前读返回的数据都会上锁，保证其他事务不会并发修改该记录。</p>
<h3 id="在MySQL-InnoDB存储引擎中，哪些读操作是快照读？哪些操作又是当前读呢？"><a href="#在MySQL-InnoDB存储引擎中，哪些读操作是快照读？哪些操作又是当前读呢？" class="headerlink" title="在MySQL InnoDB存储引擎中，哪些读操作是快照读？哪些操作又是当前读呢？"></a>在MySQL InnoDB存储引擎中，哪些读操作是快照读？哪些操作又是当前读呢？</h3><ul>
<li><p><strong>快照读：</strong>简单的select操作，属于快照读，不加锁。</p>
<ul>
<li>例如：select * from table where ?;</li>
</ul>
</li>
<li><p><strong>当前读：</strong>特殊的读操作、插入&#x2F;更新&#x2F;删除操作，属于当前读，需要加锁。</p>
<ul>
<li>select * from table where ? lock in share mode;</li>
<li>select * from table where ? for update;</li>
<li>insert into table values (…);</li>
<li>update table set ? where ?;</li>
<li>delete from table where ?;</li>
</ul>
<p>以上语句都属于当前读，读取到记录的最新版本，并且会在读取到数据后，对数据进行加锁，以保证其他并发事务不会对当前数据进行修改。其中除了第一条语句，对读记录加<code>S锁</code>（共享锁）外，其他操作都是加<code>X锁</code>（排它锁）。</p>
</li>
</ul>
<p><strong>为什么<code>插入/更新/删除</code>操作，都归为当前读?</strong></p>
<p>当Update SQL发给MySQL后，MySQL server会根据where条件，读取到第一条满足条件的记录，然后InnoDB引擎会将第一条记录返回并加锁。待MysSQL server受到第一条记录后，会再发起一个Update请求，更新这条记录。一条记录操作完成后，会再读取下一条记录，直到没有满足条件的记录为止。因此Update操作内部就包含了一个当前读。同理Delete操作也一样。Insert操作会稍微不同，简单来讲，就是Insert操作可能会触发Unique Key的冲突检查，也会进行一下当前读。</p>
<blockquote>
<p>快照读中的记录快照就对应着前面提到的<code>Read View</code>，下面介绍MVCC的工作原理。</p>
</blockquote>
<h3 id="Read-View在MVCC中是如何工作的？"><a href="#Read-View在MVCC中是如何工作的？" class="headerlink" title="Read View在MVCC中是如何工作的？"></a>Read View在MVCC中是如何工作的？</h3><p>首先我们需要了解两个知识点：</p>
<ul>
<li>Read View中的四个字段，及其作用</li>
<li>聚簇索引记录中两个跟事务相关的隐藏列</li>
</ul>
<ol>
<li><strong>Read View的四个重要字段</strong></li>
</ol>
<p><img src="https://images.ysfun.cn/mac-img/11a65cbc2e97f6855d7692a265dc2651-20220601215949157.png"></p>
<p>各个字段的含义：</p>
<ul>
<li>creator_trx_id：是指<strong>创建该Read View的事务id</strong></li>
<li>m_ids：创建Read View时，当前数据库中「<strong>活跃事务」的事务id列表</strong>，“活跃事务”是指启动了但还未提交的事务</li>
<li>min_trx_id：创建Read View时，<strong>「活跃事务」中最小的事务id</strong>，即<code>m_idx</code>中的最小值</li>
<li>max_trx_id：创建Read View时，当前数据库中应该给<strong>下一个事务的id值</strong>，不是<code>m_idx</code>中的最大值，是全局事务中最大的事务id+1</li>
</ul>
<ol start="2">
<li><strong>聚簇索引记录中两个跟事务相关的隐藏列</strong></li>
</ol>
<p><img src="https://images.ysfun.cn/mac-img/f595d13450878acd04affa82731f76c5.png"></p>
<ul>
<li>trx_id：当某个事务对该条记录改动时，会把<strong>该事务的事务id记录在trx_id中</strong></li>
<li>roll_pointer：每次对某一条记录进行修改时，都会把这条记录的旧版本保存到<code>undo log</code>中，这个隐藏列是一个指针，指向了上一个版本的记录，于是通过它就能找到历史版本</li>
</ul>
<p><strong>在创建Read View时我们可以将记录中的trx_id划分为三种情况：</strong></p>
<p><img src="https://images.ysfun.cn/mac-img/ReadView.drawio.png"></p>
<p>一个事务去读取数据时，除当前事务的修改记录总是可见的之外，还有一下情况：</p>
<ul>
<li>如果记录的<code>trx_id</code>小于Read View中的<code>min_trx_id</code>，表示这个版本的记录是<strong>在创建Read View之前就已经提交了的事务生成的</strong>，因此该版本的记录对当前事务是可见的。</li>
<li>如果记录的<code>trx_id</code>大于等于Read View中的<code>max_trx_id</code>，表示这个版本的记录是<strong>在创建Read View之后才启动的事务生成的</strong>，因此该版本的记录对当前事务是不可见的。</li>
<li>如果记录的<code>trx_id</code>介于Read View中的<code>min_trx_id</code>和<code>max_trx_id</code>之间，则需要判断<code>trx_id</code>是否在<code>m_ids</code>列表中：<ul>
<li>如果记录的<code>trx_id</code><strong>在</strong><code>m_ids</code>中，则表明这个版本的记录是在<strong>创建Read View时仍处于活跃状态（启动但未提交）的事务生成的</strong>，因此该版本的记录对当前事务时不可见的。</li>
<li>如果记录的<code>trx_id</code><strong>不在</strong><code>m_ids</code>中，则表明生成该版本记录的活跃事务<strong>在创建Read View时已经提交</strong>，因此该版本的记录对当前事务是可见的。</li>
</ul>
</li>
</ul>
<blockquote>
<p>这种通过「版本链」来控制并发事务访问同一条记录时的行为就叫MVCC（多版本并发控制）。</p>
</blockquote>
<h3 id="可重复读是如何工作的？"><a href="#可重复读是如何工作的？" class="headerlink" title="可重复读是如何工作的？"></a>可重复读是如何工作的？</h3><p><strong>可重复读隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View</strong>。</p>
<p>分析一个场景，假设事务A（事务id为51）启动后，紧接着启动了事务B（事务id为52），那么两个事务创建的Read View及初始记录如下：</p>
<p><img src="https://images.ysfun.cn/mac-img/%E4%BA%8B%E5%8A%A1ab%E7%9A%84%E8%A7%86%E5%9B%BE-new.png"></p>
<p>事务 A 和 事务 B 的 Read View 具体内容如下：</p>
<ul>
<li>在事务 A 的 Read View 中，它的事务 id 是 51，由于它是第一个启动的事务，所以此时活跃事务的事务 id 列表就只有 51，活跃事务的事务 id 列表中最小的事务 id 是事务 A 本身，下一个事务 id 则是 52。</li>
<li>在事务 B 的 Read View 中，它的事务 id 是 52，由于事务 A 是活跃的，所以此时活跃事务的事务 id 列表是 51 和 52，<strong>活跃的事务 id 中最小的事务 id 是事务 A</strong>，下一个事务 id 应该是 53。</li>
</ul>
<p>接着，在「可重复读」隔离级别下，事务A和事务B按顺序执行了以下操作：</p>
<ol>
<li>事务B读取小林的账户余额，显示余额为100万</li>
<li>事务A更新小林的账户余额为200万，但还未提交</li>
<li>事务B再读取小林的账户余额，显示100万</li>
<li>事务A提交事务</li>
<li>事务B再次读取到小林的账户余额为100万</li>
</ol>
<p>分析过程：</p>
<p>事务B第一次读取账户余额时，记录的<code>trx_id</code>为50，小于Read View中的<code>min_trx_id</code>&#x3D;51，因此记录对于事务B是可见的，因此读取到余额为100万；</p>
<p>事务A更新余额后，两个事务的Read View及记录的版本信息为</p>
<p><img src="https://images.ysfun.cn/mac-img/%E4%BA%8B%E5%8A%A1ab%E7%9A%84%E8%A7%86%E5%9B%BE2.png"></p>
<p>事务B第二次读取账户余额时，最新版本记录的<code>trx_id</code>为51，处于事务B的Read View中<code>min_trx_id=51</code>和<code>max_trx_id=53</code>之间；因此还需判断<code>trx_id</code>是否在事务B的Read View中<code>m_ids=[51, 52]</code>列表中，发现在<code>m_ids</code>列表中，因此最新版本的记录对于事务B是不可见的；此时会根据当前版本记录的<code>roll_pointer</code>沿着<code>undo log</code>链条找历史版本，直到发现<code>trx_id</code>小于事务B的Read View中<code>min_trx_id</code>的第一条记录，所以事务B能读到<code>trx_id=50</code>的记录，也就是余额为100万的记录。</p>
<p>最后在事务A提交后，由于在「可重复读」隔离级别下，Read View只会在创建事务时生成，因此事务A和事务B的Read View和创建事务是的一样。事务B第三次读取余额时还是基于之前的Read View来判断版本记录是否可见，因此此时读到的数据和第二次读取的结果是一样的，余额也是100万。</p>
<p><strong>就是通过这样的方式实现了，「可重复读」隔离级别下在事务期间读到的记录都是事务启动前的记录。</strong></p>
<h3 id="读已提交是怎么工作的？"><a href="#读已提交是怎么工作的？" class="headerlink" title="读已提交是怎么工作的？"></a>读已提交是怎么工作的？</h3><p><strong>读提交隔离级别是在每次读取数据时，都会生成一个新的 Read View。</strong></p>
<p>同样分析上面那个场景，只不过将隔离级别从原来的「可重复读」改为「读已提交」。操作顺序也同上</p>
<ol>
<li>事务B读取小林的账户余额，显示余额为100万</li>
<li>事务A更新小林的账户余额为200万，但还未提交</li>
<li>事务B再读取小林的账户余额，显示100万</li>
<li>事务A提交事务</li>
<li>事务B再次读取到小林的账户余额为200万</li>
</ol>
<p>我们来分析事务B第二次读取记录时，读取不到事务A未提交的修改？</p>
<p>在「读已提交」隔离级别下，事务B在第二次读取数据时会新创建Read View</p>
<p><img src="https://images.ysfun.cn/mac-img/%E8%AF%BB%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A1-20220601234013624.png"></p>
<p>由于事务A还未提交，因此事务B读数据时事务A扔出于活跃状态，因此事务A的修改无法被事务B读取到。</p>
<p>我们再来分析事务B第三次读数据时，为什么可以读取到事务A（事务已提交）的修改？</p>
<p>事务B第三次执行读数据操作时创建的Read View如下：</p>
<p><img src="https://images.ysfun.cn/mac-img/%E8%AF%BB%E6%8F%90%E4%BA%A4%E4%BA%8B%E5%8A%A12.drawio.png"></p>
<p>事务B第三次读数据时，事务A已经提交，此时的Read View中的<code>min_trx_id</code>为52，即当前活跃的事务只有事务B，最新版记录由事务A创建，因此其<code>trx_id</code>为51，小于事务B的Read View中的<code>min_trx_id</code>，因此最新版本的记录对于事务B是可见的，因此第三次事务B读取到的余额为200万。</p>
<p>正是因为在读提交隔离级别下，事务每次读数据时都重新创建 Read View，那么在事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL:总算把B+树搞明白了</title>
    <url>/2022/05/17/MySQL-%E6%80%BB%E7%AE%97%E6%8A%8AB-%E6%A0%91%E6%90%9E%E6%98%8E%E7%99%BD%E4%BA%86/</url>
    <content><![CDATA[<p><img src="/2022/05/17/MySQL-%E6%80%BB%E7%AE%97%E6%8A%8AB-%E6%A0%91%E6%90%9E%E6%98%8E%E7%99%BD%E4%BA%86/mysql-logo-800-400.jpg"></p>
<h2 id="1-MySQL索引为何使用B-树"><a href="#1-MySQL索引为何使用B-树" class="headerlink" title="1. MySQL索引为何使用B+树"></a>1. MySQL索引为何使用B+树</h2><p><code>MySQL</code>索引是提升数据库查询效率的最强武器，那么为何索引能够提升数据库查询速度？为何<code>MySQL</code>采用<code>B+树</code>来实现索引？</p>
<span id="more"></span>

<h3 id="1-为何索引能提升查询性能？"><a href="#1-为何索引能提升查询性能？" class="headerlink" title="1. 为何索引能提升查询性能？"></a>1. 为何索引能提升查询性能？</h3><p>第一个问题可以用一个比较通俗的说法来回答，数据库索引相当于给一本书加了一个目录。</p>
<p>问题来了，为什么有了”目录“就能提升数据库查询效率呢？</p>
<p>比较简单的解释，通过目录查找的过程可以近似理解为<code>二分查找</code>查找的过程，我们知道<code>二分查找</code>可以将遍历查询的时间复杂度从<code>o(n)</code>降为<code>o(log n)</code>。</p>
<p>数据库利用索引查询数据的具体过程，后文会进行详细描述。</p>
<h3 id="2-为何MySQL不用二叉树来实现索引？"><a href="#2-为何MySQL不用二叉树来实现索引？" class="headerlink" title="2. 为何MySQL不用二叉树来实现索引？"></a>2. 为何<code>MySQL</code>不用<code>二叉树</code>来实现索引？</h3><p>我们知道通过排序二叉树（也叫二分查找树）可以实现<code>o(log n)</code>的时间复杂度进行查询，相比于<code>o(n)</code>的时间复杂度已经有了极大的提升。</p>
<p><strong><code>MySQL</code>为何没有采用二分查找树作为索引呢？</strong></p>
<p>要解答这个问题，就必须介绍那些因素对数据库查询过程中起到了制约作用。我们都知道<code>CPU</code>的数据处理性能远远比<code>磁盘I/O</code>的速度快，因此要提升查询性能，较少<code>I/O</code>次数就至关重要了。通过<code>树</code>查找的过程，树的层数基本就等于<code>磁盘I/O</code>的次数，因此要尽可能降低树的高度。</p>
<p>我们知道，对于一颗满二叉树，假设树的高度为<code>n</code>，那么这棵树的节点个数为<code>2^n-1</code>个，即对于一个含有<code>n</code>个节点的二叉树，其高度至少为<code>log n</code>，对于数据库百万千万的数据，如果要经历<code>log n</code>次的<code>I/O</code>，其查询耗时则可想而知。</p>
<p>至此，我们知道，之所以不采用<code>二叉树</code>来实现数据库索引，是因为二叉树的高度太大，而每次查询经历的<code>磁盘I/O</code>的次数和树的高度相等，导致查询速度过慢。</p>
<h3 id="3-为何使用B-树？"><a href="#3-为何使用B-树？" class="headerlink" title="3. 为何使用B+树？"></a>3. 为何使用<code>B+</code>树？</h3><p>前面提到，为了减少<code>磁盘I/O</code>的次数，就必须降低树的高度，比较容易想到降低树的高度的方法：增加树的分叉！不难计算，对于一颗具有<code>n</code>个节点的<code>k</code>叉树，其树的高度为$log_k n$。</p>
<p>多叉树里有两种较为常见的，分别为<code>B-</code>树（又称为<code>B</code>树）和<code>B+</code>树。这二者的区别可参考<a href="https://www.jianshu.com/p/ace3cd6526c4">B+树和B树的区别</a>，我们这里主要提三点：</p>
<ul>
<li><code>B+</code>树的data数据只存放在叶子节点，非叶子节点只存储树的索引信息；而<code>B-</code>树的叶子节点和非叶子节点都存放实际的数据。</li>
<li><code>B+</code>树的叶子节点增加了前后指针，分别指向前一个叶子节点和后一个叶子结点，可以理解为维护了一个双向链表。</li>
<li>由于<code>B+</code>树的实际数据都保存在叶子结点，且所有叶子节点都在同一层，所以使用<code>B+</code>树进行查询所经历的<code>I/O</code>次数固定为树的高度；而由于<code>B-</code>树非叶子节点也存放数据，则其查询时间是不固定的。</li>
</ul>
<p><strong><code>B+</code>树和<code>B-</code>树中，为何选择<code>B+</code>树？</strong><a id="1"></a></p>
<p>我们知道要提升数据库查询效率，就要尽可能降低树的高度，即对应相同的数据量，应尽可能使树变得”胖“一些。由于<code>B+</code>树非叶子节点不存储实际数据，对于一个非叶子节点（MySQL数据是分页保存，每页默认16kB，即树的每个节点的大小为16kB），能够有更多的”分叉“，因此可以让树变得更”宽矮“一些，即相比于<code>B-</code>树，同样高度的<code>B+</code>树能保存更多的数据页，因此MySQL采用<code>B+</code>树来实现索引。</p>
<h2 id="2-InnoDB是如何存储数据的？"><a href="#2-InnoDB是如何存储数据的？" class="headerlink" title="2. InnoDB是如何存储数据的？"></a>2. <code>InnoDB</code>是如何存储数据的？</h2><blockquote>
<p>MySQL 支持多种存储引擎，不同的存储引擎，存储数据的方式也是不同的，我们最常使用的是 InnoDB 存储引擎，下面介绍下InnoDB 是如何存储数据的。</p>
</blockquote>
<p>磁盘读写的最小单位是<strong>扇区</strong>，扇区的大小只有 <code>512B</code> 大小，操作系统一次会读写多个扇区，所以<strong>操作系统的最小读写单位是块（Block）。Linux 中的块大小为 <code>4KB</code><strong>，也就是一次磁盘  I&#x2F;O 操作会直接读写 8 个扇区。同样的，MySQL保存的记录是以「行」为单位的，但是数据库的读取并不以「行」为单位，否则一次读取（也就是一次 I&#x2F;O 操作）只能处理一行数据，效率会非常低。</strong>InnoDB 的数据是按「数据页」为单位来读写的</strong>，也就是说，当需要读一条记录的时候，并不是将这个记录本身从磁盘读出来，而是以页为单位，将其整体读入内存。</p>
<p><code>InnoDB</code>保存的数据文件是后缀为<code>.ibd</code>的文件，其含义是<code>InnoDB data</code>文件，又叫<code>表空间</code>。虽然在数据表里，它们看起来是挨在一起的。但实际上在<code>xx.ibd</code>里他们被分成很多小份的<strong>数据页</strong>，每份默认大小为<code>16kB</code>。类似如下结构：</p>
<img src="https://images.ysfun.cn/mac-img/image-20220517223121145.png" style="zoom:60%">

<p>数据库<code>I/O</code>操作的最小单位是<strong>页</strong>，<strong>InnoDB 数据页的默认大小是 16KB</strong>，意味着数据库每次读写都是以 16KB 为单位的，一次最少从磁盘中读取 16K 的内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中。</p>
<p>数据页主要包括七个部分，<strong>数据页结构图</strong><a id="2"></a>如下：</p>
<img src="https://images.ysfun.cn/mac-img/image-20220517221149949.png" style="zoom:40%">

<p>各部分的作用：</p>
<img src="https://images.ysfun.cn/mac-img/image-20220517221347217.png" style="zoom:50%">

<p>在 File Header 中有两个指针，分别指向上一个数据页和下一个数据页，连接起来的页相当于一个双向的链表，如下图所示：</p>
<img src="https://images.ysfun.cn/mac-img/image-20220517221521045.png" style="zoom:60%">

<blockquote>
<p>采用链表的结构是让数据页之间不需要是物理上的连续的，而是逻辑上的连续。</p>
</blockquote>
<p><strong>数据页中的记录按照「主键」顺序组成单向链表</strong>，单向链表的特点就是插入、删除非常方便，但是检索效率不高，最差的情况下需要遍历链表上的所有节点才能完成检索。</p>
<p>因此，数据页中有一个<strong>页目录</strong>，起到记录的索引作用，就像我们书那样，针对书中内容的每个章节设立了一个目录，想看某个章节的时候，可以查看目录，快速找到对应的章节的页数，而数据页中的页目录就是为了能快速找到记录。通过<strong>页目录</strong>可以使数据页内查询记录的时间复杂度从<code>o(n)</code>变为<code>o(log n)</code>，提升页内查询效率。</p>
<h2 id="3-B-树是如何进行查询的？"><a href="#3-B-树是如何进行查询的？" class="headerlink" title="3. B+树是如何进行查询的？"></a>3. <code>B+</code>树是如何进行查询的？</h2><p>在<code>InnoDB</code>中一个<strong>数据页</strong>默认的大小为<code>16 kB</code>，当面对大数据量时，需要多个数据页共同存放数据，如何建立合适的索引，才能快速的定位到记录所在的页。因此，<code>MySQL</code>采用<code>B+</code>树作为索引。</p>
<p>InnoDB 里的 B+ 树中的<strong>每个节点都是一个数据页</strong>，结构示意图如下：</p>
<img src="https://images.ysfun.cn/mac-img/image-20220517223718982.png" style="zoom:80%">

<p>通过上图，我们看出  B+ 树的特点：</p>
<ul>
<li>只有叶子节点（最底层的节点）才存放了数据，非叶子节点（其他上层节）仅用来存放目录项作为索引。</li>
<li>非叶子节点分为不同层次，通过分层来降低每一层的搜索量；</li>
<li>所有节点按照索引键大小排序，构成一个双向链表，便于范围查询；</li>
</ul>
<p>我们再看看 B+ 树如何实现快速查找主键为 6 的记录，以上图为例子：</p>
<ul>
<li>从根节点开始，通过二分法快速定位到符合页内范围包含查询值的页，因为查询的主键值为 6，在[1, 7)范围之间，所以到页 30 中查找更详细的目录项；</li>
<li>在非叶子节点（页30）中，继续通过二分法快速定位到符合页内范围包含查询值的页，主键值大于 5，所以就到叶子节点（页16）查找记录；</li>
<li>接着，在叶子节点（页16）中，通过槽查找记录时，使用二分法快速定位要查询的记录在哪个槽（哪个记录分组），定位到槽后，再遍历槽内的所有记录，找到主键为 6 的记录。</li>
</ul>
<h2 id="4-聚集索引和二级索引"><a href="#4-聚集索引和二级索引" class="headerlink" title="4. 聚集索引和二级索引"></a>4. 聚集索引和二级索引</h2><p>索引又可以分为聚集索引和二级索引，其区别在于叶子节点存放了什么数据。</p>
<ul>
<li>聚集索引叶子节点存放了实际数据，所有完整的数据记录都保存在聚集索引的叶子节点；</li>
<li>二级索引叶子节点存放了主键值，而不是实际数据</li>
</ul>
<p>因为表的数据都是存放在聚集索引的叶子节点里，所以 InnoDB 存储引擎一定会为表创建一个聚集索引，且由于数据在物理上只会保存一份，所以聚簇索引只能有一个。</p>
<p>InnoDB 在创建聚簇索引时，会根据不同的场景选择不同的列作为索引：</p>
<ul>
<li>如果有主键，默认会使用主键作为聚簇索引的索引键；</li>
<li>如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键；</li>
<li>在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键；</li>
</ul>
<p>一张表只能有一个聚簇索引，那为了实现非主键字段的快速搜索，就引出了二级索引（非聚簇索引&#x2F;辅助索引），它也是利用了 B+ 树的数据结构，但是二级索引的叶子节点存放的是主键值，不是实际数据。</p>
<blockquote>
<p>如果某个查询语句使用了二级索引，但是查询的数据不是主键值，这时在二级索引找到主键值后，需要去聚簇索引中获得数据行，这个过程就叫作「<strong>回表</strong>」，也就是说要查两个 B+ 树才能查到数据。不过，当查询的数据是主键值时，因为只在二级索引就能查询到，不用再去聚簇索引查，这个过程就叫作「<strong>索引覆盖</strong>」，也就是只需要查一个 B+ 树就能找到数据。</p>
</blockquote>
<h2 id="5-一颗B-树可以存放多少行数据？"><a href="#5-一颗B-树可以存放多少行数据？" class="headerlink" title="5. 一颗B+树可以存放多少行数据？"></a>5. 一颗<code>B+</code>树可以存放多少行数据？</h2><p>前面提到，<code>B+</code>树的每个节点是一个<strong>数据页</strong>，默认大小<code>16kB</code>。前面<a href="#2"> 数据页结构图</a>已经介绍了每个数据页的结构，除去页头页尾及其它描述信息，真正存放用户记录的<code>User Records</code>部分还不足<code>16kB</code>。</p>
<h3 id="1-叶子节点和非叶子节点分别存放多少数据？"><a href="#1-叶子节点和非叶子节点分别存放多少数据？" class="headerlink" title="1. 叶子节点和非叶子节点分别存放多少数据？"></a>1. 叶子节点和非叶子节点分别存放多少数据？</h3><p>B+树的<strong>最末级叶子结点</strong>里放了record数据。而<strong>非叶子结点</strong>里则放了用来加速查询的索引数据。</p>
<p><img src="https://images.ysfun.cn/mac-img/image-20220517235249221.png" alt="三层B+树"></p>
<p>同样一个16kB的页，非叶子节点里每一条数据都指向一个新的页，而新的页有两种可能。</p>
<ul>
<li>如果是末级叶子节点的话，那么里面放的就是一行行record数据。</li>
<li>如果是非叶子节点，那么就会循环继续指向新的数据页。</li>
</ul>
<h3 id="2-B-树总行数的计算公式"><a href="#2-B-树总行数的计算公式" class="headerlink" title="2. B+树总行数的计算公式"></a>2. <strong>B+树总行数的计算公式</strong></h3><p>假设</p>
<ul>
<li>非叶子结点内指向其他内存页的指针数量为<code>x</code></li>
<li>叶子节点内能容纳的record数量为<code>y</code></li>
<li>B+树的层数为<code>z</code></li>
</ul>
<p>那这棵B+树放的<strong>行数据总量</strong>等于 <code>(x ^ (z-1)) * y</code>。</p>
<p><strong><code>x</code>怎么算？</strong></p>
<p><img src="https://images.ysfun.cn/mac-img/image-20220517235825563.png" alt="数据页的结构"></p>
<p>非叶子节点里主要放索引查询相关的数据，放的是主键和指向页号。</p>
<p>主键假设是<code>bigint（8Byte）</code>，而页号在源码里叫<code>FIL_PAGE_OFFSET（4Byte）</code>，那么非叶子节点里的一条数据是<code>12Byte</code>左右。</p>
<p>整个数据页<code>16k</code>， 页头页尾那部分数据全加起来大概<code>128Byte</code>，加上页目录毛估占<code>1k</code>吧。那剩下的<code>15kB</code>除以<code>12Byte</code>，等于<code>1280</code>，也就是可以指向<strong>x&#x3D;1280页</strong>。</p>
<p>我们常说的二叉树指的是一个结点可以发散出两个新的结点。m叉树一个节点能指向m个新的结点。这个指向新节点的操作就叫<strong>扇出（fanout）</strong>。</p>
<p>而上面的B+树，它能指向1280个新的节点，恐怖如斯，可以说<strong>扇出非常高</strong>了。</p>
<p> <strong><code>y</code>怎么算？</strong></p>
<p>叶子节点和非叶子节点的数据结构是一样的，所以也假设剩下<code>15kB</code>可以发挥。</p>
<p>叶子节点里放的是真正的行数据。假设一条行数据<code>1kB</code>，所以一页里能放<strong>y&#x3D;15行</strong>。</p>
<p><strong>行总数计算</strong></p>
<p>回到  <code>(x ^ (z-1)) * y</code> 这个公式。</p>
<p>已知<code>x=1280</code>，<code>y=15</code>。</p>
<p>假设B+树是<strong>两层</strong>，那<code>z=2</code>。则是<code>(1280 ^ (2-1)) * 15 ≈ 2w</code></p>
<p>假设B+树是<strong>三层</strong>，那<code>z=3</code>。则是<code>(1280 ^ (3-1)) * 15 ≈ 2.5kw</code></p>
<p><strong>这个2.5kw，就是我们常说的单表建议最大行数2kw的由来。</strong>毕竟再加一层，数据就大得有点离谱了。三层数据页对应最多三次磁盘IO，也比较合理。</p>
<h3 id="3-行数超过1亿查询速度就慢吗？"><a href="#3-行数超过1亿查询速度就慢吗？" class="headerlink" title="3. 行数超过1亿查询速度就慢吗？"></a>3. 行数超过1亿查询速度就慢吗？</h3><p>上面假设单行数据用了1kb，所以一个数据页能放个15行数据。</p>
<p>如果我单行数据用不了这么多，比如只用了<code>250byte</code>。那么单个数据页能放60行数据。</p>
<p>那同样是三层B+树，单表支持的行数就是 <code>(1280 ^ (3-1)) * 60 ≈ 1个亿</code>。</p>
<p>你看我一个亿的数据，其实也就三层B+树，在这个B+树里要查到某行数据，最多也是三次磁盘IO。所以并不慢。</p>
<h3 id="4-B树存放多少行数据"><a href="#4-B树存放多少行数据" class="headerlink" title="4. B树存放多少行数据"></a>4. B树存放多少行数据</h3><p>B树将行数据都存在非叶子节点上，假设每个数据页还是16kB，掐头去尾每页剩15kB，并且一条数据表行数据还是占1kb，就算不考虑各种页指针的情况下，也只能放个15条数据。<strong>数据页扇出明显变少了。</strong></p>
<p>B树可承载的总行数的公式也变成了一个<strong>等比数列</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">15 + 15^2 +15^3 + ... + 15^z</span><br></pre></td></tr></table></figure>

<p>其中<strong>z还是层数</strong>的意思。</p>
<p>为了能放<code>2kw</code>左右的数据，需要<code>z&gt;=6</code>。也就是树需要有6层，查一次要访问6个页。假设这6个页并不连续，为了查询其中一条数据，最坏情况需要进行<strong>6次磁盘IO</strong>。</p>
<p>而B+树同样情况下放2kw数据左右，查一次最多是<strong>3次磁盘IO。</strong></p>
<p>磁盘IO越多则越慢，这两者在性能上差距略大。</p>
<p>为此，我们可以更明确地回答<a href="#1"><code>B+</code>树和<code>B-</code>树中，为何选择<code>B+</code>树？</a>，<strong>B+树比B树更适合成为mysql的索引。</strong></p>
<p>参考资料：</p>
<p>《MYSQL内核：INNODB存储引擎 卷1》</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Git常用命令</title>
    <url>/2022/05/10/Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="Git基础命令"><a href="#Git基础命令" class="headerlink" title="Git基础命令"></a>Git基础命令</h2><ol>
<li>克隆代码</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git clone xxx</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">克隆指定分支</span></span><br><span class="line">git clone -b branchName xxx</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>拉取（更新）代码</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git pull origin</span><br><span class="line">git pull origin branchName</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">变基</span></span><br><span class="line">git pull --rebase origin branchName</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<ol start="3">
<li>提交代码</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit &quot;message&quot;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>推送远程分支</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git push origin head:branchName</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">强制推送</span></span><br><span class="line">git push -f origin head:branchName</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>合并提交记录</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">合并近k条提交记录</span></span><br><span class="line">git rebase -i head~k</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一般pick第一条，后面都squash</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><img src="https://images.ysfun.cn/mac-img/image-20220510193114486.png"></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis过期key是否立马被删除？</title>
    <url>/2022/05/10/Redis%E8%BF%87%E6%9C%9Fkey%E6%98%AF%E5%90%A6%E7%AB%8B%E9%A9%AC%E8%A2%AB%E5%88%A0%E9%99%A4%EF%BC%9F/</url>
    <content><![CDATA[<h3 id="Redis过期key是否立马被删除？"><a href="#Redis过期key是否立马被删除？" class="headerlink" title="Redis过期key是否立马被删除？"></a>Redis过期key是否立马被删除？</h3><p>答案是不会，Redis处理过期key主要有两种方式：</p>
<ul>
<li>惰性删除（客户端侧）</li>
<li>定期随机删除（服务端侧）</li>
</ul>
<span id="more"></span>

<h4 id="惰性删除"><a href="#惰性删除" class="headerlink" title="惰性删除"></a>惰性删除</h4><p>当客户端请求查询时，判断当前key已过期，则会删除该key，删除key的主动权交给每次访问的请求。</p>
<p>弊端：只能处理还会访问的key，无法对一些不再会被访问的key进行删除。</p>
<p>该实现通过<code>expiredIfNeeded</code>函数实现，源码路径：<code>src/db.c</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">expireIfNeeded</span><span class="params">(redisDb *db, robj *key, <span class="type">int</span> force_delete_expired)</span> &#123;</span><br><span class="line">   <span class="comment">// key 没有过期，return 0</span></span><br><span class="line">    <span class="keyword">if</span> (!keyIsExpired(db,key)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (server.masterhost != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (server.current_client == server.master) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!force_delete_expired) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (checkClientPauseTimeoutAndReturnIfPaused()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Delete the key */</span></span><br><span class="line">    deleteExpiredKeyAndPropagate(db,key);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="定期删除"><a href="#定期删除" class="headerlink" title="定期删除"></a>定期删除</h4><p>对于一些key过期后不再被访问，惰性删除永远无法对其进行删除，这会导致已过期的key不断积压，因此仅靠客户端侧的处理是不够的。</p>
<ul>
<li>如何让处理“占着茅坑不拉屎”的key?</li>
</ul>
<p>服务端进行定期删除，顾名思义就是Redis默认每100 ms 执行一次，随机抽取一些设置了过期时间的key，判断是否过期，如发现已过期就直接删除。</p>
<blockquote>
<p>注意：并不是检查所有key，而是随机抽取一定数量的key</p>
</blockquote>
<p>具体步骤如下：</p>
<img src="https://images.ysfun.cn/mac-img/image-20220511000559696.png" style="zoom:70%">

<p>该过程通过<code>activeExpireCycle</code>函数实现，源码路径：<code>src/expire.c</code></p>
<ul>
<li>为什么不检查所有设置过期时间的key？</li>
</ul>
<p>Redis中存放了数以万计的key，如果每隔100 ms 就要轮询检查所有设置过期时间的key，会非常耗费CPU</p>
<ul>
<li>删除如何做到主从同步？</li>
</ul>
<p>不论是惰性删除还是定期删除，当进行删除时，<code>master</code>会将删除指令记录到<code>AOF</code>和<code>slave</code>节点</p>
<blockquote>
<p><strong>如果过期数据太多，定时删除无法完全删除（每次删除完过期的key还是超过25%），同时这些key再也不会被客户端请求，即也无法通过惰性删除，该如何解决？</strong></p>
<p>答：内存淘汰机制</p>
</blockquote>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Java小知识</title>
    <url>/2022/05/11/Java%E5%B0%8F%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<ol>
<li>使用<code>String.split(expr)</code>方法时，要注意<code>expr</code>是否是正则表达式的通配符，如 <code>.</code>, <code>$</code>等，要使用双反斜杠进行转译<code>\\</code>，<code>\</code>要使用<code>\\\\</code>进行转译</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abc.def.ghi&quot;</span>;</span><br><span class="line">String[] split = s.split(<span class="string">&quot;\\.&quot;</span>);</span><br><span class="line">System.out.println(Arrays.toString(split));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">[abc, def, ghi]</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;abc\\def\\ghi&quot;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;s:\t\t&quot;</span> + s);</span><br><span class="line">String[] split = s.split(<span class="string">&quot;\\\\&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;split:\t&quot;</span> + Arrays.toString(split));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">s:			abc\def\ghi</span><br><span class="line">split:	[abc, def, ghi]</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>集合new对象时添加元素</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// new对象的时候添加元素</span></span><br><span class="line">Map&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, Integer&gt;()&#123;&#123;</span><br><span class="line">  put(<span class="string">&quot;a&quot;</span>, <span class="number">0</span>);</span><br><span class="line">  put(<span class="string">&quot;b&quot;</span>, <span class="number">1</span>);</span><br><span class="line">&#125;&#125;;</span><br><span class="line">System.out.println(map);</span><br><span class="line"><span class="comment">// 正常添加元素</span></span><br><span class="line">map.put(<span class="string">&quot;c&quot;</span>, <span class="number">2</span>);</span><br><span class="line">System.out.println(map);</span><br></pre></td></tr></table></figure>

<p>输出结果：</p>
<p><img src="/2022/05/11/Java%E5%B0%8F%E7%9F%A5%E8%AF%86/image-20211129213733732.png"> </p>
<ol start="3">
<li>查看Java版本信息</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(System.getProperty(<span class="string">&quot;java.version&quot;</span>));</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>String s=&quot;a&quot;+&quot;b&quot;+&quot;c&quot;到底创建了几个对象？</title>
    <url>/2022/05/11/String-s-a-b-c%E5%88%B0%E5%BA%95%E5%88%9B%E5%BB%BA%E4%BA%86%E5%87%A0%E4%B8%AA%E5%AF%B9%E8%B1%A1%EF%BC%9F/</url>
    <content><![CDATA[<p><strong>常量折叠技术</strong>：在编译期间，编译器会将<strong>编译器常</strong>的加减乘除运算过程在编译过程中折叠。编译器通过语法分析，将常量表达式计算求值，并用求出来的值替换表达式，而不必等到运行期间再进行运算处理，从而在运行期间节省处理器资源。</p>
<ul>
<li>下面来对比三种不同写法，观察那些情况下会发生<strong>常量折叠</strong></li>
</ul>
<span id="more"></span>

<blockquote>
<p>  我们对比反编译后的字节码文件以及使用<code>jclasslib bytecode viewer</code>查看字节码信息</p>
</blockquote>
<ol>
<li>我们来分析一下语句，查看反编译后的字节码文件，进行了<strong>常量折叠</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span> + <span class="string">&quot;c&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://images.ysfun.cn/mac-img/image-20220511003922966.png"></p>
<p>字节码信息如下：</p>
<p><img src="https://images.ysfun.cn/mac-img/image-20220511005110697.png"></p>
<p>直接对比是否指向同一个对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span> + <span class="string">&quot;c&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">t</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(s == t);</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="https://images.ysfun.cn/mac-img/image-20220511010602524.png"> </p>
<ol start="2">
<li>再来对比，没有进行<strong>常量折叠</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> s1 + <span class="string">&quot;c&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://images.ysfun.cn/mac-img/image-20220511004222616.png"></p>
<p>字节码信息如下：</p>
<p><img src="https://images.ysfun.cn/mac-img/image-20220511004929034.png"></p>
<p>是否指向常量池中的常量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> s1 + <span class="string">&quot;c&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">t</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(s == t);</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="https://images.ysfun.cn/mac-img/image-20220511010725943.png"> </p>
<ol start="3">
<li>在观察如下语句，与2唯一的区别就是给<code>s1</code>添加了<code>final</code>修饰，可以发现又发生了<strong>常量折叠</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> s1 + <span class="string">&quot;c&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><img src="https://images.ysfun.cn/mac-img/image-20220511005336059.png"></p>
<p>字节码信息如下：</p>
<p><img src="https://images.ysfun.cn/mac-img/image-20220511005447668.png"></p>
<p>是否指向同一个对象：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> s1 + <span class="string">&quot;c&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">t</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(s == t);</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="https://images.ysfun.cn/mac-img/image-20220511010924324.png"> </p>
<blockquote>
<p>发生<code>常量折叠</code>必须是编译器常量：</p>
<ul>
<li>被声明为final</li>
<li>基本数据类型或者字符串类型</li>
<li>声明时就已经初始化了</li>
<li>使用常量表达式进行初始化</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown如何实现页内跳转？</title>
    <url>/2022/05/18/Typora%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E9%A1%B5%E5%86%85%E8%B7%B3%E8%BD%AC%EF%BC%9FMarkdown%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E9%A1%B5%E5%86%85%E8%B7%B3%E8%BD%AC%EF%BC%9F/</url>
    <content><![CDATA[<h2 id="1-Markdown怎么实现页内跳转？"><a href="#1-Markdown怎么实现页内跳转？" class="headerlink" title="1. Markdown怎么实现页内跳转？"></a>1. Markdown怎么实现页内跳转？</h2><h3 id="1-利用Markdown语法"><a href="#1-利用Markdown语法" class="headerlink" title="1. 利用Markdown语法"></a>1. 利用Markdown语法</h3><p>格式：[描述文字] (#标题名称)</p>
<span id="more"></span>

<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">实践：</span><br><span class="line"></span><br><span class="line">把这段话复制到typora，按住ctrl并点击实现跳转效果</span><br><span class="line"></span><br><span class="line">[点我去顶部](#1.-我是顶部（空格用`-`代替，转换为html时会跳转失败）)</span><br><span class="line"></span><br><span class="line">[点我去中部](#我是中部)</span><br><span class="line"></span><br><span class="line">##### 1. 我是顶部（空格用`-`代替，转换为html时会跳转失败）</span><br><span class="line"></span><br><span class="line">##### 我是中部</span><br></pre></td></tr></table></figure>

<p><strong>效果展示：</strong></p>
<hr>
<p><a href="#1.-%E6%88%91%E6%98%AF%E9%A1%B6%E9%83%A8%EF%BC%88%E7%A9%BA%E6%A0%BC%E7%94%A8%60-%60%E4%BB%A3%E6%9B%BF%EF%BC%8C%E8%BD%AC%E6%8D%A2%E4%B8%BAhtml%E6%97%B6%E4%BC%9A%E8%B7%B3%E8%BD%AC%E5%A4%B1%E8%B4%A5%EF%BC%89">点我去顶部</a></p>
<p><a href="#%E6%88%91%E6%98%AF%E4%B8%AD%E9%83%A8">点我去中部</a></p>
<h5 id="1-我是顶部（空格用-代替，转换为html时会跳转失败）"><a href="#1-我是顶部（空格用-代替，转换为html时会跳转失败）" class="headerlink" title="1. 我是顶部（空格用-代替，转换为html时会跳转失败）"></a>1. 我是顶部（空格用<code>-</code>代替，转换为html时会跳转失败）</h5><h5 id="我是中部"><a href="#我是中部" class="headerlink" title="我是中部"></a>我是中部</h5><hr>
<blockquote>
<p>注意事项：标题名称要完全一样，标题中的空格要用 <code>-</code>代替，这种跳转方式只能局限于跳转到<code>#</code>目录</p>
</blockquote>
<h3 id="2-使用html标签"><a href="#2-使用html标签" class="headerlink" title="2. 使用html标签"></a>2. 使用html标签</h3><p>格式：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">在需要被跳转到地方添加标签：&lt;a id=&quot;xxx&quot;&gt;&lt;/a&gt;</span><br><span class="line">在跳转的位置添加标签：[跳转名称](#xxx)</span><br></pre></td></tr></table></figure>

<p>实践：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">把这段话复制到typora，按住ctrl并点击实现跳转效果</span><br><span class="line">[跳转到位置1](#a1)</span><br><span class="line"></span><br><span class="line">[跳转到地方2](#p2)</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">&lt;a id=&quot;a1&quot;&gt;位置1&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">地方2&lt;a id=&quot;p2&quot;&gt;&lt;/a&gt;</span><br></pre></td></tr></table></figure>

<p><strong>效果展示：</strong></p>
<hr>
<p><a href="#a1">跳转到位置1</a></p>
<p><a href="#p2">跳转到地方2</a></p>
<br>

<br>

<p><a id="a1">位置1</a></p>
<p>地方2<a id="p2"></a></p>
<hr>
<blockquote>
<p>采用这种方式在转换为html时仍然生效，且可控制性高，推荐这种方式。</p>
</blockquote>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Java异常：Exception与Error，checkedException与unCheckedException</title>
    <url>/2022/05/12/Java%E5%BC%82%E5%B8%B8%EF%BC%9AException%E4%B8%8EError%EF%BC%8CcheckedException%E4%B8%8EunCheckedException/</url>
    <content><![CDATA[<h3 id="1-Java异常类层级结构图"><a href="#1-Java异常类层级结构图" class="headerlink" title="1. Java异常类层级结构图"></a>1. Java异常类层级结构图</h3><p><img src="https://images.ysfun.cn/mac-img/image-20220512152121807.png"></p>
<p><code>java.lang.Throwable</code>是Java异常的顶级接口，<code>Exception</code>和<code>Error</code>均继承自<code>Throwable</code>。</p>
<span id="more"></span>

<h3 id="2-Exception和Error有什么区别？"><a href="#2-Exception和Error有什么区别？" class="headerlink" title="2. Exception和Error有什么区别？"></a>2. Exception和Error有什么区别？</h3><ul>
<li>Exception：程序本身可以处理的异常，可以通过<code>try-catch</code>进行捕获。<code>Exception</code>又可分为<code>CheckedException</code>（受检异常）和<code>unCheckedException</code>（非受检异常）。</li>
<li><code>Error</code>：程序本身无法处理的异常，<del>无法通过<code>catch</code>进行捕获</del>不建议通过<code>catch</code>进行捕获。例如上图展示的<code>OutOfMemoryError</code>。这类异常发生时，会导致程序终止运行（线程终止）。</li>
</ul>
<h3 id="3-CheckedException和unCheckedException有什么区别？"><a href="#3-CheckedException和unCheckedException有什么区别？" class="headerlink" title="3. CheckedException和unCheckedException有什么区别？"></a>3. <code>CheckedException</code>和<code>unCheckedException</code>有什么区别？</h3><blockquote>
<p> 二者只是逻辑上的分类，并不存在<code>CheckedException</code>或<code>unCheckedException</code>接口或类</p>
</blockquote>
<ul>
<li><code>CheckedException</code>即受检查异常：Java代码在编译过程中，如果受检查异常没有被<code>catch</code>或者<code>throws</code>关键字处理的话，就没法通过编译。除了<code>RuntimeException</code>及其子类，其他的<code>Exception</code>类及其子类都是受检查异常，常见的有：<code>IoException</code>、<code>ClassNotFoundException</code>、<code>SQLException</code>等。</li>
<li><code>unCheckedException</code>即非受检查异常：Java代码在编译过程中，即使我们不对其进行处理，编译也可以通过。<code>RuntimeException</code>及其子类都是非受检查异常，常见的有：<code>NullPointException</code>、<code>IllegalArgumentException</code>、<code>NumberFormatException</code>等。</li>
</ul>
<p><img src="https://images.ysfun.cn/mac-img/image-20220512152237987.png"></p>
<h3 id="4-Throwable有哪些常用方法？"><a href="#4-Throwable有哪些常用方法？" class="headerlink" title="4. Throwable有哪些常用方法？"></a>4. <code>Throwable</code>有哪些常用方法？</h3><img src="https://images.ysfun.cn/mac-img/image-20220512152739565.png" style="zoom:40%" align="center">

<ul>
<li><code>String getMessage()</code>：返回异常描述信息</li>
</ul>
<p><img src="https://images.ysfun.cn/mac-img/image-20220512153002731.png"></p>
<ul>
<li><code>void printStackTrace()</code>：在控制台打印<code>Throwable</code>对象封装的异常信息</li>
</ul>
<h3 id="5-try-with-resources代替try-catch-finally进行资源释放"><a href="#5-try-with-resources代替try-catch-finally进行资源释放" class="headerlink" title="5. try-with-resources代替try-catch-finally进行资源释放"></a>5. <code>try-with-resources</code>代替<code>try-catch-finally</code>进行资源释放</h3><p><code>try-with-resources</code>是JDK1.7推出的一种资源释放的方式。</p>
<ol>
<li>适用范围：资源的定义，任何实现<code>java.lang.AutoCloseable</code>或<code>java.lang.Closeable</code>接口的对象。</li>
<li>关闭资源和finally块的执行顺序：在<code>try-with-resources</code>语句中，任何catch或finally块在声明的资源关闭后运行。</li>
<li>使用说明：只需在<code>try</code>后面跟上小括号<code>()</code>括号中对资源进行定义，无需使用<code>finally</code>手动释放资源。</li>
</ol>
<p><strong>《Effective Java》</strong>中明确指出：</p>
<blockquote>
<p>面对必须要关闭的资源，我们总是优先使用<code>try-with-resources</code>而不是<code>finally</code>。随之产生的代码更简短，更清晰。</p>
</blockquote>
<p>Java中类似于<code>InputStream</code>、<code>OutputStream</code>、<code>Scanner</code>、<code>PrintWriter</code>等资源都需要我们调用<code>close()</code>方法进行手动关闭资源，一般情况下我们可以使用<code>try-catch-finally</code>来实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  scanner = <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;read.txt&quot;</span>));</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (scanner != <span class="literal">null</span>) &#123;</span><br><span class="line">    scanner.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>JDK1.7后使用<code>try-with-resources</code>实现：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;read.txt&quot;</span>)))&#123;</span><br><span class="line">  <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">    System.out.println(scanner.nextLine());</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>涉及到多个资源的定义，使用分号<code>;</code>进行分隔</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (<span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;read.txt&quot;</span>)); </span><br><span class="line">     <span class="type">OutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;output.txt&quot;</span>))&#123;</span><br><span class="line">  <span class="keyword">while</span> (scanner.hasNext()) &#123;</span><br><span class="line">    outputStream.write(scanner.nextLine().getBytes(StandardCharsets.UTF_8));</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">  e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>源码剖析：HashMap中插入节点put(k, v)和扩容resize()</title>
    <url>/2022/06/08/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%9AHashMap%E7%9A%84put-k-v-%E5%92%8Cresize/</url>
    <content><![CDATA[<img src="https://images.ysfun.cn/mac-img/337690-20200704174405569-752263172-20220608125854874.png" style="zoom:80%">

<p><code>HashMap</code>在不同JDK版本的实现方式和源码有所区别，本文针对<code>jdk1.8</code>展开分析，从源码出发深入探讨<code>HashMap</code>插入元素及其中涉及的扩容的过程。</p>
<span id="more"></span>

<h2 id="HashMap数据结构"><a href="#HashMap数据结构" class="headerlink" title="HashMap数据结构"></a>HashMap数据结构</h2><p><code>HashMap</code>本质由数组+链表&#x2F;红黑树，其源码中定义了一个核心属性<code>table</code>（一个<code>Node</code>数组），<code>Node</code>可以理解为存储哈希表中<strong>键值对</strong>的容器。</p>
<p><img src="https://images.ysfun.cn/mac-img/image-20220608130154836.png"></p>
<p><code>HashMap</code>会根据<code>key</code>的<code>哈希值</code>找到当前键值对存放在<code>table</code>中的下标<code>index</code>，当多个<code>key</code>位于同一个下标时（称之为哈希冲突），会采用链表的方式，将当前<code>Node</code>插入到链表尾端；当链表的长度超过<code>TREEIFY_THRESHOLD</code>时，会将链表转换为二叉查找树进行存储（HashMap采用的是红黑树）；当发现<code>key</code>相同时只替换<code>value</code>值即可。</p>
<p>上面提到发现”<code>key</code>相同“，进行<code>key</code>比较的时候会按照如下顺序进行比对：</p>
<ol>
<li>先判断两个<code>key</code>的哈希值是否相同，如果不同则两个<code>key</code>不同，否则继续比较</li>
<li>判断是否指向同一个引用，即是否<code>==</code>，如果指向同一个引用则两个<code>key</code>相同，否则继续比较</li>
<li>判断<code>equals</code>是否相等，如果相等则两个<code>key</code>相同，否则不相同</li>
</ol>
<blockquote>
<p>从这里我们解释为什么说“重写equals方法就一定要重写hashCode方法”？</p>
<p>当我们需要使用到散列结构（HashMap, HashSet等）时，如果只重写equals方法而没有重写hashCode方法，在比较key是否相同时会先进行hashCode比较，没有重写hashCode方法会导致两个equals相等的对象的hashCode不同，因此在put操作时会当做两个不同的key来处理。</p>
</blockquote>
<h2 id="HashMap插入节点和扩容"><a href="#HashMap插入节点和扩容" class="headerlink" title="HashMap插入节点和扩容"></a>HashMap插入节点和扩容</h2><p><code>put</code>方法源码注释：</p>
<p><img src="https://images.ysfun.cn/mac-img/image-20220608131355501.png"></p>
<p>我们可以发现<code>put</code>方法实际是调用了<code>putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict)</code>方法，我们先来看计算哈希值的过程：</p>
<p><img src="https://images.ysfun.cn/mac-img/image-20220608131606962.png"></p>
<p>从源码我们可以发现，计算哈希值的时候，当<code>key</code>为<code>null</code>时指定了哈希值为0，说明<code>HashMap</code>是允许<code>key</code>为<code>null</code>的，并且只能有一个<code>key</code>为<code>null</code>。这里和其他的哈希表不同（如<code>HashTable</code>,<code>ConcurrentHashMap</code>），其他哈希结构都是不允许<code>key</code>为<code>null</code>的。</p>
<h3 id="putVal-插入节点"><a href="#putVal-插入节点" class="headerlink" title="putVal()插入节点"></a>putVal()插入节点</h3><p>插入节点的步骤：</p>
<ol>
<li>根据哈希值找到当前key在table数组（哈希桶）中的位置</li>
<li>table数组当前位置为空，则在此处创建新Node并放在table的当前位置即可，break</li>
<li>当前位置不为空，且发现当前位置的节点是一颗红黑树，执行红黑树插入节点的操作，break</li>
<li>当前位置不为空，也不是红黑树，则当前位置只有可能是链表，执行链表的插入操作<ol>
<li>遍历链表，查找是否有相同key，如果发现了相同key，则进行值替换，break</li>
<li>遍历到链表尾部，仍未发现相同key，此处创建行Node，并将其插入到链表尾部；插入节点后若发现当前链表长度超过<code>TREEIFY_THRESHOLD</code>时，将链表变成红黑树，break</li>
</ol>
</li>
<li>插入节点后，判断当前<code>size</code>是否超过<code>threshold</code>，如超过进行<code>resize()</code></li>
<li>Return</li>
</ol>
<p><strong>源码分析：（详细分析过程见注释）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Implements Map.put and related methods.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> onlyIfAbsent if true, don&#x27;t change existing value</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">final</span> V <span class="title function_">putVal</span><span class="params">(<span class="type">int</span> hash, K key, V value, <span class="type">boolean</span> onlyIfAbsent,</span></span><br><span class="line"><span class="params">               <span class="type">boolean</span> evict)</span> &#123;</span><br><span class="line">  Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="type">int</span> n, i;</span><br><span class="line">  <span class="keyword">if</span> ((tab = table) == <span class="literal">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">    <span class="comment">// table为空时，初始化table</span></span><br><span class="line">    n = (tab = resize()).length;</span><br><span class="line">  <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="literal">null</span>)</span><br><span class="line">    <span class="comment">// 哈希桶当前位置为空，则直接把新的Node放到table数组的当前位置即可</span></span><br><span class="line">    tab[i] = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 发生哈希冲突</span></span><br><span class="line">    Node&lt;K,V&gt; e; K k;</span><br><span class="line">    <span class="comment">// p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))就是上面提到的「比较key」的源码</span></span><br><span class="line">    <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">        ((k = p.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">      <span class="comment">// 发现key相同，把当前Node赋给e，后面进行value替换操作</span></span><br><span class="line">      e = p;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">      <span class="comment">// 发现哈希桶当前位置已经是一颗树，进行红黑树插入节点操作，此处不进行详细阐述</span></span><br><span class="line">      e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="built_in">this</span>, tab, hash, key, value);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// table当前位置为链表，遍历链表，寻找是否有相同的key</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">binCount</span> <span class="operator">=</span> <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((e = p.next) == <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// 遍历到链表尾部，仍未发现相同的key，创建新Node，并插入到链表尾部</span></span><br><span class="line">          p.next = newNode(hash, key, value, <span class="literal">null</span>);</span><br><span class="line">          <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">            <span class="comment">// 发现当前链表的长度达到了TREEIFY_THRESHOLD，链表变红黑树，提升查询效率</span></span><br><span class="line">            treeifyBin(tab, hash);</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此处同样是「比较key」的过程</span></span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">            ((k = e.key) == key || (key != <span class="literal">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 发现有相同的key，把当前Node赋给e，后面进行value替换操作</span></span><br><span class="line">        p = e;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">      <span class="comment">// 发现key相同，进行value替换操作</span></span><br><span class="line">      <span class="type">V</span> <span class="variable">oldValue</span> <span class="operator">=</span> e.value;</span><br><span class="line">      <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="literal">null</span>)</span><br><span class="line">        e.value = value;</span><br><span class="line">      afterNodeAccess(e);</span><br><span class="line">      <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ++modCount;</span><br><span class="line">  <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">    <span class="comment">// 当前HashMap的节点数超过了门槛值，进行扩容</span></span><br><span class="line">    resize();  <span class="comment">// 扩容操作</span></span><br><span class="line">  afterNodeInsertion(evict);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="resize-扩容"><a href="#resize-扩容" class="headerlink" title="resize()扩容"></a>resize()扩容</h3><p>源码注释：</p>
<p><img src="https://images.ysfun.cn/mac-img/image-20220608134431428.png"></p>
<p>从上面注释我们可以知道，当初始化或者哈希桶大小翻倍时会执行<code>resize()</code>方法。</p>
<p><code>resize()</code>方法分为两个部分：</p>
<ol>
<li>重新计算<code>threshold</code>及<code>capacity</code></li>
<li>重新放置所有Node</li>
</ol>
<p>第一个过程较为简单，基本过程就是<code>table</code>大小翻倍，然后重新计算<code>threshold = newCap * loadFactor</code>，源码部分涉及到很多越界处理，看着有些复杂。</p>
<p>第二个过程遍历旧<code>table</code>，将节点放入到新<code>table</code>对应的位置，主要分为以下几步：</p>
<ol>
<li><p>旧<code>table</code>当前位置为空，直接跳过</p>
</li>
<li><p>旧<code>table</code>当前位置只有一个节点，将该节点放到新<code>table</code>的<code>e.hash &amp; (newCap - 1)</code>位置上即可</p>
</li>
<li><p>旧<code>table</code>当前位置是一颗二叉树，执行红黑树的重新放置节点操作</p>
</li>
<li><p>旧<code>table</code>当前位置是一个长度大于1的链表</p>
<ol>
<li>在链表中存在位置不变和位置往后移动<code>oldCap</code>的节点，使用<code>loHead,loTail</code>来记录位置不变节点的头尾节点，使用<code>hiHead, hiTail</code>记录位置需要往后移动<code>oldCap</code>的头尾节点</li>
</ol>
<blockquote>
<p>怎么判断哪些节点位置不变，哪些需要移动？为什么是向后移动oldCap个位置？<br>e.hash &amp; (newCap - 1) 代表新table的位置，且newCap &#x3D; oldCap &lt;&lt; 1，并且newCap和oldCap都是2的倍数<br>举例说明：<br>我们假定oldCap &#x3D; 8（即0b1000），则newCap &#x3D; 16（即0b10000）<br>e.hash &amp;  0b111 表示在旧table中的位置，&amp; 操作是对e.hash进行截断，即e.hash的后三位即代表旧位置<br>e.hash &amp; 0b1111 表示在新table中的位置，同理，e.hash的后四位代表新位置<br>因此我们只要判断e.hash在第四位是否为0即可，如果为0，则表示新位置和旧位置一致；如果不为0，则新位置比旧位置大0b1000<br>结论：<br>e.hash &amp; oldCap &#x3D;&#x3D; 0 : 新位置和旧位置一致<br>e.hash &amp; oldCap !&#x3D; 0 : 新位置比旧位置大oldCap</p>
</blockquote>
<ol start="2">
<li>位置不动的节点通过<code>newTab[j] = loHead</code>来实现；位置往后移动通过<code>newTab[j + oldCap] = hiHead</code>来实现</li>
</ol>
</li>
</ol>
<p><strong>源码分析：（详细分析过程见注释）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">  Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">  <span class="comment">// ==============第一部分 开始==============</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">oldCap</span> <span class="operator">=</span> (oldTab == <span class="literal">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">  <span class="type">int</span> <span class="variable">oldThr</span> <span class="operator">=</span> threshold;</span><br><span class="line">  <span class="type">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">      threshold = Integer.MAX_VALUE;</span><br><span class="line">      <span class="keyword">return</span> oldTab;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// newCap = oldCap &lt;&lt; 1，capacity翻倍，即table大小翻倍</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">             oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">      <span class="comment">// threshold翻倍</span></span><br><span class="line">      newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">    newCap = oldThr;</span><br><span class="line">  <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">    newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">    newThr = (<span class="type">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 重新计算threshold = newCap * loadFactor</span></span><br><span class="line">    <span class="type">float</span> <span class="variable">ft</span> <span class="operator">=</span> (<span class="type">float</span>)newCap * loadFactor;</span><br><span class="line">    newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="type">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">              (<span class="type">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">  &#125;</span><br><span class="line">  threshold = newThr;</span><br><span class="line">  <span class="comment">// ==============第一部分 结束==============</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ==============第二部分 开始==============</span></span><br><span class="line">  <span class="meta">@SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)</span></span><br><span class="line">  Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> <span class="title class_">Node</span>[newCap];</span><br><span class="line">  table = newTab;</span><br><span class="line">  <span class="keyword">if</span> (oldTab != <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 遍历原来的table</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">      Node&lt;K,V&gt; e;</span><br><span class="line">      <span class="comment">// 原来table当前位置为null的直接跳过</span></span><br><span class="line">      <span class="keyword">if</span> ((e = oldTab[j]) != <span class="literal">null</span>) &#123;</span><br><span class="line">        oldTab[j] = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (e.next == <span class="literal">null</span>)</span><br><span class="line">          <span class="comment">// 当前位置上的链表只有一个节点，重新计算在新table中的位置，并放置到新table对应位置即可</span></span><br><span class="line">          newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">          <span class="comment">// 当前位置上是一颗红黑树，进行树的重新放置操作，此处不进行详细阐述</span></span><br><span class="line">          ((TreeNode&lt;K,V&gt;)e).split(<span class="built_in">this</span>, newTab, j, oldCap);</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">          <span class="comment">// 当前位置上是一颗节点数大于1的链表</span></span><br><span class="line">          <span class="comment">// 不需要改变位置的头结点和尾节点</span></span><br><span class="line">          Node&lt;K,V&gt; loHead = <span class="literal">null</span>, loTail = <span class="literal">null</span>;</span><br><span class="line">          <span class="comment">// 需要将位置往后移动oldCap个位置的头节点和尾节点</span></span><br><span class="line">          Node&lt;K,V&gt; hiHead = <span class="literal">null</span>, hiTail = <span class="literal">null</span>;</span><br><span class="line">          Node&lt;K,V&gt; next;</span><br><span class="line">          <span class="keyword">do</span> &#123;</span><br><span class="line">            next = e.next;</span><br><span class="line">            <span class="comment">/* </span></span><br><span class="line"><span class="comment">            (e.hash &amp; oldCap) == 0 是判断当前节点哈希值在新table中的位置是否需要改变</span></span><br><span class="line"><span class="comment">            e.hash &amp; (newCap - 1) 代表新table的位置，且newCap = oldCap &lt;&lt; 1，并且newCap和oldCap都是2的倍数</span></span><br><span class="line"><span class="comment">            举例说明：</span></span><br><span class="line"><span class="comment">            我们假定oldCap = 8（即0b1000），则newCap = 16（即0b10000）</span></span><br><span class="line"><span class="comment">            e.hash &amp;  0b111 表示在旧table中的位置，&amp; 操作是对e.hash进行截断，即e.hash的后三位即代表旧位置</span></span><br><span class="line"><span class="comment">            e.hash &amp; 0b1111 表示在新table中的位置，同理，e.hash的后四位代表新位置</span></span><br><span class="line"><span class="comment">            因此我们只要判断e.hash在第四位是否为0即可，如果为0，则表示新位置和旧位置一致；如果不为0，则新位置比旧位置大0b1000</span></span><br><span class="line"><span class="comment">            结论：</span></span><br><span class="line"><span class="comment">            e.hash &amp; oldCap == 0 : 新位置和旧位置一致</span></span><br><span class="line"><span class="comment">            e.hash &amp; oldCap != 0 : 新位置比旧位置大oldCap</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">              <span class="keyword">if</span> (loTail == <span class="literal">null</span>)</span><br><span class="line">                loHead = e;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                loTail.next = e;</span><br><span class="line">              loTail = e;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">if</span> (hiTail == <span class="literal">null</span>)</span><br><span class="line">                hiHead = e;</span><br><span class="line">              <span class="keyword">else</span></span><br><span class="line">                hiTail.next = e;</span><br><span class="line">              hiTail = e;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125; <span class="keyword">while</span> ((e = next) != <span class="literal">null</span>);</span><br><span class="line">          <span class="keyword">if</span> (loTail != <span class="literal">null</span>) &#123;</span><br><span class="line">            loTail.next = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 将新旧位置不变的节点仍放到j位置上</span></span><br><span class="line">            newTab[j] = loHead;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (hiTail != <span class="literal">null</span>) &#123;</span><br><span class="line">            hiTail.next = <span class="literal">null</span>;</span><br><span class="line">            <span class="comment">// 将需要往后移的节点放到j+oldCap位置上</span></span><br><span class="line">            newTab[j + oldCap] = hiHead;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newTab;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>如何配置git ssh</title>
    <url>/2022/05/10/%E5%A6%82%E4%BD%95%E9%85%8D%E7%BD%AEgit-ssh/</url>
    <content><![CDATA[<h3 id="1-检查用户名和邮箱"><a href="#1-检查用户名和邮箱" class="headerlink" title="1. 检查用户名和邮箱"></a>1. 检查用户名和邮箱</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看用户名</span></span><br><span class="line">git config user.name</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看邮箱</span></span><br><span class="line">git config user.email</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置用户名</span></span><br><span class="line">git config --global user.name &quot;xxx&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">配置邮箱</span></span><br><span class="line">git config --global user.email &quot;xxx&quot;</span><br></pre></td></tr></table></figure>

<span id="more"></span>

<h3 id="2-查看是否配置过SSH-Key"><a href="#2-查看是否配置过SSH-Key" class="headerlink" title="2. 查看是否配置过SSH Key"></a>2. 查看是否配置过SSH Key</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ls ~/.ssh</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">hyunmin@HyunmindeMacBook-Air .ssh % <span class="built_in">ls</span> ~/.ssh</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">id_rsa      id_rsa.pub  known_hosts</span></span><br></pre></td></tr></table></figure>

<p>存在id_rsa      id_rsa.pub文件即证明已配置过SSH Key</p>
<h3 id="3-生成SSH-Key（秘钥）"><a href="#3-生成SSH-Key（秘钥）" class="headerlink" title="3. 生成SSH Key（秘钥）"></a>3. 生成SSH Key（秘钥）</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t -rsa -C &quot;email&quot;</span><br></pre></td></tr></table></figure>

<h3 id="4-GitHub远程仓库添加公钥"><a href="#4-GitHub远程仓库添加公钥" class="headerlink" title="4. GitHub远程仓库添加公钥"></a>4. GitHub远程仓库添加公钥</h3><ol>
<li><p>复制<code>~/.ssh/id_rsa.pub</code>文件内容，并粘贴到GitHub-&gt;settings-&gt;SSH and GPG keys</p>
</li>
<li><p>检查是否配置成功</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示如下内容则表示配置成功</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">Hi Ysfun! You<span class="string">&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span></span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM：GC垃圾回收</title>
    <url>/2022/06/13/JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/</url>
    <content><![CDATA[<img src="https://images.ysfun.cn/mac-img/image-20220614213725670.png" style="zoom:80%">

<p>在Java 中，JVM 会对内存进行自动分配与回收，其中 GC (Garbage Collection) 的主要作用就是<strong>清除不再使用的对象，自动释放内存</strong>。</p>
<span id="more"></span>

<p>要搞清楚JVM垃圾回收机制，就需要搞清楚一下三件事：</p>
<ol>
<li>哪些垃圾需要回收</li>
<li>垃圾回收算法</li>
<li>常见的垃圾回收器及其工作原理</li>
</ol>
<h2 id="1-哪些内存需要被回收？"><a href="#1-哪些内存需要被回收？" class="headerlink" title="1. 哪些内存需要被回收？"></a>1. 哪些内存需要被回收？</h2><h3 id="1-1-GC的目标区域"><a href="#1-1-GC的目标区域" class="headerlink" title="1.1 GC的目标区域"></a>1.1 GC的目标区域</h3><p>JVM的内存结构包括五大区域：程序计数器、虚拟机栈、本地方法栈、方法区、堆。根据是否线程私有可以分为两类：</p>
<img src="https://images.ysfun.cn/mac-img/image-20220613134151848.png" style="zoom:50%">

<p>其中程序计数器、虚拟机栈、本地方法栈是随线程创建而生、线程销毁而亡，因此这几个区域的内存分配和回收都具备确定性，因为方法结束或者线程终止，内存自然就跟着回收了。</p>
<p><strong>而方法区和堆的内存分配和回收是动态的，正是垃圾回收器需要关注的区域。</strong></p>
<h3 id="1-2-如何判定哪些对象是“垃圾”？"><a href="#1-2-如何判定哪些对象是“垃圾”？" class="headerlink" title="1.2 如何判定哪些对象是“垃圾”？"></a>1.2 如何判定哪些对象是“垃圾”？</h3><p>对于如何判断对象是否可以回收，有两种比较经典的判断策略。</p>
<ul>
<li><p>引用计数算法</p>
</li>
<li><p>可达性分析算法</p>
</li>
</ul>
<ol>
<li><strong>引用计数算法</strong></li>
</ol>
<p>在对象头维护了一个<code>counter</code>计数器，对象被引用一次，计数器+1；若删除该引用或引用失效，计数器-1。当计数器为0时，则认为该对象是可以被回收的。</p>
<p><strong>弊端：</strong>无法解决循环引用的问题，发生循环应用的引用计数器永远不会为0，则意味着这些对象永远不会被回收，就会导致<code>内存泄漏</code>问题。因此主流的Java虚拟机都没有采用引用计数算法来判断对象是否存活。</p>
<p><img src="https://images.ysfun.cn/mac-img/%E5%BE%AA%E7%8E%AF%E5%BC%95%E7%94%A8.jpg" alt="循环引用"></p>
<ol start="2">
<li><strong>可达性分析算法</strong></li>
</ol>
<p>首先确定一系列的**根对象 (GC Roots)<strong>，并根对象出发根据对象之间的引用关系搜索出一条</strong>引用链 (Reference Chain)**，能被引用链搜索到的对象就判定为存活对象，不在引用链的对象则可对其进行回收。</p>
<p><strong>JVM中，<code>GC Roots</code>包括：</strong></p>
<ul>
<li><strong>虚拟机栈中引用的对象</strong>（方法内的局部变量、参数等）</li>
<li><strong>方法区中静态属性引用的对象</strong>（static声明的字段）</li>
<li><strong>方法区中常量引用的对象</strong>（final声明的字段）</li>
<li><strong>本地方法栈中引用的对象</strong>（native方法）</li>
<li><strong>Java虚拟机内部的引用</strong></li>
</ul>
<img src="https://images.ysfun.cn/mac-img/image-20220614171629710.png" style="zoom:60%">

<h3 id="1-3-Java中的引用"><a href="#1-3-Java中的引用" class="headerlink" title="1.3 Java中的引用"></a>1.3 Java中的引用</h3><p>无论是通过引用计数算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与“引用”相关。在Java中，引用又分为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference），这四种引用强度依次逐渐减小。</p>
<p><img src="https://images.ysfun.cn/mac-img/%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8.png" alt="四种引用"></p>
<ol>
<li><strong>强引用（Strong Reference）</strong></li>
</ol>
<p>在程序代码中普遍存在的，类似 <code>Object obj = new Object()</code> 这类引用，只要强引用存在，垃圾收集器永远不会回收被引用的对象。</p>
<ol start="2">
<li><strong>软引用（Soft Reference）</strong></li>
</ol>
<p>软引用是一种相对强引用弱化一些的引用，可以让对象豁免一些垃圾收集，只有当 JVM 认为内存不足时，才会去试图回收软引用指向的对象。<strong>JVM 会确保在抛出 OutOfMemoryError 之前，清理软引用指向的对象</strong>。软引用通常用来<strong>实现内存敏感的缓存</strong>，如果还有空闲内存，就可以暂时保留缓存，当内存不足时清理掉，这样就保证了使用缓存的同时，不会耗尽内存。</p>
<ol start="3">
<li><strong>弱引用（Weak Reference）</strong></li>
</ol>
<p>弱引用的<strong>强度比软引用更弱</strong>一些。当 JVM 进行垃圾回收时，<strong>无论内存是否充足，都会回收</strong>只被弱引用关联的对象。</p>
<ol start="4">
<li><strong>虚引用（Phantom Reference）</strong></li>
</ol>
<p>虚引用也称为幽灵引用或者幻影引用，它是<strong>最弱</strong>的一种引用关系。一个对象是否有虚引用的存在，<strong>完全不会对其生存时间构成影响</strong>，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的<strong>唯一目的就是能在这个对象被收集器回收时收到一个系统通知</strong>。</p>
<blockquote>
<p>无论引用计数算法还是可达性分析算法都是基于强引用而言的。</p>
</blockquote>
<h3 id="1-4-对象死亡（被回收）前的最后一次挣扎"><a href="#1-4-对象死亡（被回收）前的最后一次挣扎" class="headerlink" title="1.4 对象死亡（被回收）前的最后一次挣扎"></a>1.4 对象死亡（被回收）前的最后一次挣扎</h3><p>即使在可达性分析算法中不可达的对象，也并非“非死不可”，这时候它们处于“缓刑”阶段，要真正宣告一个对象死亡，至少还要经历两次标记过程：</p>
<ul>
<li><strong>第一次标记：</strong>如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记；</li>
<li><strong>第二次标记：</strong>第一次标记后接着会进行一次筛选，筛选的条件是此对象是否有必要执行<code>finalize()</code>方法。在<code>finalize()</code>方法中没有重新与引用链建立关联关系的，将被进行第二次标记。</li>
</ul>
<p>第二次标记成功的对象将真的会被回收，如果对象在<code>finalize()</code>方法中重新与引用链建立了关联关系，那么将会逃离本次回收，继续存活。</p>
<h3 id="1-5-方法区的内存如何判断是否需要回收"><a href="#1-5-方法区的内存如何判断是否需要回收" class="headerlink" title="1.5 方法区的内存如何判断是否需要回收"></a>1.5 方法区的内存如何判断是否需要回收</h3><p>方法区主要回收的内容有：废弃常量和无用的类。对于「废弃常量」也可以通过可达性分析来判断，对于「无用的类」则需要同时满足以下三个条件：</p>
<ul>
<li>该类的所有实例都被回收，即Java堆中不存在该类的任何实例；</li>
<li>加载该类的<code>ClassLoader</code>已经被回收；</li>
<li>该类对应的<code>java.lang.Class</code>对象没有在任何地方被引用，无法在任何地方通过反射访问该类。</li>
</ul>
<h2 id="2-GC（垃圾回收）算法"><a href="#2-GC（垃圾回收）算法" class="headerlink" title="2. GC（垃圾回收）算法"></a>2. GC（垃圾回收）算法</h2><p>常见的GC算法包括：</p>
<ul>
<li>标记-清除算法</li>
<li>标记-整理算法</li>
<li>复制算法</li>
<li>分代收集算法</li>
</ul>
<h3 id="2-1-标记-清除（Mark-Sweep）算法"><a href="#2-1-标记-清除（Mark-Sweep）算法" class="headerlink" title="2.1 标记-清除（Mark-Sweep）算法"></a>2.1 标记-清除（Mark-Sweep）算法</h3><p>标记-清除算法是最基本的一种垃圾回收算法，其垃圾回收过程可以分为两步：</p>
<ol>
<li><strong>标记</strong></li>
</ol>
<img src="https://images.ysfun.cn/mac-img/image-20220614185146705.png" style="zoom:50%">

<p>上图中灰色对象是不可达对象，标记为需要被回收的对象。</p>
<ol start="2">
<li><strong>清除</strong></li>
</ol>
<img src="https://images.ysfun.cn/mac-img/image-20220614185357855.png" style="zoom:50%">

<p>将标记为灰色的部分进行清除。</p>
<blockquote>
<p>注意：所谓的清除操作并不是真正把整个内存的字节进行清零，只是把空闲对象的起始和结束地址记录下来并放入空闲列表中，表示这段内存是空闲的。</p>
</blockquote>
<p>标记-清除算法优缺点：</p>
<ul>
<li>优点：速度快，只需要做个标记就能知道哪一块需要被回收。</li>
<li>缺点： 会产生内存碎片。</li>
</ul>
<blockquote>
<p>内存碎片带来的问题：空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</p>
</blockquote>
<h3 id="2-2-标记-整理（Mark-Compact）算法"><a href="#2-2-标记-整理（Mark-Compact）算法" class="headerlink" title="2.2 标记-整理（Mark-Compact）算法"></a>2.2 标记-整理（Mark-Compact）算法</h3><p>与标记-清除算法不同，标记-整理算法是移动式的，它会让所有存活的对象都向空间一端移动，然后清除到边界以外的内存。</p>
<img src="https://images.ysfun.cn/mac-img/image-20220614193929369.png" style="zoom:50%">

<p>标记-整理算法的优缺点：</p>
<ul>
<li>优点：不会产生空间碎片，完美解决了标记-清除算法带来的空间碎片问题。</li>
<li>缺点：标记-整理算法是在标记-清除算法的基础上增加了对象的移动，在整理阶段，由于移动了可用对象，需要去更新引用，从而导致效率较低。</li>
</ul>
<h3 id="2-3-复制算法"><a href="#2-3-复制算法" class="headerlink" title="2.3 复制算法"></a>2.3 复制算法</h3><p>将内存空间分为大小相等的两个内存块，在垃圾回收时将正在使用内存块中存活的对象复制到另一个未被使用的内存块，然后清除正在使用内存块的所有对象。然后交换两个内存块的角色，完成垃圾回收过程。</p>
<img src="https://images.ysfun.cn/mac-img/image-20220614195237263.png" style="zoom:50%">

<p>复制算法的优缺点：</p>
<ul>
<li>优点：复制算法不需要对象移动的操作，效率较高；并且不存在内存碎片的问题。</li>
<li>缺点：需要两倍的内存空间。</li>
</ul>
<h3 id="2-4-分代收集算法"><a href="#2-4-分代收集算法" class="headerlink" title="2.4 分代收集算法"></a>2.4 分代收集算法</h3><p>分代收集算法是目前大部分JVM垃圾回收器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个区域，针对不同区域采用不同的垃圾回收算法。</p>
<p>一般情况下将Java堆内存划分为「新生代」和「老年代」，新生代中大部分都是“朝生夕死”、存活率低的对象，而老年代中大部分都是存活时间长、存活率高的对象，这样就可以根据各个年代的特点采用最合适的回收算法。</p>
<p>Java堆中不同内存块选用的垃圾回收算法：</p>
<ul>
<li><strong>新生代：复制算法</strong>。新生代中，每次垃圾回收的时候都会有大量对象死亡，只有少量存活，因此选用<strong>复制算法</strong>，只需要付出少量存活对象复制的成本就可以完成垃圾回收，并且新生代内存较小，双倍空间成本也是可以接受的。</li>
<li><strong>老年代：标记-清除算法、标记-整理算法</strong>。老年代中因为对象存活率高，且没有额外空间对它进行分配担保，，就必须使用 <strong>“标记—清理”</strong> 或者 <strong>“标记—整理” 算法</strong> 来进行回收。</li>
</ul>
<h3 id="2-5-GC触发"><a href="#2-5-GC触发" class="headerlink" title="2.5 GC触发"></a>2.5 GC触发</h3><p>GC触发分类：</p>
<ul>
<li><strong>Young GC&#x2F;Minor GC：</strong>指目标只是<strong>新生代</strong>的垃圾收集。</li>
<li><strong>Major GC</strong>：指目标只是<strong>老年代</strong>的垃圾收集。<strong>目前只有CMS收集器会有单独收集老年代的行为</strong>。另外请注意“Major GC”这个说法现在有点混淆，在不同资料上常有不同所指，读者需按上下文区分到底是指老年代的收集还是整堆收集。</li>
<li><strong>Full GC</strong>：指目标是整个堆和方法区的垃圾收集。</li>
</ul>
<p>创建对象时GC触发的流程：</p>
<img src="https://images.ysfun.cn/mac-img/image-20220614214059862.png" style="zoom:50%">

<p><strong>Full GC</strong>是对整个堆进行整理，包括Young、Tenured和Perm。Full GC因为需要对整个堆进行回收，所以执行时间会较长，因此应该尽可能减少Full GC的次数。在对JVM调优的过程中，很大一部分工作就是对于Full GC的调节。</p>
<p><strong>触发Full GC的条件：</strong></p>
<p>a) 年老代（Tenured）被写满；</p>
<p>b) 持久代（Perm）被写满；</p>
<p>c) System.gc()被显式调用；</p>
<p>d) 上一次GC之后Heap的各域分配策略动态变化；</p>
<h2 id="3-常见的垃圾收集器"><a href="#3-常见的垃圾收集器" class="headerlink" title="3. 常见的垃圾收集器"></a>3. 常见的垃圾收集器</h2><p>Jdk1.8版本<code>HotSpot</code>虚拟机所包含的垃圾收集器：</p>
<img src="https://images.ysfun.cn/mac-img/1326194-20181017145352803-1499680295.png" style="zoom:150%">

<h3 id="3-1-串行收集器（Serial-Serial-Old）"><a href="#3-1-串行收集器（Serial-Serial-Old）" class="headerlink" title="3.1 串行收集器（Serial, Serial Old）"></a>3.1 串行收集器（Serial, Serial Old）</h3><p><strong>Serial</strong> 翻译过来可以理解成单线程。单线程收集器有Serial 和 Serial Old 两种，它们的唯一区别就是：<strong>Serial 工作在新生代，使用“复制”算法；Serial Old 工作在老年代，使用“标志-整理”算法</strong>。</p>
<p>串行收集器收集器是最经典、最基础，也是最好理解的。它们的特点就是单线程运行及独占式运行，因此会带来很不好的用户体验。虽然它的收集方式对程序的运行并不友好，但由于它的单线程执行特性，应用于单个CPU硬件平台的性能可以超过其他的并行或并发处理器。</p>
<p>“单线程”的意义<strong>并不仅仅是说明它只会使用一个处理器或一条收集线程去完成垃圾收集工作，更重要的是强调在它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束（STW [Stop The World] 阶段）</strong>。</p>
<img src="https://images.ysfun.cn/mac-img/image-20220614215350657.png" style="zoom:50%">

<p>STW 会带给用户恶劣的体验，所以从JDK 1.3开始，一直到现在最新的JDK 13，HotSpot虚拟机开发团队为消除或者降低用户线程因垃圾收集而导致停顿的努力一直持续进行着，从Serial收集器到Parallel收集器，再到Concurrent Mark Sweep（CMS）和Garbage First（G1）收集器，最终至现在垃圾收集器的最前沿成果Shenandoah和ZGC等。</p>
<p>虽然新的收集器很多，但是串行收集器仍有其适合的场景。迄今为止，它依然是HotSpot虚拟机运行在客户端模式下的默认新生代收集器，有着优于其他收集器的地方，那就是简单而高效。对于内存资源受限的环境，它是所有收集器里额外内存消耗最小的，单线程没有线程交互开销。（这里实际上也是一个时间换空间的概念）</p>
<h3 id="3-2-并行收集器（ParNew-Parallel-Scavenge-Parallel-Old）"><a href="#3-2-并行收集器（ParNew-Parallel-Scavenge-Parallel-Old）" class="headerlink" title="3.2 并行收集器（ParNew, Parallel Scavenge, Parallel Old）"></a>3.2 并行收集器（ParNew, Parallel Scavenge, Parallel Old）</h3><p>并行收集器是多线程的收集器，在多核CPU下能够很好的提高收集性能。</p>
<img src="https://images.ysfun.cn/mac-img/image-20220614215805141.png" style="zoom:50%">

<p>并行收集器包含：</p>
<ul>
<li><strong>ParNew收集器</strong>：就是 Serial收集器的多线程版本，基于“复制”算法，其他方面完全一样，在JDK9之后差不多退出历史舞台，只能配合CMS在JVM中发挥作用。</li>
<li><strong>Parallel Scavenge收集器</strong>：和 ParNew收集器类似，基于“复制”算法，但此收集器更关注<strong>可控制的吞吐量</strong>，并且能够通过<code>-XX：+UseAdaptiveSizePolicy</code>打开垃圾收集<strong>自适应调节策略</strong>的开关。</li>
<li><strong>Parallel Old收集器</strong>：就是 Parallel Scavenge 收集器的<strong>老年代</strong>版本，基于<strong>“标记-整理”算法</strong>实现。</li>
</ul>
<h3 id="3-3-Concurrent-Mark-and-Sweep（CMS）收集器"><a href="#3-3-Concurrent-Mark-and-Sweep（CMS）收集器" class="headerlink" title="3.3 Concurrent Mark and Sweep（CMS）收集器"></a>3.3 Concurrent Mark and Sweep（CMS）收集器</h3><p><strong>CMS(Concurrent Mark Sweep，并发标记清除) 收集器</strong>是以获取<strong>最短回收停顿时间</strong>为目标的收集器，它在垃圾收集时使得用户线程和 GC 线程<strong>并发</strong>执行，因此在垃圾收集过程中用户也不会感到明显的卡顿。</p>
<p><strong>特点：</strong>基于标记-清除算法实现。并发收集、低停顿。</p>
<p>从名字就可以知道，CMS是基于“<strong>标记-清除</strong>”算法实现的。它的工作流程如下：</p>
<img src="https://images.ysfun.cn/mac-img/image-20220614221100575.png" style="zoom:50%">

<p>整个过程可以分为四步：</p>
<ol>
<li><p><strong>初始标记</strong>：主要是<strong>标记 GC Root 开始的下级（注：仅下一级）对象</strong>，这个过程会 <strong>STW</strong>，但是跟 GC Root 直接关联的下级对象不会很多，因此这个过程其实很快。</p>
</li>
<li><p><strong>并发标记</strong>：根据上一步的结果，继续向下标识所有关联的对象，直到这条链上的最尽头。这个过程是多线程的，虽然耗时理论上会比较长，但是<strong>其它工作线程并不会阻塞</strong>，<strong>没有 STW</strong>。</p>
</li>
<li><p><strong>重新标记</strong>：顾名思义，就是要再标记一次。为啥还要再标记一次？因为<strong>第 2 步并没有阻塞其它工作线程，其它线程在标识过程中，很有可能会产生新的垃圾</strong>。这个过程会有<strong>STW</strong>，但是时间不会很长。</p>
</li>
<li><p><strong>并发清除</strong>：GC线程和用户线程并发执行，清除已标记的垃圾，没有<strong>STW</strong>。由于最后一步并发清除时，并不阻塞其它线程，<strong>所以还有一个副作用，在清理的过程中，仍然可能会有新垃圾对象产生，只能等到下一轮 GC，才会被清理掉</strong>。</p>
</li>
</ol>
<blockquote>
<p>提问：前面提到“标记-清除”算法会产生空间碎片，为什么CMS还要使用标记-清除算法，而不使用标记-整理算法？</p>
<p>答：如果换成“标记 - 整理”算法，把垃圾清理后，剩下的对象也顺便整理，会导致这些对象的内存地址发生变化，而<strong>此时其他线程还在工作，如果对象引用发生改变，将会带来巨大的问题。</strong></p>
</blockquote>
<h3 id="3-4-G1（Garbage-First）收集器"><a href="#3-4-G1（Garbage-First）收集器" class="headerlink" title="3.4 G1（Garbage First）收集器"></a>3.4 G1（Garbage First）收集器</h3><p>一款面向服务端应用的垃圾收集器。JDK 9发布之日，G1宣告取代Parallel Scavenge加Parallel Old组合，成为服务端模式下的默认垃圾收集器。</p>
<p><strong>特点如下：</strong></p>
<p><span style="color:red;">并发与并行</span>：G1能<strong>充分利用多CPU、多核环境下的硬件优势</strong>，使用多个CPU来缩短Stop-The-World停顿时间。部分收集器原本需要停顿Java线程来执行GC动作，G1收集器仍然可以通过并发的方式让Java程序继续运行。</p>
<p><span style="color:red">分代收集</span>：G1能够独自管理整个Java堆，并且采用不同的方式去处理<strong>新创建的对象</strong>和<strong>已经存活了一段时间、熬过多次GC的旧对象</strong>以获取更好的收集效果。</p>
<p><span style="color:red">空间整合</span>：G1运作期间<strong>不会产生空间碎片</strong>，收集后能提供规整的可用内存。</p>
<p><span style="color:red">可预测的停顿</span>：G1除了追求低停顿外，还能建立<strong>可预测的停顿时间模型</strong>。能让使用者明确指定在一个长度为M毫秒的时间段内，消耗在垃圾收集上的时间不得超过N毫秒。</p>
<p>鉴于 CMS 的一些不足之外，比如: 老年代内存碎片化，STW 时间虽然已经改善了很多，但是仍然有提升空间。G1 就横空出世了，它对于堆区的内存划思路很新颖，有点算法中分治法“分而治之”的味道。下面我们来讨论G1收集器的工作原理！</p>
<p>G1 将连续的Java堆划分为<strong>多个大小相等的独立区域（Region）</strong>，每一个Region都可以根据需要，扮演<strong>新生代的Eden空间、Survivor空间，或者老年代空间</strong>。每个Region的大小可以通过参数<code>-XX：G1HeapRegionSize</code>设定，取值范围为<strong>1MB～32MB，且应为2的N次幂</strong>。</p>
<p>Region中还有一类特殊的<strong>Humongous</strong>区域，专门用来<strong>存储大对象</strong>。<strong>G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象。对于那些超过了整个Region容量的超级大对象，将会被存放在N个连续的Humongous Region之中</strong>。Humongous，简称 H 区，是专用于存放超大对象的区域，通常 &gt;&#x3D; 1&#x2F;2 Region Size，G1的大多数行为都把Humongous Region作为老年代的一部分来进行看待。</p>
<img src="https://images.ysfun.cn/mac-img/image-20220614224058407.png" style="zoom:67%;" />



<p>在G1收集器中，所有的垃圾回收，都是基于 region 的。G1根据各个Region回收所获得的空间大小以及回收所需时间等指标在后台维护一个优先列表，每次根据允许的收集时间，优先回收<strong>价值最大（垃圾）</strong>的Region，从而可以<strong>有计划地避免在整个Java堆中进行全区域的垃圾收集</strong>。这也是 “Garbage First” 得名的由来。</p>
<p>G1<strong>从整体来看是基于“标记-整理”算法实现的收集器</strong>，但<strong>从局部（两个Region之间）上看又是基于“标记-复制”算法实现</strong>，无论如何，这两种算法都意味着<strong>G1运作期间不会产生内存空间碎片</strong>，垃圾收集完成之后能提供规整的可用内存。这种特性有利于程序长时间运行，在程序为大对象分配内存时不容易因无法找到连续内存空间而提前触发下一次GC。</p>
<blockquote>
<p>提问：一个对象和它内部所引用的对象可能不在同一个 Region 中，那么当垃圾回收时，是否需要扫描整个堆内存才能完整地进行一次可达性分析？</p>
</blockquote>
<p>这里就需要引入 <strong>Remembered Set</strong> 的概念了。</p>
<p>答案是<strong>不需要</strong>，每个 Region 都有一个 <strong>Remembered Set （记忆集）</strong>，<strong>用于记录本区域中所有对象引用的对象所在的区域，进行可达性分析时，只要在 GC Roots 中再加上 Remembered Set 即可防止对整个堆内存进行遍历</strong>。</p>
<p>再提一个概念，<strong>Collection Set</strong> ：简称 CSet，<strong>记录了等待回收的 Region 集合，GC 时这些 Region 中的对象会被回收（copied or moved）</strong>。</p>
<p><span style="color:red"><strong>G1工作流程：</strong></span></p>
<img src="https://images.ysfun.cn/mac-img/image-20220614225133854.png" style="zoom:67%;" />



<p>如果不计算维护 Remembered Set 的操作，G1 收集器的工作过程分为以下几个步骤：</p>
<ul>
<li>初始标记：Stop The World，仅使用一条初始标记线程对所有与 GC Roots 直接关联的对象进行标记。</li>
<li>并发标记：使用一条标记线程与用户线程并发执行。此过程进行可达性分析，速度很慢。</li>
<li>最终标记：Stop The World，使用多条标记线程并发执行。</li>
<li>筛选回收：回收废弃对象，此时也要 Stop The World，并使用多条筛选回收线程并发执行。（还会更新Region的统计数据，对各个Region的回收价值和成本进行排序）</li>
</ul>
<p>从上述阶段的描述可以看出，G1收集器除了并发标记外，其余阶段也是要完全暂停用户线程的，换言之，它并非纯粹地追求低延迟，官方给它设定的目标是在<strong>延迟可控的情况下获得尽可能高的吞吐量</strong></p>
<p><span style="color:red"><strong>G1 的 Minor GC&#x2F;Young GC</strong></span></p>
<p>在分配一般对象时，当所有eden region使用达到最大阈值并且无法申请足够内存时，会触发一次YGC。每次YGC会回收所有Eden以及Survivor区，并且将存活对象复制到Old区以及另一部分的Survivor区。</p>
<img src="https://images.ysfun.cn/mac-img/image-20220614225418814.png" style="zoom:67%;" />

<p><span style="color:red"><strong>G1 的 Mixed GC</strong></span></p>
<p>当越来越多的对象晋升到老年代Old Region 时，为了避免堆内存被耗尽，虚拟机会触发一个混合的垃圾收集器，即Mixed GC，是收集整个新生代以及部分老年代的垃圾收集。除了回收整个Young Region，还会回收一部分的Old Region ，这里需要注意：<strong>是一部分老年代，而不是全部老年代</strong>，可以选择哪些Old Region 进行收集，从而可以对垃圾回收的耗时时间进行控制。</p>
<p>Mixed GC的整个子任务和YGC完全一样，只是回收的范围不一样。</p>
<img src="https://images.ysfun.cn/mac-img/image-20220614225700283.png" style="zoom:67%;" />

<blockquote>
<p>注：G1 一般来说是没有FGC的概念的。因为它本身不提供FGC的功能。</p>
</blockquote>
<p>如果 Mixed GC 仍然效果不理想，跟不上新对象分配内存的需求，会使用 Serial Old GC 进行 Full GC强制收集整个 Heap。</p>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>刷题分享：LeetCode[729,731,732]我的日程安排表【TreeMap、查分数组、线段树】</title>
    <url>/2022/06/06/%E5%88%B7%E9%A2%98%E5%88%86%E4%BA%AB%EF%BC%9ATreeMap%E5%BA%94%E7%94%A8%E7%A4%BA%E4%BE%8B-LeetCode-%E6%88%91%E7%9A%84%E6%97%A5%E7%A8%8B%E5%AE%89%E6%8E%92%E8%A1%A8/</url>
    <content><![CDATA[<p><img src="https://images.ysfun.cn/mac-img/leetcode-logo.jpg"></p>
<p>题目对应<code>LeetCode</code><a href="https://leetcode.cn/problems/my-calendar-i/">729. 我的日程安排表 I</a> <a href="https://leetcode.cn/problems/my-calendar-ii/">731. 我的日程安排表 II</a> <a href="https://leetcode.cn/problems/my-calendar-iii/">732. 我的日程安排表 III</a></p>
<span id="more"></span>

<h2 id="我的日程安排表I"><a href="#我的日程安排表I" class="headerlink" title="我的日程安排表I"></a>我的日程安排表I</h2><p><a href="https://leetcode.cn/problems/my-calendar-i/">729. 我的日程安排表 I</a></p>
<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><p>实现一个 MyCalendar 类来存放你的日程安排。如果要添加的日程安排不会造成 重复预订 ，则可以存储这个新的日程安排。</p>
<p>当两个日程安排有一些时间上的交叉时（例如两个日程安排都在同一时间内），就会产生 重复预订 。</p>
<p>日程可以用一对整数 start 和 end 表示，这里的时间是半开区间，即 [start, end), 实数 x 的范围为，  start &lt;&#x3D; x &lt; end 。</p>
<p>实现 MyCalendar 类：</p>
<p>MyCalendar() 初始化日历对象。<br>boolean book(int start, int end) 如果可以将日程安排成功添加到日历中而不会导致重复预订，返回 true 。否则，返回 false 并且不要将该日程安排添加到日历中。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MyCalendar&quot;, &quot;book&quot;, &quot;book&quot;, &quot;book&quot;]</span><br><span class="line">[[], [10, 20], [15, 25], [20, 30]]</span><br><span class="line">输出：</span><br><span class="line">[null, true, false, true]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MyCalendar myCalendar = new MyCalendar();</span><br><span class="line">myCalendar.book(10, 20); // return True</span><br><span class="line">myCalendar.book(15, 25); // return False ，这个日程安排不能添加到日历中，因为时间 15 已经被另一个日程安排预订了。</span><br><span class="line">myCalendar.book(20, 30); // return True ，这个日程安排可以添加到日历中，因为第一个日程安排预订的每个时间都小于 20 ，且不包含时间 20 。</span><br></pre></td></tr></table></figure>

<h3 id="题解【TreeMap】"><a href="#题解【TreeMap】" class="headerlink" title="题解【TreeMap】"></a>题解【TreeMap】</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCalendar</span> &#123;</span><br><span class="line">    TreeMap&lt;Integer, Integer&gt; treeMap;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyCalendar</span><span class="params">()</span> &#123;</span><br><span class="line">        treeMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">book</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        Map.Entry&lt;Integer, Integer&gt; floor = treeMap.floorEntry(start);</span><br><span class="line">        Map.Entry&lt;Integer, Integer&gt; ceiling = treeMap.ceilingEntry(start);</span><br><span class="line">        <span class="keyword">if</span> (floor != <span class="literal">null</span> &amp;&amp; floor.getValue() &gt; start) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ceiling != <span class="literal">null</span> &amp;&amp; ceiling.getKey() &lt; end) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        treeMap.put(start, end);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h3><p>在book()方法中，<code>TreeMap</code>是排序二叉树，<code>treeMap.floorEntry()</code>和<code>treeMap.ceilingEntry()</code>都是通过二分查找实现的，时间复杂度都是<code>o (log n)</code>.</p>
<h2 id="我的日程安排表II"><a href="#我的日程安排表II" class="headerlink" title="我的日程安排表II"></a>我的日程安排表II</h2><p><a href="https://leetcode.cn/problems/my-calendar-ii/">731. 我的日程安排表 II</a></p>
<h3 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h3><p>实现一个 MyCalendar 类来存放你的日程安排。如果要添加的时间内不会导致三重预订时，则可以存储这个新的日程安排。</p>
<p>MyCalendar 有一个 book(int start, int end)方法。它意味着在 start 到 end 时间内增加一个日程安排，注意，这里的时间是半开区间，即 [start, end), 实数 x 的范围为，  start &lt;&#x3D; x &lt; end。</p>
<p>当三个日程安排有一些时间上的交叉时（例如三个日程安排都在同一时间内），就会产生三重预订。</p>
<p>每次调用 MyCalendar.book方法时，如果可以将日程安排成功添加到日历中而不会导致三重预订，返回 true。否则，返回 false 并且不要将该日程安排添加到日历中。</p>
<p>请按照以下步骤调用MyCalendar 类: MyCalendar cal &#x3D; new MyCalendar(); MyCalendar.book(start, end)</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">MyCalendar();</span><br><span class="line">MyCalendar.book(10, 20); // returns true</span><br><span class="line">MyCalendar.book(50, 60); // returns true</span><br><span class="line">MyCalendar.book(10, 40); // returns true</span><br><span class="line">MyCalendar.book(5, 15); // returns false</span><br><span class="line">MyCalendar.book(5, 10); // returns true</span><br><span class="line">MyCalendar.book(25, 55); // returns true</span><br><span class="line">解释： </span><br><span class="line">前两个日程安排可以添加至日历中。 第三个日程安排会导致双重预订，但可以添加至日历中。</span><br><span class="line">第四个日程安排活动（5,15）不能添加至日历中，因为它会导致三重预订。</span><br><span class="line">第五个日程安排（5,10）可以添加至日历中，因为它未使用已经双重预订的时间10。</span><br><span class="line">第六个日程安排（25,55）可以添加至日历中，因为时间 [25,40] 将和第三个日程安排双重预订；</span><br><span class="line">时间 [40,50] 将单独预订，时间 [50,55）将和第二个日程安排双重预订</span><br></pre></td></tr></table></figure>

<h3 id="题解【差分数组思想、TreeMap】"><a href="#题解【差分数组思想、TreeMap】" class="headerlink" title="题解【差分数组思想、TreeMap】"></a>题解【差分数组思想、TreeMap】<a id="t2"></a></h3><p>边界计数，边界开始时计数加一<code>delta[start]++</code>，边界计数时计数减一<code>delta[end]--</code>，按照排序从小到达统计<code>count</code>之和，一旦<code>count==3</code>则表明当前区间有三次重叠。考虑到需要排序结构，delta使用TreeMap。</p>
<p><strong>图解：</strong></p>
<p><img src="https://images.ysfun.cn/mac-img/image-20220606120852444.png"></p>
<p>注意：当<code>count==3</code>时应撤销添加日程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCalendarTwo</span> &#123;</span><br><span class="line">    TreeMap&lt;Integer, Integer&gt; treeMap;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyCalendarTwo</span><span class="params">()</span> &#123;</span><br><span class="line">        treeMap = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">book</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        treeMap.put(start, treeMap.getOrDefault(start, <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        treeMap.put(end, treeMap.getOrDefault(end, <span class="number">0</span>)-<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> count : treeMap.values()) &#123;</span><br><span class="line">            sum += count;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="comment">// 出现三重预定，取消将该日程添加到日历</span></span><br><span class="line">                treeMap.put(start, treeMap.getOrDefault(start, <span class="number">0</span>)-<span class="number">1</span>);</span><br><span class="line">                treeMap.put(end, treeMap.getOrDefault(end, <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="我的日程安排表III"><a href="#我的日程安排表III" class="headerlink" title="我的日程安排表III"></a>我的日程安排表III</h2><p><a href="https://leetcode.cn/problems/my-calendar-iii/">732. 我的日程安排表 III</a></p>
<h3 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h3><p>当 k 个日程安排有一些时间上的交叉时（例如 k 个日程安排都在同一时间内），就会产生 k 次预订。</p>
<p>给你一些日程安排 [start, end) ，请你在每个日程安排添加后，返回一个整数 k ，表示所有先前日程安排会产生的最大 k 次预订。</p>
<p>实现一个 MyCalendarThree 类来存放你的日程安排，你可以一直添加新的日程安排。</p>
<p>MyCalendarThree() 初始化对象。<br>int book(int start, int end) 返回一个整数 k ，表示日历中存在的 k 次预订的最大值。</p>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">输入：</span><br><span class="line">[&quot;MyCalendarThree&quot;, &quot;book&quot;, &quot;book&quot;, &quot;book&quot;, &quot;book&quot;, &quot;book&quot;, &quot;book&quot;]</span><br><span class="line">[[], [10, 20], [50, 60], [10, 40], [5, 15], [5, 10], [25, 55]]</span><br><span class="line">输出：</span><br><span class="line">[null, 1, 1, 2, 3, 3, 3]</span><br><span class="line"></span><br><span class="line">解释：</span><br><span class="line">MyCalendarThree myCalendarThree = new MyCalendarThree();</span><br><span class="line">myCalendarThree.book(10, 20); // 返回 1 ，第一个日程安排可以预订并且不存在相交，所以最大 k 次预订是 1 次预订。</span><br><span class="line">myCalendarThree.book(50, 60); // 返回 1 ，第二个日程安排可以预订并且不存在相交，所以最大 k 次预订是 1 次预订。</span><br><span class="line">myCalendarThree.book(10, 40); // 返回 2 ，第三个日程安排 [10, 40) 与第一个日程安排相交，所以最大 k 次预订是 2 次预订。</span><br><span class="line">myCalendarThree.book(5, 15); // 返回 3 ，剩下的日程安排的最大 k 次预订是 3 次预订。</span><br><span class="line">myCalendarThree.book(5, 10); // 返回 3</span><br><span class="line">myCalendarThree.book(25, 55); // 返回 3</span><br></pre></td></tr></table></figure>

<h3 id="题解【线段树】"><a href="#题解【线段树】" class="headerlink" title="题解【线段树】"></a>题解【线段树】</h3><h3 id="方法一：差分数组"><a href="#方法一：差分数组" class="headerlink" title="方法一：差分数组"></a>方法一：差分数组</h3><p>采用差分数组解法，同<a href="#t2">我的日程安排表II</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCalendarThree</span> &#123;</span><br><span class="line">    TreeMap&lt;Integer, Integer&gt; delta;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyCalendarThree</span><span class="params">()</span> &#123;</span><br><span class="line">        delta = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">book</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        delta.put(start, delta.getOrDefault(start, <span class="number">0</span>)+<span class="number">1</span>);</span><br><span class="line">        delta.put(end, delta.getOrDefault(end, <span class="number">0</span>)-<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>, maxCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> val : delta.values()) &#123;</span><br><span class="line">            count += val;</span><br><span class="line">            maxCount = Math.max(count, maxCount);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxCount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="方法二：线段树"><a href="#方法二：线段树" class="headerlink" title="方法二：线段树"></a>方法二：线段树</h3><p>针对本题的线段树初级教程可以参考：<a href="https://leetcode.cn/problems/my-calendar-iii/solution/xian-duan-shu-by-xiaohu9527-rfzj/">线段树 – 新手篇</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyCalendarThree</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; tree;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, Integer&gt; lazy;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyCalendarThree</span><span class="params">()</span> &#123;</span><br><span class="line">        tree = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">        lazy = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">book</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">        update(start, end - <span class="number">1</span>, <span class="number">0</span>, <span class="number">1000000000</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> tree.getOrDefault(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">update</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> idx)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (r &lt; start || end &lt; l) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">if</span> (start &lt;= l &amp;&amp; r &lt;= end) &#123;</span><br><span class="line">            tree.put(idx, tree.getOrDefault(idx, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">            lazy.put(idx, lazy.getOrDefault(idx, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            update(start, end, l, mid, <span class="number">2</span> * idx);</span><br><span class="line">            update(start, end, mid + <span class="number">1</span>, r, <span class="number">2</span> * idx + <span class="number">1</span>);</span><br><span class="line">            tree.put(idx, lazy.getOrDefault(idx, <span class="number">0</span>) + Math.max(tree.getOrDefault(<span class="number">2</span> * idx, <span class="number">0</span>), tree.getOrDefault(<span class="number">2</span> * idx + <span class="number">1</span>, <span class="number">0</span>)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<blockquote>
<p>后续会出一篇关于线段树的详细教程！！！</p>
</blockquote>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法题</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker安装Halo博客&amp;配置swap虚拟内存</title>
    <url>/2022/06/17/%E6%9C%8D%E5%8A%A1%E5%99%A8Docker%E5%AE%89%E8%A3%85halo%E5%8D%9A%E5%AE%A2%E5%8F%8Anginx%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="Halo相关链接"><a href="#Halo相关链接" class="headerlink" title="Halo相关链接"></a>Halo相关链接</h3><p>官网：<a href="https://halo.run/">https://halo.run</a><br>文档：<a href="https://docs.halo.run/">https://docs.halo.run</a><br>社区：<a href="https://bbs.halo.run/">https://bbs.halo.run</a><br>主题仓库：<a href="https://halo.run/themes.html">https://halo.run/themes.html</a><br>开源地址：<a href="https://github.com/halo-dev/halo">https://github.com/halo-dev/halo</a></p>
<span id="more"></span>

<p>之前都是使用Hexo博客系统的，聊聊为什么改用Halo博客系统了。</p>
<p>Halo相比于Hexo博客的优缺点：</p>
<p><strong>优点：</strong></p>
<ul>
<li>Halo有后端，可以在线修改，可以在不同设备上进行修改发布；而Hexo则不行，它必须修改源文件，再重新编译发布</li>
<li>Halo配置更简单，有后台配置中心，而Hexo则全部依赖于自己修改配置文件。如果需要修改主题的话Halo几乎都不需要变动，而Hexo可能设计较大变动，因此对于喜欢经常更换主题的同学推荐Halo。</li>
<li>Halo是基于Java开发，而我本人也主要搞Java开发，碰到问题了更好解决。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>Halo是需要后台服务的，因此更依赖于硬件资源，我购买的服务器是1GB内存的，好几次都把服务器搞挂了，内存撑爆了。</li>
<li>页面加载速度Halo也比Hexo慢很多，因为Hexo是纯静态网站。</li>
</ul>
<h3 id="我现在的方案："><a href="#我现在的方案：" class="headerlink" title="我现在的方案："></a>我现在的方案：</h3><p><a href="https://ysfun.github.io/">https://ysfun.github.io</a>		域名用来部署Hexo博客</p>
<p><a href="https://www.ysfun.cn/">https://www.ysfun.cn</a>		域名用来部署Halo博客</p>
<p>两个博客系统同步更新！！！</p>
<h2 id="1-安装Docker"><a href="#1-安装Docker" class="headerlink" title="1. 安装Docker"></a>1. 安装Docker</h2><p>在新主机上首次安装 Docker Engine-Community 之前，需要设置 Docker 仓库。之后，您可以从仓库安装和更新 Docker。</p>
<h3 id="1-设置仓库"><a href="#1-设置仓库" class="headerlink" title="1. 设置仓库"></a>1. 设置仓库</h3><p>安装所需的软件包。yum-utils 提供了 yum-config-manager ，并且 device mapper 存储驱动程序需要 device-mapper-persistent-data 和 lvm2。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure>

<p>使用以下命令来设置稳定的仓库。</p>
<ul>
<li>使用官方源地址（比较慢）</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>

<ul>
<li>阿里云</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>

<ul>
<li>清华大学</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    https://mirrors.tuna.tsinghua.edu.cn/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>

<h3 id="2-安装-Docker-Engine-Community"><a href="#2-安装-Docker-Engine-Community" class="headerlink" title="2. 安装 Docker Engine-Community"></a>2. 安装 Docker Engine-Community</h3><p><strong>安装特定版本的 Docker Engine-Community，请在存储库中列出可用版本，然后选择并安装：</strong></p>
<ol>
<li>列出并排序您存储库中可用的版本。此示例按版本号（从高到低）对结果进行排序。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum list docker-ce --showduplicates | sort -r</span><br><span class="line"></span><br><span class="line">docker-ce.x86_64  3:18.09.1-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64  3:18.09.0-3.el7                     docker-ce-stable</span><br><span class="line">docker-ce.x86_64  18.06.1.ce-3.el7                    docker-ce-stable</span><br><span class="line">docker-ce.x86_64  18.06.0.ce-3.el7                    docker-ce-stable</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>通过其完整的软件包名称安装特定版本，该软件包名称是软件包名称（docker-ce）加上版本字符串（第二列），从第一个冒号（:）一直到第一个连字符，并用连字符（-）分隔。例如：docker-ce-18.09.1。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io</span><br></pre></td></tr></table></figure>

<h3 id="3-启动-x2F-卸载Docker"><a href="#3-启动-x2F-卸载Docker" class="headerlink" title="3. 启动&#x2F;卸载Docker"></a>3. 启动&#x2F;卸载Docker</h3><p>启动Docker</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo systemctl start docker</span><br></pre></td></tr></table></figure>

<p>卸载Docker</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">yum remove docker-ce</span><br></pre></td></tr></table></figure>

<h2 id="2-使用Docker安装Halo"><a href="#2-使用Docker安装Halo" class="headerlink" title="2. 使用Docker安装Halo"></a>2. 使用Docker安装Halo</h2><p>参考官方文档：<a href="https://docs.halo.run/getting-started/install/docker">使用 Docker 部署 Halo</a></p>
<p><strong>创建容器，启动halo</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it -d --name halo -p 8090:8090 -v ~/.halo:/root/.halo --restart=unless-stopped halohub/halo:1.5.3</span><br></pre></td></tr></table></figure>
<blockquote>
<p>INFO<br>注意：此命令默认使用自带的 H2 Database 数据库。如需使用 MySQL，请参考：使用 Docker 部署 Halo 和 MySQL</p>
</blockquote>
<p>-it： 开启输入功能并连接伪终端<br>-d： 后台运行容器<br>–name： 为容器指定一个名称<br>-p： 端口映射，格式为 主机(宿主)端口:容器端口 ，可在 application.yaml 配置。<br>-v： 工作目录映射。形式为：-v 宿主机路径:&#x2F;root&#x2F;.halo，后者不能修改。<br>–restart： 建议设置为 unless-stopped，在 Docker 启动的时候自动启动 Halo 容器。<br>打开 <a href="http://ip:端口号">http://ip:端口号</a> 即可看到安装引导界面。</p>
<blockquote>
<p>TIP<br>如果需要配置域名访问，建议先配置好反向代理以及域名解析再进行初始化。如果通过 <a href="http://ip:端口号">http://ip:端口号</a> 的形式无法访问，请到服务器厂商后台将运行的端口号添加到安全组，如果服务器使用了 Linux 面板，请检查此 Linux 面板是否有还有安全组配置，需要同样将端口号添加到安全组。</p>
</blockquote>
<h2 id="3-增加虚拟内存（Swap）"><a href="#3-增加虚拟内存（Swap）" class="headerlink" title="3. 增加虚拟内存（Swap）"></a>3. 增加虚拟内存（Swap）</h2><p>如果服务器内存不够，可使用swap增加虚拟内存</p>
<p>1、使用 “ swapon -s “ 命令可以检查系统是否已经配置过swap，如果该命令没有返回出结果，则代表该系统尚未配置过swap。</p>
<p>或者用 “ free ”命令查看，如果看到如下</p>
<p>Swap: 0 0 0</p>
<p>这一行的话，也可以说明目前没有配置过swap</p>
<blockquote>
<p>通常，我们建立一个单独的分区作为swap。然而有时候由于硬件或软件的限制，新建分区的方式无法实现，这种情况下就可以建立一个swap文件来实现同样的功能，我当然是通过建立swap文件来解决啦</p>
</blockquote>
<p><strong>步骤</strong></p>
<ol>
<li><p>bs&#x3D;1024 单位数据块（block）同时读入&#x2F;输出的块字节大小为1024个字节即1KB</p>
<p>count&#x3D;4194304 表示swap的大小分配为4G，计算方法：1024 * 1024 * 4</p>
</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">dd if=/dev/zero of=/var/swapfile bs=1024 count=4194304</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>格式化并转换为swap分区</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkswap /var/swapfile</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>修改下权限</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">chmod 600 /var/swapfile</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>挂载并激活分区</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">swapon /var/swapfile</span><br></pre></td></tr></table></figure>

<p>操作完毕后可使用<code>free</code>命令查看</p>
<p><img src="https://images.ysfun.cn/mac-img/image-20220617034309669.png"></p>
<p>注意到上面Swap内存used为0，说明并没有使用swap内存，因此还需配置swapness参数。</p>
<blockquote>
<p>设置swap不是说全部swap就可以用了，还是要设置参数才可以提供swap使用率的。 <a href="https://blog.csdn.net/weixin_43279032/article/details/111469024?spm=5176.smartservice_service_robot-chat.0.0.653c3cdaaGSkRM">https://blog.csdn.net/weixin_43279032&#x2F;article&#x2F;details&#x2F;111469024</a> swappiness的值的大小对如何使用swap分区是有着很大的联系的。swappiness&#x3D;0的时候表示最大限度使用物理内存，然后才是 swap空间，swappiness＝100的时候表示积极的使用swap分区，并且把内存上的数据及时的搬运到swap空间里面。linux的基本默认设置为60，具体如下： cat &#x2F;proc&#x2F;sys&#x2F;vm&#x2F;swappiness 也就是说，您的内存在使用到100-60&#x3D;40%的时候，就开始出现有交换分区的使用。 操作系统层面，要尽可能使用内存，对该参数进行调整。 临时调整的方法如下，调成10： sysctl vm.swappiness&#x3D;10 要想永久调整的话，需要将在&#x2F;etc&#x2F;sysctl.conf修改，加上： cat &#x2F;etc&#x2F;sysctl.conf vm.swappiness&#x3D;10</p>
</blockquote>
<ol>
<li>查看swappiness的值</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat /proc/sys/vm/swappiness</span><br><span class="line">或</span><br><span class="line">sysctl vm.swappiness</span><br><span class="line"></span><br><span class="line">0 # 说明不会使用swap空间</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>修改<code>/etc/sysctl.conf</code>文件中的<code>vm.swappiness</code>的值</li>
</ol>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">vm.swappiness = 60</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>手动使配置的参数生效，执行以下命令</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>再次查看swappiness的值</li>
</ol>
<p><img src="https://images.ysfun.cn/mac-img/image-20220617183409078.png"></p>
<p>可以看到swappiness参数配置成功</p>
<ol start="5">
<li>查看swap内存使用情况</li>
</ol>
<p><img src="https://images.ysfun.cn/mac-img/image-20220617183515053.png"></p>
<p>可以发现已经在使用swap内存了！</p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>Halo</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程：Synchronized底层实现&amp;锁升级</title>
    <url>/2022/06/20/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9ASynchronized%E9%94%81%E5%8D%87%E7%BA%A7/</url>
    <content><![CDATA[<p><img src="https://images.ysfun.cn/mac-img/image-20220620211730544.png"></p>
<p><code>synchronized</code>是Java中加锁的关键字，它可以用来修饰实例方法、静态方法以及代码块。值得注意的是，<code>synchronized</code>是一个对象锁，也就是它锁的是一个对象，因此无论使用哪一种方法，<code>synchronized</code>都需要一个锁对象。</p>
 <span id="more"></span>

<p>如果某一个资源被多个线程共享，为了避免因为资源抢占导致资源数据错乱，我们需要对线程进行同步，在Java中，<code>synchronized</code> 就是实现线程同步的关键字。使用<code>synchronized</code>关键字，拿到<strong>Java对象的锁</strong>，保护锁定的代码块，JVM保证同一时间只有一个线程拿到这个Java对象的锁，从而达到保证线程安全的目的。</p>
<h2 id="1-synchronized的作用"><a href="#1-synchronized的作用" class="headerlink" title="1. synchronized的作用"></a>1. synchronized的作用</h2><p><code>synchronized</code>可以同时保证并发操作的原子性、可见性和有序性。</p>
<ul>
<li><strong>原子性</strong></li>
</ul>
<p><strong>原子性是指一个或多个操作，要么全部执行并且执行过程中不会被任何因素打断，要么都不执行。</strong>被<code>synchronized</code>修饰的类或对象的操作都是原子的，因为在执行操作之前会获得类或对象的锁，知道操作执行完毕后才会释放锁。</p>
<ul>
<li><strong>可见性</strong></li>
</ul>
<p><strong>可见性是指当一个线程去修改某个共享变量的时候，这个修改对其他所有线程都是立即可见的。</strong><code>synchronized</code>和<code>volatile</code>都保证可见性，其中<code>synchronized</code>对一个类或对象加锁时，一个线程如果要访问该类或对象必须要获得它的锁，而这个锁状态对其他线程都是可见的，并且在锁释放之前会将修改的变量刷新到主内存中，从而保证资源的可见性。</p>
<ul>
<li><strong>有序性</strong></li>
</ul>
<p><strong>有序性是指程序完全按照代码的先后顺序执行。</strong><code>synchronized</code>和<code>volatile</code>都保证有序性，Java允许编译器和处理器对指令进行「重排」，但「指令重拍」并不会影响单线程的执行顺序，它影响的是多线程并发执行的顺序。<code>synchronized</code>保证了每个时刻只有一个线程访问同步代码块，也就确定了多线程执行同步代码块是分先后顺序的，从而保证了有序性。</p>
<h2 id="2-synchronized的使用"><a href="#2-synchronized的使用" class="headerlink" title="2. synchronized的使用"></a>2. synchronized的使用</h2><p><code>synchronized</code>关键字可以用来修饰三个地方：</p>
<ul>
<li>修饰<strong>实例方法</strong>，锁对象是当前的<strong>this</strong>对象</li>
<li>修饰<strong>静态方法</strong>，锁对象是方法区中的<strong>类对象</strong>，是一个全局锁。</li>
<li>修饰<strong>代码块</strong>，指定加锁对象，也就是<code>synchronized(object)&#123;&#125;</code>，锁对象是<code>()</code>中的对象。</li>
</ul>
<p>针对<code>synchronized</code>修饰的地方不同，实现的原理不同。</p>
<h3 id="2-1-synchronized修饰实例方法"><a href="#2-1-synchronized修饰实例方法" class="headerlink" title="2.1 synchronized修饰实例方法"></a>2.1 synchronized修饰实例方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sync</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sync method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过<code>javap -v SyncTest.class</code>查看反编译后的结果：</p>
<p><img src="https://images.ysfun.cn/mac-img/image-20220620154949504.png"></p>
<p>从反编译后的结果，我们可以看到<code>sync()</code>方法多了一个<code>ACC_SYNCHRONIZED</code>标识，<strong>JVM就是根据<code>ACC_SYNCHRONIZED</code>标识符来实现对象方法的同步</strong>。</p>
<p>当方法被执行时，JVM调用指令检查该方法上是否设置了<code>ACC_SYNCHRONIZED</code>标识，如果设置了则会获取锁对象的monitor对象，线程执行完方法体后，会释放锁对象的monitor对象。在此期间，其他线程无法获取锁对象的monitor对象。</p>
<h3 id="2-2-synchronized修饰静态方法"><a href="#2-2-synchronized修饰静态方法" class="headerlink" title="2.2 synchronized修饰静态方法"></a>2.2 synchronized修饰静态方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">sync</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sync method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>反编译后的结果：</p>
<p><img src="https://images.ysfun.cn/mac-img/image-20220620160121201.png"></p>
<p>可以看到和修饰实例方法相同，也是在<code>sync()</code>方法上多了一个<code>ACC_SYNCHRONIZED</code>标识，可以得出<code>synchronized</code>修饰实例方法和静态方法的实现原理相同，都是通过<code>ACC_SYNCHRONIZED</code>标识符来实现的。但二者的差别在于锁的对象不同，修饰实例方法锁的对象为当前类的实例（this）对象；而修饰静态方法锁的对象则为当前类（Class）对象。</p>
<p>一个类的A对象实例访问这个类的B对象实例正在执行的非静态<code>synchronized</code>方法，是被允许的，因为非静态<code>synchronized</code>方法锁住的是对象实例，对于两个不同的对象实例，<code>synchronized</code>锁住的对象不同。然而当一个类的A对象实例试图访问这个类的B对象实例正在执行的静态<code>synchronized</code>方法，这是不允许的，因为对于由<code>synchronized</code>修饰的静态方法锁住的是Class对象，A实例和B实例是同一个Class对象，相当于被同一把「锁」锁住了，因此只允许同步访问。</p>
<p>如果一个线程 A 调用一个实例对象的非静态 <code>synchronized</code> 方法，而线程 B 需要调用这个实例对象所属类的静态 <code>synchronized</code> 方法，是允许的，不会发生互斥现象，<strong>因为访问静态 <code>synchronized</code> 方法占用的锁是当前类的锁，而访问非静态 <code>synchronized</code> 方法占用的锁是当前实例对象锁</strong>。</p>
<h3 id="2-3-synchronized修饰代码块"><a href="#2-3-synchronized修饰代码块" class="headerlink" title="2.3 synchronized修饰代码块"></a>2.3 synchronized修饰代码块</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SyncTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sync</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;sync method&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字节码信息：</p>
<p><img src="https://images.ysfun.cn/mac-img/image-20220620162106570.png"></p>
<p>我们可以看到在<code>synchronized</code>修饰的代码块起止位置生成了<code>monitorenter</code>和<code>monitorexit</code>指令：</p>
<ul>
<li><strong>monitorenter</strong>：该指令表示获取对象的monitor对象，这时monitor对象中的count会+1，如果monitor对象被其他线程所获取，该线程会被阻塞，直到count&#x3D;0，再重新获取monitor对象。</li>
<li><strong>monitorexit</strong>：该指令表示线程释放锁对象的monitor对象，这时monitor对象的count会-1变为0，其他阻塞的线程可以重新尝试获取锁对象的monitor对象。</li>
</ul>
<blockquote>
<p>synchronized关键字是如何对一个对象加锁实现代码同步的呢？如果想弄清楚，那就不得不先了解一下Java对象的对象头了。</p>
</blockquote>
<h2 id="3-Java对象头和Monitor对象"><a href="#3-Java对象头和Monitor对象" class="headerlink" title="3. Java对象头和Monitor对象"></a>3. Java对象头和Monitor对象</h2><p>在JVM中，对象在内存中的布局可以分为三个区域：对象头、实例数据以及填充数据。</p>
<ul>
<li><p>实例数据：存放类的属性信息，包括父类的属性信息，这部分按4字节对齐。</p>
</li>
<li><p>填充数据：由于虚拟机要求对象起始地址必须是8字节的整数倍，填充数据不是必须存在的，仅仅是为了字节对齐。</p>
</li>
<li><p>对象头：在HotSpot虚拟机中，对象头又被分为两部分：Mark Word（标记字段）和Class Point（类型指针）。如果是数组，还会有数组长度。对象头是本次讨论的重点，下面详细展开。</p>
</li>
</ul>
<p><img src="https://images.ysfun.cn/mac-img/%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E4%B8%89%E5%A4%A7%E5%8C%BA%E5%9F%9F-1.jpg"></p>
<h3 id="3-1-对象头"><a href="#3-1-对象头" class="headerlink" title="3.1 对象头"></a>3.1 对象头</h3><p>在对象头的Mark Word中存储了对象自身的运行时数据，如<strong>哈希码、GC分代年龄、锁状态、线程持有的锁、偏向线程ID及偏向时间戳</strong>等。同时，Mark Word也记录的对象和锁有关的信息。</p>
<p>当对象被<code>synchronized</code>当成同步锁时，和锁相关的一系列操作都与Mark Word有关。由于JDK1.6版本中对<code>synchronized</code>进行了锁优化，引入了偏向锁和轻量级锁（关于锁优化后面详细讨论）。<strong>Mark Word</strong>在不同锁状态下存储的内容有所不同，我们以32位虚拟机中对象头的存储内容为例：</p>
<p><a id="p1"></a><img src="https://images.ysfun.cn/mac-img/image-20220620170042988.png"></p>
<p>从图中我们可以清除地看到，Mark Word中有2bit的数据来标记锁的状态信息。无锁和偏向锁标记状态为01，轻量级锁为00，重量级锁为10。</p>
<ul>
<li>当状态为偏向锁时，Mark Word存储了偏向锁的线程ID。</li>
<li>当状态为轻量级锁时，Mark Word存储了指向线程栈中Lock Record的指针。</li>
<li>当状态为重量级锁时，Mark Word存储了指向堆中Monitor对象的指针。</li>
</ul>
<p>当前我们只讨论重量级锁，因为重量级锁相当于对synchronized优化之前的状态。关于偏向锁和轻量级锁在后边锁优化章节中详细讲解。</p>
<p>可以看到，当为重量级锁时，对象头的MarkWord中存储了指向Monitor对象的指针。那么Monitor又是什么呢？</p>
<h3 id="3-2-Monitor对象"><a href="#3-2-Monitor对象" class="headerlink" title="3.2 Monitor对象"></a>3.2 Monitor对象</h3><p>Monitor对象被成为管程或监视器锁。在Java中，每个对象都关联了一个Monitor对象，这个Monitor对象既可以与对象一起创建销毁，也可以在线程试图获取对象锁时生成。当这个Monitor对象被线程持有后，它便处于锁定状态。</p>
<p>在HotSpot虚拟机中，Monitor是由<u>ObjectMonitor</u>实现的，它是一个使用c++实现的类，主要数据结构如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ObjectMonitor</span>() &#123;</span><br><span class="line">  _header       = <span class="literal">NULL</span>;</span><br><span class="line">  _count        = <span class="number">0</span>; <span class="comment">//记录个数</span></span><br><span class="line">  _waiters      = <span class="number">0</span>,</span><br><span class="line">  _recursions   = <span class="number">0</span>;  <span class="comment">// 线程重入次数</span></span><br><span class="line">  _object       = <span class="literal">NULL</span>;</span><br><span class="line">  _owner        = <span class="literal">NULL</span>;</span><br><span class="line">  _WaitSet      = <span class="literal">NULL</span>; <span class="comment">// 调用wait方法后的线程会被加入到_WaitSet</span></span><br><span class="line">  _WaitSetLock  = <span class="number">0</span> ;</span><br><span class="line">  _Responsible  = <span class="literal">NULL</span> ;</span><br><span class="line">  _succ         = <span class="literal">NULL</span> ;</span><br><span class="line">  _cxq          = <span class="literal">NULL</span> ; <span class="comment">// 阻塞队列，线程被唤醒后根据决策判读是放入cxq还是EntryList</span></span><br><span class="line">  FreeNext      = <span class="literal">NULL</span> ;</span><br><span class="line">  _EntryList    = <span class="literal">NULL</span> ; <span class="comment">// 没有抢到锁的线程会被放到这个队列</span></span><br><span class="line">  _SpinFreq     = <span class="number">0</span> ;</span><br><span class="line">  _SpinClock    = <span class="number">0</span> ;</span><br><span class="line">  OwnerIsThread = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ObjectMonitor</code>中有五个重要部分，分别为_owner, _WaitSet, _cxq, _EntryList和count。</p>
<ul>
<li><code>_owner</code>用来指向持有Monitor的线程，它的初始值为Null，表示当前没有任何线程持有Monitor。当一个线程成功持有该锁后会保存线程ID，等到线程释放锁后<code>_owner</code>又会重置为Null。</li>
<li><code>_WaitSet</code>调用锁对象的<code>wait</code>方法后的线程会被加入到<code>_WaitSet</code>。</li>
<li><code>_cxq</code>是一个阻塞队列，线程被唤醒后根据决策判断是放入<code>cxq</code>还是<code>EntryList</code>。</li>
<li><code>_EntryList</code>没有抢到锁的线程会放到这个队列。</li>
<li><code>count</code>用于记录线程获取锁的次数，成功获取锁count会+1，释放锁会-1。</li>
</ul>
<p>如果线程获取到对象的Monitor后，会将Monitor中的<code>_owner</code>设置为该线程的ID，并且<code>count</code>会+1；如果调用了锁对象的wait()方法，线程会释放当前持有的Monitor，并将<code>_owner</code>置为null，且count减一，同时该线程会进入到<code>_WaitSet</code>集合中等待被唤醒。</p>
<blockquote>
<p>注意_WaitSet, _cxq, _EntryList都是链表结构，存放的是封装了线程的ObjectMonitor对象。</p>
</blockquote>
<p>在多条线程竞争Monitor锁时，所有没有竞争到锁的线程都会被封装为ObjectMonitor并加入到<code>_EntryList</code>队列。当一个已经获得锁的线程调用对象的<code>wait()</code>方法后，线程也会被会被封装为ObjectMonitor并加入到<code>_WaitSet</code>队列中。当调用线程的notify()方法后，会根据不同情况来决定是将_WaitSet中的元素转移到<code>_cxq</code>队列还是<code>_EntryList</code>队列。等到获得锁的线程释放锁后，会根据不同条件执行<code>_EntryList</code>中的线程或者将<code>_cxq</code>转移到<code>_EntryList</code>再执行<code>EntryList</code>中的线程。</p>
<p>所以，可以看出<code>_WaitSet</code>中存放的是处于WAITING状态等待被唤醒的线程；而<code>_EntryList</code>队列中存放的是等待锁BLOCKED状态的线程。<code>_cxq</code>队列仅仅是用来临时存放，最终还是会被转移到<code>EntryList</code>队列中等待获取锁。</p>
<blockquote>
<p>了解了对象头和Monitor，那么synchronized是如何利用Monitor进行工作的？</p>
</blockquote>
<h2 id="4-synchronized同步原理"><a href="#4-synchronized同步原理" class="headerlink" title="4. synchronized同步原理"></a>4. synchronized同步原理<a id="ch4"></a></h2><p>从上面<strong>synchronized</strong>放置的位置不同可以得出，<strong>synchronized</strong>用来修饰方法时，是通过<strong>ACC_SYNCHRONIZED</strong>标识符来保持线程同步的。而用来修饰代码块时，是通过<strong>monitorenter</strong>和<strong>monitorexit</strong>指令来完成。</p>
<ul>
<li><strong>monitorenter</strong>：每个对象都是一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行monitorenter指令时尝试获取monitor的所有权，过程如下：</li>
</ul>
<blockquote>
<ol>
<li>如果monitor的count为0，则该线程进入Monitor，然后count变为1，该线程即为monitor对象的持有者。</li>
<li>如果线程已占有monitor，只是重新进入，则count加1。</li>
<li>如果其他线程占有了该monitor，则当前线程获取锁失败进入阻塞状态并加入到_EntryList中，直到等待的锁释放，再重新尝试获取monitor的所有权。</li>
</ol>
</blockquote>
<ul>
<li><strong>monitorexit</strong>：执行monitorexit的线程必须是所对应的monitor的持有者者。指令执行时，monitor的count减1，如果减1后count为0，那线程退出monitor，不再是这个monitor的所有者。其他被这个monitor阻塞的线程可以尝试去获取这个 monitor 的所有权。</li>
</ul>
<blockquote>
<p>注：monitorexit指令出现了两次，第1次为同步正常退出释放锁；第2次为发生异步退出释放锁；</p>
</blockquote>
<ul>
<li><strong>ACC_SYNCHRONIZE</strong>：当方法调用时，调用指令将会检查方法的 <strong>ACC_SYNCHRONIZED</strong> 访问标志是否被设置，如果设置了，执行线程将先获取 monitor，获取成功之后才能执行方法体，方法执行完后再释放monitor。<strong>在方法执行期间，其他任何线程都无法再获得同一个monitor对象。</strong></li>
</ul>
<p>两种同步的方式本质上没有区别，都是通过JVM调用操作系统的互斥锁<code>mutex</code>来实现的，被阻塞的线程会被挂起，等待重新调度，会导致「用户态」和「内核态」的切换，对性能影响比较大。</p>
<p>通过上面的描述，我们可以知道<code>synchronized</code>的语义底层都是通过Monitor对象来实现的，其实<code>wait()/notify()</code>方法也依赖于Monitor对象，这就是为什么只能在同步方法或代码块中调用，否则会抛出<code>java.lang.IllegalMonitorStateException</code>的异常。</p>
<h2 id="5-锁升级"><a href="#5-锁升级" class="headerlink" title="5. 锁升级"></a>5. 锁升级</h2><p>在JDK6之前，Monitor的实现完全依赖于操作系统内部的「互斥锁」来实现的，因为需要进行用户态到内核态的切换，所以其同步操作</p>
<p>是一个无差别的重量级锁操作；JDK6版本中，Java官方从JVM层面对<code>synchronized</code>进行了优化，提供了三种不同的Monitor实现，也就是常说的三种不同锁：偏向锁、轻量级锁、重量级锁。</p>
<p>随着锁的竞争变激烈，锁的状态会出现一个升级的过程。即可以从偏向锁升级到轻量级锁，再从轻量级锁升级为重量级锁。注意，锁升级的过程是不可逆的，即一旦锁升级为重量级锁就不会降级为轻量级锁。</p>
<h3 id="5-1-偏向锁"><a href="#5-1-偏向锁" class="headerlink" title="5.1 偏向锁"></a>5.1 偏向锁</h3><p><strong>大多数情况下锁不仅不存在多线程竞争关系，而且大多数时候都是同一线程多次获得</strong>，因此，为了减少同一线程获取锁的代价而引入了「偏向锁」的概念。</p>
<p><strong><span style="color:blue">获取锁：</span></strong></p>
<ol>
<li>检测Mark Word是否为可偏向状态，即判断对象头第30个bit的位置是否为偏向锁1，锁标志位为01；</li>
<li>若为可偏向状态，则测试Mark Word中的线程ID是否为当前线程ID，如果是则执行步骤（5），否则执行步骤（3）；</li>
<li>如果线程ID不是当前线程ID，则通过CAS竞争锁，竞争成功则将Mark Word的线程ID替换为当前线程ID，否则执行步骤（4）；</li>
<li>通过CAS竞争锁失败，说明当前存在多线程竞争的情况，当达到全局安全点，获得偏向锁的线程会被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码；</li>
<li>执行同步代码。</li>
</ol>
<p>**<span style="color:blue">释放锁：</span>**偏向锁的释放采用了一种只有竞争才会释放锁的机制，线程不会主动释放偏向锁，需要等待其他线程来竞争。偏向锁的撤销需要等待全局安全点（这个时间点上没有正在执行的代码）。其步骤如下：</p>
<ol>
<li>暂停拥有偏向锁的线程，判断锁对象是否还处于被锁定状态；</li>
<li>撤销偏向锁，恢复到无锁状态（1）或者升级为轻量级锁的状态。</li>
</ol>
<blockquote>
<p>在有锁状态下，位置被锁指针占用，那么hashCode等信息存放在哪里？（如图<a href="#p1">Mark Word内存布局</a>）</p>
<p>答案：</p>
<ol>
<li>当一个对象已经计算过identity hash code，它就无法进入偏向锁状态；</li>
<li>当一个对象当前正处于偏向锁状态，并且需要计算其identity hash code的话，则它的偏向锁会被撤销，并且锁会膨胀为重量锁；</li>
<li>重量锁的实现中，ObjectMonitor类里有字段可以记录非加锁状态下的mark word，其中可以存储identity hash code的值。或者简单说就是重量锁可以存下identity hash code。</li>
</ol>
<p>注意：这里讨论的hash code都只针对identity hash code。用户自定义的hashCode()方法所返回的值跟这里讨论的不是一回事。Identity hash code是未被覆写的 java.lang.Object.hashCode() 或者 java.lang.System.identityHashCode(Object) 所返回的值。</p>
</blockquote>
<h3 id="5-2-轻量级锁"><a href="#5-2-轻量级锁" class="headerlink" title="5.2 轻量级锁"></a>5.2 轻量级锁</h3><p>引入轻量级锁的主要目的是在多线程竞争不激烈的情况下，通过CAS竞争锁，减少传统重量级锁使用操作系统互斥产生的性能消耗。当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁，其步骤如下：</p>
<p><strong><span style="color:blue">获取锁：</span></strong></p>
<ol>
<li>判断当前对象是否处于无锁状态（偏向锁标志位为0，锁状态我01），若是，则JVM首先将当前线程的栈帧中建立一份名为锁记录（Lock Record）的空间，用于存储锁对象目前Mark Word的拷贝（官方把这份拷贝加了一个Displaced前缀，即Displaced Mark Word）；否则执行步骤（3）；</li>
<li>JVM利用CAS操作尝试将对象的Mark Word指向为Lock Record的指向，如果成功则表示竞争到锁，则将锁标志位变为00（表示此对象处于轻量级锁状态），执行同步操作；如果失败，则执行步骤（3）；</li>
<li>判断当前对象的Mark Word是否指向当前线程的栈帧，如果是则表示当前线程已经持有当前锁，则直接执行同步代码；否则只能说该锁对象已经被其他线程抢占了，这是轻量级锁需要膨胀为重量级锁，锁标志位变为10，后面的线程将会进入阻塞状态。</li>
</ol>
<p>**<span style="color:blue">释放锁：</span>**轻量级锁也是通过CAS来释放的，具体步骤：</p>
<ol>
<li>取出轻量级锁保存在Displaced Mark Word中的数据；</li>
<li>用CAS操作取出数据替换当前Mark Word中的数据，如果成功则表示释放锁成功，否则执行（3）；</li>
<li>如果CAS替换操作失败，说明有其他线程尝试获取锁，则需要在释放锁的同时唤醒被挂起的线程。</li>
</ol>
<blockquote>
<p>对于轻量级锁，其提升性能的依据是”对于绝大部分锁，在整个生命周期内是不存在竞争的“，如果打破了这个依据则除了互斥的开销外，还有额外的CAS操作，因此在有多线程锁竞争的情况下，轻量级锁会比重量级锁更慢。</p>
</blockquote>
<p><strong>自旋锁：</strong></p>
<p>轻量级获取锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。</p>
<p>自旋锁是基于<strong>在大多数情况下，线程持有锁的时间都不会太长</strong>。如果直接挂起操作系统层面的线程可能会得不偿失，毕竟操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。因此自旋锁会假设在不久将来，当前的线程可以获得锁，因此虚拟机会让当前想要获取锁的线程做几个空循环(这也是称为自旋的原因)，不断的尝试获取锁。</p>
<p>在jdk1.6以前，默认轻量级锁自旋次数是10次，如果超过这个次数或自旋线程数超过CPU核数的一半，就会升级为重量级锁。这时因为如果自旋次数过多，或过多线程进入自旋，会导致消耗过多cpu资源，重量级锁情况下线程进入等待队列可以降低cpu资源的消耗。自旋次数的值也可以通过jvm参数进行修改：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">-XX:PreBlockSpin</span><br></pre></td></tr></table></figure>

<p>jdk1.6以后加入了<strong>自适应自旋锁</strong> （<code>Adapative Self Spinning</code>），自旋的次数不再固定，由jvm自己控制，由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定：</p>
<ul>
<li>对于某个锁对象，如果自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也是很有可能再次成功，进而允许自旋等待持续相对更长时间</li>
<li>对于某个锁对象，如果自旋很少成功获得过锁，那在以后尝试获取这个锁时将可能省略掉自旋过程，直接阻塞线程，避免浪费处理器资源。</li>
</ul>
<h3 id="5-3-重量级锁"><a href="#5-3-重量级锁" class="headerlink" title="5.3 重量级锁"></a>5.3 重量级锁</h3><p>重量级锁是由轻量级锁升级而来，当<strong>同一时间有多个线程竞争锁</strong>时，锁就会被升级成重量级锁，此时其申请锁带来的开销也就变大。重量级锁一般使用场景会在追求吞吐量，同步块或者同步方法执行时间较长的场景。</p>
<p>前面讲到<code>synchronized</code>是通过对象内部的监视器锁（Monitor）来实现的（实现原理在<a href="#ch4">第四节</a>已经详细介绍过了）。但是监视器锁本质又是依赖于底层的操作系统的<code>Mutex Lock</code>来实现的。而操作系统实现线程之间的切换这就需要从用户态转换到内核态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么<code>synchronized</code>效率低的原因。因此，这种依赖于操作系统<code>Mutex Lock</code>所实现的锁我们称之为重量级锁。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程：volatile关键字&amp;JMM内存模型</title>
    <url>/2022/06/27/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%EF%BC%9Avolatile%E5%85%B3%E9%94%AE%E5%AD%97-JMM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<p><img src="https://images.ysfun.cn/mac-img/image-20220628001825805.png"></p>
<p>前面在<a href="https://www.ysfun.cn/archives/bing-fa-bian-cheng-synchronized-di-ceng-shi-xian--suo-sheng-ji">并发编程：Synchronized底层实现&amp;锁升级</a>一文中详细地介绍了<code>synchronized</code>关键字，而相比于<code>synchronized</code>关键字，<code>volatile</code>关键字是Java虚拟机提供的一个更轻量级的同步机制，下面我们对<code>volatile</code>关键字展开详细介绍。</p>
<span id="more"></span>

<p><strong>被volatile修饰的变量能够保证每个线程能够获取该变量的最新值，从而避免出现数据脏读的现象。</strong>要了解<code>volatile</code>实现原理，就必须先了解<strong>Java内存模型（JMM）</strong>。</p>
<h2 id="1-内存模型概述"><a href="#1-内存模型概述" class="headerlink" title="1. 内存模型概述"></a>1. 内存模型概述</h2><p>JMM（Java Memory Model，Java内存模型）是java虚拟机规范中所定义的一种内存模型，Java内存模型是标准化的，屏蔽掉了底层不同计算机的区别。</p>
<p>在介绍Java内存模型之前，我们先介绍一下现代计算机的内存模型。</p>
<h3 id="1-1-计算机的内存模型"><a href="#1-1-计算机的内存模型" class="headerlink" title="1.1 计算机的内存模型"></a>1.1 计算机的内存模型</h3><p>早起计算机中CPU和内存的速度是差不多的，但是在现代计算中，<strong>CPU的速度远超过内存的读写速度</strong>，由于计算机的存储设备与处理器运算速度差了好几个量级，所以现代计算机必须在二者之间引入一层读写速度尽可能接近处理器运算速度的<strong>高速缓存（Cache）</strong>来作为内存和处理器之间的缓冲。</p>
<p>将需要使用的数据复制到高速缓存中，使其进行快速的运算和存取，当运算结束后将缓存中的数据同步到内存，这样处理器就不需要等待内存缓慢的存取数据了。</p>
<p>基于高速缓存的方式可以很好地处理内存和处理器运算速度差异过大的问题，但是也为计算机系统带来的更高的复杂度，因为它引入了一个新的问题：<strong>缓存一致性</strong>。</p>
<p>在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一个主内存。</p>
<p><img src="https://images.ysfun.cn/mac-img/%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.jpg" alt="现代计算机内存模型"></p>
<p>在程序运行中，会将运行所需要的数据复制一份到 CPU 高速缓存中，在进行运算时 CPU 不再也主存打交道，而是直接从高速缓存中读写数据，只有当运行结束后，才会将数据刷新到主存中。举一个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>当线程运行这段代码时，会先从主内存中读取<code>i</code>的值（假设此时<code>i=1</code>），然后复制一份到CPU高速缓存中，然后 CPU 执行 <code>+ 1</code> 的操作（此时 <code>i = 2</code>），然后将数据 <code>i = 2</code> 写入到告诉缓存中，最后刷新到主存中。</p>
<p>其实这样做在单线程中是没有问题的，有问题的是在多线程中。如下：</p>
<p>假如有两个线程 A、B 都执行这个操作（ <code>i++</code> ），按照我们正常的逻辑思维主存中的i值应该<code>=3</code> 。但事实是这样么？分析如下：</p>
<p>两个线程从主存中读取 <code>i</code> 的值( 假设此时 <code>i = 1</code> )，到各自的高速缓存中，然后线程 A 执行 <code>+1</code> 操作并将结果写入高速缓存中，最后写入主存中，此时主存 <code>i = 2</code> 。但是此时线程B高速缓存中<code>i</code>的值仍为1，线程B执行同样操作后，主存中的 <code>i=2</code> 。所以最终结果为 2 并不是 3 。这种现象就是<strong>缓存一致性问题</strong>。</p>
<p><strong>解决缓存一致性问题的方案：</strong></p>
<ol>
<li>在总线加LOCK锁的方式</li>
<li>通过缓存一致性协议</li>
</ol>
<p>第一种方案， 存在一个问题，它是采用一种独占的方式来实现的，即总线加 LOCK# 锁的话，只能有一个 CPU 能够运行，其他 CPU 都得阻塞，效率较为低下。</p>
<p>第二种方案，缓存一致性协议（MESI协议），它确保每个缓存中使用的共享变量的副本是一致的。其核心思想是：当某个CPU在写数据时，如果发现操作的变量是共享变量，则会通知其他CPU告知该共享变量的缓存失效，因此在其他CPU读取该变量时，发现缓存失效则会重新从主内存中读取数据。</p>
<p>根据缓存一致性协议，再来看前面的例子，线程A、B都执行</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">i = i + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>最开始主内存、缓存中<code>i=1</code>，线程A先执行语句，缓存1中的<code>i=2</code>，并刷新到主内存，同时通知其他线程缓存失效；线程B再执行语句，发现缓存数据失效，则从主内存中读取数据<code>i=2</code>，执行<code>+1</code>命令，最终<code>i=3</code>。</p>
<p><img src="https://images.ysfun.cn/mac-img/%E7%BC%93%E5%AD%98%E6%9B%B4%E6%96%B0%E8%BF%87%E7%A8%8B-1.jpg"></p>
<h3 id="1-2-JMM（Java内存模型）"><a href="#1-2-JMM（Java内存模型）" class="headerlink" title="1.2 JMM（Java内存模型）"></a>1.2 JMM（Java内存模型）</h3><p>JMM描述了Java程序中各种变量（线程共享变量）的访问规则，以及在JVM中将变量存储到内存和从内存中读取变量的底层细节。</p>
<p><strong>JMM具有以下规定：</strong></p>
<ul>
<li><p>所有共享变量都存储在主内存。注意这里所说的变量包括类变量和实例变量，不包括局部变量，因为局部变量是线程私有的，不存在竞争问题。</p>
</li>
<li><p>每个线程还有自己的工作内存，线程的工作内存保存了使用到的变量的工作副本。</p>
</li>
<li><p>所有线程对变量的操作（读、写）都必须在工作内存中进行，而不能直接操作主内存。</p>
</li>
<li><p>一个线程不能访问其他线程的工作内存中的变量，线程中变量的值的传递需要通过主内存中转实现。</p>
</li>
</ul>
<p><strong>工作内存与主内存：</strong></p>
<p><img src="https://images.ysfun.cn/mac-img/JMM%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98%E4%B8%8E%E4%B8%BB%E5%86%85%E5%AD%98.jpg"></p>
<h2 id="2-JMM三大特性"><a href="#2-JMM三大特性" class="headerlink" title="2. JMM三大特性"></a>2. JMM三大特性</h2><h3 id="2-1-可见性"><a href="#2-1-可见性" class="headerlink" title="2.1 可见性"></a>2.1 可见性</h3><p>根据JMM规定，我们知道各个线程中对主内存中共享变量的操作都是各个线程格子拷贝到自己的工作内存区域中进行的操作后，然后回写到主内存中的。</p>
<p>这就有可能存在线程A修改了共享变量X的值，但未及时更新到主内存中，另一个线程B又对共享变量X进行了操作，此时线程A对共享变量的修改是不可见的。</p>
<p>这种工作内存和主内存同步延迟现象导致了可见性问题。</p>
<p>使用<code>volatile</code>关键字可以解决可见性问题，后面会介绍其原理。</p>
<h3 id="2-2-原子性"><a href="#2-2-原子性" class="headerlink" title="2.2 原子性"></a>2.2 原子性</h3><p>原子性是指一个或多个操作，要么全部执行并且执行过程中不会被任何因素打断，要么都不执行。在Java中即便是一条最简单的语句都可能是多条CPU指令组成的，例如：</p>
<p><img src="https://images.ysfun.cn/mac-img/image-20220627205429244.png"></p>
<p>一条最简单的<code>i = i + 1</code>的Java语句，经过反编译后可以返现它是由多条字节码执行组成，因此如果不适用额外手段保证语句<code>i = i + 1</code>的原子性，可能会导致字节码执行到一半时出现问题，导致后续操作无法执行成功。</p>
<p><code>volatile</code>关键字无法保证原子性，可以通过<code>synchronized</code>或者加锁的方式保证原子性，或者使用<code>java.util.concurrent</code>包下的原子类（如<code>AtomicInteger</code>, <code>AtomicLong</code>等）。</p>
<h3 id="2-3-有序性"><a href="#2-3-有序性" class="headerlink" title="2.3 有序性"></a>2.3 有序性</h3><p>在计算机执行程序时，为了提高性能，编译器和处理器的常常会对<strong>指令做重排，</strong> 一般分为三种情况。</p>
<ul>
<li><strong>编译器优化的重排序</strong>。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序;</li>
<li><strong>指令级并行的重排序</strong>。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序;</li>
<li><strong>内存系统的重排序</strong>。由于处理器使用缓存和读&#x2F;写缓冲区，这使得加载和存储操作看上去可能是在乱序执行的。</li>
</ul>
<p><img src="https://images.ysfun.cn/mac-img/%E4%B8%89%E6%AC%A1%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92.jpg"><br>单线程环境下能够保证程序最终执行结果和代码顺序执行的结果一致。</p>
<p>处理器在进行重排序时必须要考虑之前的<strong>数据依赖性</strong>。多线程环境中线程交替执行，由于编译器优化重排的存在，两个线程中使用的变量能否保证一致性是否无法确定的，结果无法预测。</p>
<blockquote>
<p>Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。</p>
</blockquote>
<h2 id="3-volatile语义及实现原理"><a href="#3-volatile语义及实现原理" class="headerlink" title="3. volatile语义及实现原理"></a>3. volatile语义及实现原理</h2><p><code>volatile</code>是 JVM 虚拟机提供的轻量级的同步机制，它具有两层语义：</p>
<ul>
<li>保证可见性，不保证原子性</li>
<li>禁止指令重排</li>
</ul>
<h3 id="3-1-volatile如何保证可见性？"><a href="#3-1-volatile如何保证可见性？" class="headerlink" title="3.1 volatile如何保证可见性？"></a>3.1 volatile如何保证可见性？</h3><p>一个被<code>volatile</code>修饰的共享变量，一旦一个线程对该变量进行了写操作，立马强制把该工作内存中修改后的值刷新到主内存，然后强制其他线程的工作内存的缓存失效。</p>
<p><strong><code>volatile</code>是怎么实现的？</strong></p>
<p>在生成汇编代码时，会在<code>volatile</code>修饰的共享变量进行写操作时<strong>多出Lock前缀的指令</strong>。</p>
<p>Lock前缀在多核处理器下主要有两方面的作用：</p>
<ol>
<li>将当前处理器缓存的数据写回主内存</li>
<li>这个写回内存的操作会使其他CPU缓存了该内存地址的数据失效</li>
</ol>
<p>如果对声明了volatile的变量进行写操作，JVM就会向处理器发送一条Lock前缀的指令，将这个变量所在缓存的数据写回到主内存。但是，就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题。所以，在多处理器下，为了保证各个处理器的缓存是一致的，就会实现<strong>缓存一致性</strong>协议，<strong>每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期</strong>了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器对这个数据进行修改操作的时候，会重新从系统内存中把数据读到处理器缓存里。因此，经过分析我们可以得出如下结论：</p>
<ol>
<li>Lock前缀的指令会引起处理器缓存写回内存；</li>
<li>一个处理器的缓存回写到内存会导致其他处理器的缓存失效；</li>
<li>当处理器发现本地缓存失效后，就会从内存中重读该变量数据，即可以获取当前最新值。</li>
</ol>
<p>这样针对volatile变量通过这样的机制就使得每个线程都能获得该变量的最新值。</p>
<blockquote>
<p><strong>为什么加锁可以保证可见性？</strong></p>
<p>因为线程获得锁后，会<strong>清空工作内存</strong>，<strong>从主内存中拷贝共享变量最新值到工作内存作为副本</strong>，执行代码，<strong>将修改后的副本的值刷回主内存</strong>，释放锁。</p>
<p>而对于其他获取不到锁的线程会阻塞等待，所以变量的值一直都是最新的。</p>
</blockquote>
<h3 id="3-2-volatile禁止指令重排"><a href="#3-2-volatile禁止指令重排" class="headerlink" title="3.2 volatile禁止指令重排"></a>3.2 volatile禁止指令重排</h3><p>学习<code>volatile</code>如何禁止指令重排之前，我们先来了解一下<a href="https://juejin.cn/post/6844903600318054413#heading-3">happens-before规则</a>：</p>
<p>如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在<code>happens-before</code>关系。<code>happens-before</code>具体的一共有八项规则：</p>
<ol>
<li>程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。</li>
<li>监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。</li>
<li>volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。</li>
<li>传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。</li>
<li>start()规则：如果线程A执行操作ThreadB.start()（启动线程B），那么A线程的ThreadB.start()操作happens-before于线程B中的任意操作。</li>
<li>join()规则：如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。</li>
<li>程序中断规则：对线程interrupted()方法的调用先行于被中断线程的代码检测到中断时间的发生。</li>
<li>对象finalize规则：一个对象的初始化完成（构造函数执行结束）先行于发生它的finalize()方法的开始。</li>
</ol>
<p>我们着重看<strong>第三点 Volatile规则</strong>：对 <code>volatile</code>变量的写操作，happen-before 后续的读操作。为了实现 <code>volatile</code> 内存语义，JMM会重排序，其规则如下：</p>
<p><img src="https://images.ysfun.cn/mac-img/volatile%E6%8C%87%E4%BB%A4%E9%87%8D%E6%8E%92%E8%A7%84%E5%88%99%E8%A1%A8.jpg"></p>
<p><strong>观察加入 <code>volatile</code> 关键字和没有加入 <code>volatile</code> 关键字时所生成的汇编代码发现，加入<code>volatile</code> 关键字时，会多出一个 lock 前缀指令</strong>。lock 前缀指令，其实就相当于一个内存屏障。内存屏障是一组处理指令，用来实现对内存操作的顺序限制。<code>volatile</code> 的底层就是通过内存屏障来实现的。</p>
<p><strong>内存屏障</strong></p>
<p>JMM内存屏障分为如下四类：</p>
<table>
<thead>
<tr>
<th>屏障类型</th>
<th>指令示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>LoadLoad Barriers</td>
<td>Load1; LoadLoad; Load2</td>
<td>确保Load1数据的装载优先于Load2及其后续装载指令的装载</td>
</tr>
<tr>
<td>StoreStore Barriers</td>
<td>Store1; StoreStore; Store2</td>
<td>确保Store1数据对其他处理器可见（刷新到主内存）先于Store2及其后续存储指令的存储</td>
</tr>
<tr>
<td>LoadStore Barriers</td>
<td>Load1; LoadStore; Store2</td>
<td>确保Load1数据装载优先于Store2及其后所有的存储指令的存储</td>
</tr>
<tr>
<td>StoreLoad Barriers</td>
<td>Store1; StoreLoad; Load2</td>
<td>确保Store1数据对其他处理器变得可见（刷新到主内存）先于Load2及其后所有装载指令的装载。StoreLoad Barriers会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令</td>
</tr>
</tbody></table>
<p><code>NO</code>表示禁止指令重排。为了实现volatile内存语义时，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的<strong>处理器重排序</strong>。对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎是不可能的，为此，JMM采取了保守策略：</p>
<ul>
<li><p>在每个volatile写操作的<strong>前面</strong>插入一个StoreStore屏障；在每个volatile写操作的<strong>后面</strong>插入一个StoreLoad屏障；</p>
</li>
<li><p>在每个volatile读操作的<strong>后面</strong>插入一个LoadLoad屏障；在每个volatile读操作的<strong>后面</strong>插入一个LoadStore屏障。</p>
</li>
</ul>
<blockquote>
<p>需要注意的是：volatile写是在前面和后面<strong>分别插入内存屏障</strong>，而volatile读操作是在<strong>后面插入两个内存屏障</strong></p>
</blockquote>
<p><strong>StoreStore屏障</strong>：禁止上面的普通写和下面的volatile写重排序；</p>
<p><strong>StoreLoad屏障</strong>：防止上面的volatile写与下面可能有的volatile读&#x2F;写重排序</p>
<p><strong>LoadLoad屏障</strong>：禁止下面所有的普通读操作和上面的volatile读重排序</p>
<p><strong>LoadStore屏障</strong>：禁止下面所有的普通写操作和上面的volatile读重排序</p>
<p><img src="https://images.ysfun.cn/mac-img/volatile%E5%86%85%E5%AD%98%E5%B1%8F%E9%9A%9C.jpg"></p>
<blockquote>
<p><code>volatile</code> 经常用于两个两个场景：状态标记变量、Double Check 。</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>刷题分享：LeetCode134.加油站</title>
    <url>/2022/06/29/%E5%88%B7%E9%A2%98%E5%88%86%E4%BA%AB%EF%BC%9ALeetCode134-%E5%8A%A0%E6%B2%B9%E7%AB%99/</url>
    <content><![CDATA[<p><img src="https://images.ysfun.cn/mac-img/leetcode-logo.jpg"></p>
<p>题目对应<code>LeetCode</code><a href="https://leetcode.cn/problems/gas-station/">134. 加油站</a></p>
<span id="more"></span>

<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p>
<p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</p>
<p>给定两个整数数组 gas 和 cost ，如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1 。如果存在解，则 保证 它是 唯一 的。</p>
<h2 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h2><blockquote>
<p>示例 1:</p>
<p>输入: gas &#x3D; [1,2,3,4,5], cost &#x3D; [3,4,5,1,2]<br>输出: 3<br>解释:<br>从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 &#x3D; 0 + 4 &#x3D; 4 升汽油<br>开往 4 号加油站，此时油箱有 4 - 1 + 5 &#x3D; 8 升汽油<br>开往 0 号加油站，此时油箱有 8 - 2 + 1 &#x3D; 7 升汽油<br>开往 1 号加油站，此时油箱有 7 - 3 + 2 &#x3D; 6 升汽油<br>开往 2 号加油站，此时油箱有 6 - 4 + 3 &#x3D; 5 升汽油<br>开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。<br>因此，3 可为起始索引。</p>
</blockquote>
<blockquote>
<p>示例 2:</p>
<p>输入: gas &#x3D; [2,3,4], cost &#x3D; [3,4,3]<br>输出: -1<br>解释:<br>你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。<br>我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 &#x3D; 0 + 4 &#x3D; 4 升汽油<br>开往 0 号加油站，此时油箱有 4 - 3 + 2 &#x3D; 3 升汽油<br>开往 1 号加油站，此时油箱有 3 - 3 + 3 &#x3D; 3 升汽油<br>你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。<br>因此，无论怎样，你都不可能绕环路行驶一周。</p>
</blockquote>
<p>提示:</p>
<blockquote>
<p>gas.length &#x3D;&#x3D; n<br>cost.length &#x3D;&#x3D; n<br>1 &lt;&#x3D; n &lt;&#x3D; 105<br>0 &lt;&#x3D; gas[i], cost[i] &lt;&#x3D; 104</p>
</blockquote>
<h2 id="3-题解"><a href="#3-题解" class="headerlink" title="3. 题解"></a>3. 题解</h2><h3 id="3-1-解法一"><a href="#3-1-解法一" class="headerlink" title="3.1 解法一"></a>3.1 解法一</h3><p>假设从<code>x</code>号加油站出发，最近一个不能到达的加油站为<code>y</code>号（注意<code>x~y</code>之间的加油站都可以到达），则有：</p>
<p>$$\sum_{i&#x3D;x}^y{gas(i)} &lt; \sum_{i&#x3D;x}^y{cost(i)}$$</p>
<p>$$\sum_{i&#x3D;x}^j{gas(i)} \le \sum_{i&#x3D;x}^j{cost(i)} (j \in [x,y)$$</p>
<p>第一个公式说明从<code>x</code>号加油站出发无法到达<code>y</code>号加油站；第二个公式说明可以到达<code>y</code>之前的所有加油站。</p>
<p><strong>下面证明：<code>x</code>和<code>y</code>之间的任意加油站都无法到达<code>y</code>号加油站</strong></p>
<p>假设<code>z</code>号加油站介于<code>x</code>和<code>y</code>之间，</p>
<p>$$\sum_{i&#x3D;z}^y{gas(i)}&#x3D;\sum_{i&#x3D;x}^y{gas(i)}-\sum_{i&#x3D;x}^z{gas(i)}$$</p>
<p>$$&lt;\sum_{i&#x3D;x}^y{cost(i)}-\sum_{i&#x3D;x}^z{gas(i)} \le \sum_{i&#x3D;x}^y{cost(i)}-\sum_{i&#x3D;x}^z{cost(i)}$$</p>
<p>$$&#x3D;\sum_{i&#x3D;z}^y{cost(i)}$$</p>
<p>说明<code>z</code>无法到达<code>y</code>号加油站，得证！</p>
<p>基于以上结论，我们可以采用一次遍历，从<code>0</code>号加油站出发，判断能否环绕一周；如果不能，从第一个不能到达的加油站开始继续检查能否环绕一周；当遍历完一遍后仍没招到环绕一周的出发点，则返回<code>-1</code>。</p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> gas.length;</span><br><span class="line">  <span class="comment">// 遍历完一圈后，仍没找到符合条件的起点加油站，则返回-1</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">    <span class="comment">// 经过的加油站数</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">gasSum</span> <span class="operator">=</span> <span class="number">0</span>, costSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (count &lt; n) &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> (i + count) % n; </span><br><span class="line">      gasSum += gas[idx];</span><br><span class="line">      costSum += cost[idx];</span><br><span class="line">      <span class="keyword">if</span> (gasSum &lt; costSum) &#123;</span><br><span class="line">        <span class="comment">// 不能到达下一个加油站，跳出循环，并且重新从下一个加油站作为起点进行检查</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (count == n) &#123;</span><br><span class="line">      <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 从不能到达的加油站作为起点重新出发</span></span><br><span class="line">      i += count; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度<code>o(n)</code></li>
<li>空间复杂度<code>o(1)</code></li>
</ul>
<h3 id="3-2-解法二"><a href="#3-2-解法二" class="headerlink" title="3.2 解法二"></a>3.2 解法二</h3><p>使用图的思想</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">以下为例：</span><br><span class="line">gas  = [1,2,3,4,5]</span><br><span class="line">cost = [3,4,5,1,2]</span><br></pre></td></tr></table></figure>

<p>下图中，橙色柱状图表示每个加油站到下一个加油站的油耗量，蓝色为加油量，黑色折线<code>spare-1</code>表示从第一个加油站出发经过各个加油站时的<strong>净剩油量</strong>。要想完整的跑完一圈，必须经过各个加油站时的**净剩油量<code>spare&gt;=0</code>**，即黑色折线图最低点大于等于0即可。</p>
<p>很容易可以发现，改变出发点是不改变黑色折线的形状，只是会另其上下平移。不难发现，从黑色折线最低点的下一个加油站出发，会使整体向上移动最多的距离。</p>
<p><img src="https://images.ysfun.cn/mac-img/image-20220629192655728.png"></p>
<p>上图最低点为<code>3</code>号加油站，因此从<code>4</code>号加油站出发可以使折线向上移动最多距离，<code>spare-4</code>折线表示从<code>4</code>号加油站出发经过各个加油站时的<strong>净剩油量</strong>，可以发现此时各个加油站的<strong>净剩油量</strong>均大于零，因此可以环绕一周。</p>
<p><img src="https://images.ysfun.cn/mac-img/image-20220629193414871.png"></p>
<p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">spare</span> <span class="operator">=</span> <span class="number">0</span>, n = gas.length;</span><br><span class="line">  <span class="comment">// minSpare记录最低点的值，minIdx记录最低点的索引</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">minSpare</span> <span class="operator">=</span> Integer.MAX_VALUE, minIdx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">    spare += gas[i] - cost[i];</span><br><span class="line">    <span class="keyword">if</span> (spare &lt; minSpare) &#123;</span><br><span class="line">      minSpare = spare;</span><br><span class="line">      minIdx = i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 遍历完所有加油站后的净剩油量spare &lt; 0 则没有返回-1</span></span><br><span class="line">  <span class="comment">// 否则返回 minIdx + 1，注意对长度取余</span></span><br><span class="line">  <span class="keyword">return</span> spare &lt; <span class="number">0</span> ? -<span class="number">1</span> : (minIdx+<span class="number">1</span>)%n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>时间复杂度<code>o(n)</code></li>
<li>空间复杂度<code>o(1)</code></li>
</ul>
<p>运行结果：</p>
<p><img src="https://images.ysfun.cn/mac-img/image-20220629194254939.png"></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法题</tag>
      </tags>
  </entry>
  <entry>
    <title>七牛云图床&amp;Typora+PicGo图片上传</title>
    <url>/2022/06/29/Typora-PicGo%E5%9B%BE%E7%89%87%E4%B8%8A%E4%BC%A0-%E4%B8%83%E7%89%9B%E4%BA%91%E5%9B%BE%E5%BA%8A/</url>
    <content><![CDATA[<p><img src="https://images.ysfun.cn/mac-img/image-20220630153346076.png"></p>
<p>使用<code>Markdown</code>做记录很长一段时间了，一直都是使用<code>typora</code>来写文件的，对于<code>.md</code>文件中的图片都是采用<code>url</code>链接进行路由访问的。之前都是在<code>typora</code>中设置在导入图片时创建一个文件同名的文件夹来保存图片，然后利用相对路径路由到图片。采用这种方式有个致命的缺点就是一旦需要将这个<code>.md</code>文件分享或者上传，都必须把这个图片文件夹一并上床，这就很麻烦。因此开始有了尝试用图床保存图片的想法。</p>
<span id="more"></span>

<h2 id="1-七牛云图床"><a href="#1-七牛云图床" class="headerlink" title="1. 七牛云图床"></a>1. 七牛云图床</h2><h3 id="1-1-七牛云配置对象存储"><a href="#1-1-七牛云配置对象存储" class="headerlink" title="1.1  七牛云配置对象存储"></a>1.1  七牛云配置对象存储</h3><ol>
<li>注册七牛云账号并实名认证</li>
</ol>
<p>进入<a href="https://portal.qiniu.com/">七牛云首页</a>注册账号，并实名认证，完成实名认证后会赠送10GB的免费存储空间。</p>
<ol start="2">
<li>进入「对象存储」，点击左侧「空间管理」-&gt;「新建空间」</li>
</ol>
<img src="https://images.ysfun.cn/mac-img/image-20220629224608546.png" style="zoom:50%;" />

<p>七牛云的存储对象地区对应表(PicGo配置地区存储区域会用到)：<a id="t1"></p>
<table>
<thead>
<tr>
<th>存储区域</th>
<th>地域简称</th>
<th>上传域名</th>
</tr>
</thead>
<tbody><tr>
<td>华东</td>
<td>z0</td>
<td>服务器端：http(s):&#x2F;&#x2F;up.qiniup.com 客户端： http(s):&#x2F;&#x2F;upload.qiniup.com</td>
</tr>
<tr>
<td>华北</td>
<td>z1</td>
<td>服务器端：http(s):&#x2F;&#x2F;up-z1.qiniup.com 客户端：http(s):&#x2F;&#x2F;upload-z1.qiniup.com</td>
</tr>
<tr>
<td>华南</td>
<td>z2</td>
<td>服务器端：http(s):&#x2F;&#x2F;up-z2.qiniup.com 客户端：http(s):&#x2F;&#x2F;upload-z2.qiniup.com</td>
</tr>
<tr>
<td>北美</td>
<td>na0</td>
<td>服务器端：http(s):&#x2F;&#x2F;up-na0.qiniup.com 客户端：http(s):&#x2F;&#x2F;upload-na0.qiniup.com</td>
</tr>
<tr>
<td>东南亚</td>
<td>as0</td>
<td>服务器端：http(s):&#x2F;&#x2F;up-as0.qiniup.com 客户端：http(s):&#x2F;&#x2F;upload-as0.qiniup.com</td>
</tr>
</tbody></table>
<ol start="3">
<li>配置自定义域名</li>
</ol>
<p>这里我用的是子域名，在域名前面加了<code>images</code>前缀，解析<code>cname</code>即可。</p>
<h2 id="2-Typora-PicGo安装-amp-配置"><a href="#2-Typora-PicGo安装-amp-配置" class="headerlink" title="2. Typora+PicGo安装&amp;配置"></a>2. Typora+PicGo安装&amp;配置</h2><ol>
<li>去<a href="https://typoraio.cn/">Typora中文官网</a>下载并安装最新版Typora</li>
</ol>
<blockquote>
<p>最新版Typora开始不免费提供了，并且使用老版本会提示强制更新，有能力者推荐支持正版Typora。</p>
<p>这里提供一个Mac最新破解版Typora：<a href="https://www.macwk.com/soft/typora">macwk-typora</a>		</p>
</blockquote>
<ol start="2">
<li>前往<a href="https://github.com/Molunerfinn/PicGo/releases/">PicGo-releases</a>下载安装PicGo，建议下载非beta版</li>
</ol>
<p><img src="https://images.ysfun.cn/mac-img/image-20220630150012999.png"></p>
<ol start="3">
<li>配置PicGo</li>
</ol>
<p>安装完成后，Mac版上方会有以下应用图标显示，右键打开详细窗口 -&gt; 图床设置 -&gt; 七牛云图床</p>
<p><img src="https://images.ysfun.cn/mac-img/image-20220630150107030.png"></p>
<p>参考以下配置：</p>
<img src="https://images.ysfun.cn/mac-img/image-20220630151259192.png" style="zoom:50%;" />

<p><code> AccessKey, SecretKey</code>在七牛云 -&gt; 个人中心 -&gt; 秘钥管理中的<code>AK和SK</code></p>
<p>存储空间名即为刚刚创建的存储空间名，访问地址<code>http:</code>或<code>https:</code>加上域名，注意使用<code>https</code>需要在七牛云额外支付CDN流量；存储区域见<a href="#t1">存储对象地区对应表</a>；存储路径可自行设置。</p>
<ol start="4">
<li>Typora设置</li>
</ol>
<p>打开Typora偏好设置 -&gt; 图像</p>
<img src="https://images.ysfun.cn/mac-img/image-20220630152220581.png" style="zoom:50%;" />

<p>点击<code>验证图片上传选项</code>出现以下结果则表示配置成功</p>
<img src="https://images.ysfun.cn/mac-img/image-20220630152320399.png" style="zoom:50%;" />

<ol start="5">
<li>登录七牛云查看图片文件</li>
</ol>
<p>上面一步操作就全部完成了，要想查看图片存放位置可以进入七牛云空间管理 -&gt; 进入空间 -&gt; 文件管理，即可查看图床上的所有图片。</p>
]]></content>
  </entry>
  <entry>
    <title>刷题分享：LeetCode648.单词替换【字典树】</title>
    <url>/2022/07/07/%E5%88%B7%E9%A2%98%E5%88%86%E4%BA%AB%EF%BC%9ALeetCode648-%E5%8D%95%E8%AF%8D%E6%9B%BF%E6%8D%A2%E3%80%90%E5%AD%97%E5%85%B8%E6%A0%91%E3%80%91/</url>
    <content><![CDATA[<p><img src="https://images.ysfun.cn/mac-img/leetcode-logo.jpg"></p>
<p>题目对应<code>LeetCode</code><a href="https://leetcode.cn/problems/replace-words/">648. 单词替换</a></p>
<span id="more"></span>

<h2 id="1-题目描述"><a href="#1-题目描述" class="headerlink" title="1. 题目描述"></a>1. 题目描述</h2><p>在英语中，我们有一个叫做 词根(root) 的概念，可以词根后面添加其他一些词组成另一个较长的单词——我们称这个词为 继承词(successor)。例如，词根an，跟随着单词 other(其他)，可以形成新的单词 another(另一个)。</p>
<p>现在，给定一个由许多词根组成的词典 dictionary 和一个用空格分隔单词形成的句子 sentence。你需要将句子中的所有继承词用词根替换掉。如果继承词有许多可以形成它的词根，则用最短的词根替换它。</p>
<p>你需要输出替换之后的句子。</p>
<p><strong>示例：</strong></p>
<blockquote>
<p>示例 1：</p>
<p>输入：dictionary &#x3D; [“cat”,”bat”,”rat”], sentence &#x3D; “the cattle was rattled by the battery”<br>输出：”the cat was rat by the bat”</p>
</blockquote>
<blockquote>
<p>示例 2：</p>
<p>输入：dictionary &#x3D; [“a”,”b”,”c”], sentence &#x3D; “aadsfasf absbs bbab cadsfafs”<br>输出：”a a b c”</p>
</blockquote>
<h2 id="2-题解"><a href="#2-题解" class="headerlink" title="2. 题解"></a>2. 题解</h2><h3 id="2-1-字典树介绍"><a href="#2-1-字典树介绍" class="headerlink" title="2.1 字典树介绍"></a>2.1 字典树介绍</h3><p>这是一道「字典树」的模板题，下面介绍字典树：</p>
<p>「字典树」数据结构一般用于判断是否具有相同前缀，因此非常适合用来解决当前题。</p>
<p>字典树结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">  <span class="type">boolean</span> isEnd;</span><br><span class="line">  Trie[] children;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">    children = <span class="keyword">new</span> <span class="title class_">Trie</span>[len];  <span class="comment">// len取决于字典树包含字符种类数（例如，对于只包含小写字母的字典树len=26）</span></span><br><span class="line">    isEnd = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其一般包含两个属性：</p>
<ul>
<li><code>isEnd</code>：标识当前字典树节点是否对应单词的最后字符</li>
<li><code>children</code>：子节点数组，数组长度取决于字符种类数，一般情况，对于只包含小写字母的字典树，子数组长度一般为26</li>
</ul>
<p><img src="https://images.ysfun.cn/mac-img/%E5%AD%97%E5%85%B8%E6%A0%91%E6%A8%A1%E5%9E%8B-1.jpg"></p>
<h3 id="2-2-字典树解法"><a href="#2-2-字典树解法" class="headerlink" title="2.2 字典树解法"></a>2.2 字典树解法</h3><p>字典树算法主要包括两个步骤：</p>
<ul>
<li>建树</li>
<li>搜索</li>
</ul>
<ol>
<li><strong>建树</strong></li>
</ol>
<p>建立一颗包含所有词根的字典树，代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">  <span class="comment">// 建树</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(Trie root, String str)</span> &#123;</span><br><span class="line">    		<span class="comment">// 字典树根节点root</span></span><br><span class="line">        <span class="type">Trie</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;str.length(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> str.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (cur.children[idx] == <span class="literal">null</span>) &#123;</span><br><span class="line">                cur.children[idx] = <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.children[idx];</span><br><span class="line">        &#125;</span><br><span class="line">        cur.isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    Trie[] children;</span><br><span class="line">    <span class="type">boolean</span> isEnd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        children = <span class="keyword">new</span> <span class="title class_">Trie</span>[<span class="number">26</span>];</span><br><span class="line">        isEnd = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下图展示了词根数组<code>[abc, cb]</code>建树过程：</p>
<p><img src="https://images.ysfun.cn/mac-img/%E5%AD%97%E5%85%B8%E6%A0%91%E5%BB%BA%E6%A0%91.jpg"></p>
<ol start="2">
<li><strong>搜索</strong></li>
</ol>
<p>找出一个单词的最短词根，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">check</span><span class="params">(String s, Trie root)</span> &#123;</span><br><span class="line">  <span class="type">Trie</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> s.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (cur.children[idx] == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 当前字符在字典树中搜索不到，说明词根数组中没有与当前字符串匹配的词根</span></span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    cur = cur.children[idx];</span><br><span class="line">    <span class="keyword">if</span> (cur.isEnd) &#123;</span><br><span class="line">      <span class="comment">// 搜索到词根的结尾，返回当前词根，当前词根为最短词根</span></span><br><span class="line">      <span class="keyword">return</span> s.substring(<span class="number">0</span>, i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-代码"><a href="#2-3-代码" class="headerlink" title="2.3 代码"></a>2.3 代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceWords</span><span class="params">(List&lt;String&gt; dictionary, String sentence)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">        <span class="keyword">for</span> (String str : dictionary) &#123;</span><br><span class="line">            build(root, str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        String[] arr = sentence.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;arr.length; i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> check(arr[i], root);</span><br><span class="line">            builder.append(str);</span><br><span class="line">            <span class="keyword">if</span> (i != arr.length - <span class="number">1</span>) &#123;</span><br><span class="line">                builder.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> builder.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">check</span><span class="params">(String s, Trie root)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> s.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (cur.children[idx] == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> s;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.children[idx];</span><br><span class="line">            <span class="keyword">if</span> (cur.isEnd) &#123;</span><br><span class="line">                <span class="keyword">return</span> s.substring(<span class="number">0</span>, i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(Trie root, String str)</span> &#123;</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;str.length(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">idx</span> <span class="operator">=</span> str.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (cur.children[idx] == <span class="literal">null</span>) &#123;</span><br><span class="line">                cur.children[idx] = <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.children[idx];</span><br><span class="line">        &#125;</span><br><span class="line">        cur.isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line">    Trie[] children;</span><br><span class="line">    <span class="type">boolean</span> isEnd;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        children = <span class="keyword">new</span> <span class="title class_">Trie</span>[<span class="number">26</span>];</span><br><span class="line">        isEnd = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：<code>O(d + s)</code>。其中 d 为dictionary的字符数，s 是sentence的字符数。构建字典树时间复杂度为<code>O(d)</code>，每个单词搜索前缀均为线性时间复杂度。</li>
<li>空间复杂度：<code>O(d)</code>，搜索树的复杂度，即为dictionary的字符数。</li>
</ul>
<p>运行结果：</p>
<img src="https://images.ysfun.cn/mac-img/image-20220707194552157.png" style="zoom:70%;"/>

]]></content>
  </entry>
  <entry>
    <title>计算机网络模型概述【OSI七层模型&amp;常见协议】</title>
    <url>/2022/07/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0%E3%80%90OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B-TCP-IP%E5%8D%8F%E8%AE%AE%E7%B0%87%E3%80%91/</url>
    <content><![CDATA[<p><img src="https://images.ysfun.cn/mac-img/163d9775a0270f99~tplv-t2oaga2asx-zoom-crop-mark:3024:3024:3024:1702.awebp"></p>
<p>对于同一台设备上的进程通信，有很多种方式，比如管道、消息队列、共享内存、信号等方式，而对于不同设备上的进程通信，就需要网络通信，而设备是多样的，所以要兼容多种多样的设备，就需要协商出一套通用的<strong>网路协议</strong>。</p>
<span id="more"></span>

<p>要完成网络间的通信是比较复杂的，为了确保功能很好地实现，会对所有的<strong>网络协议</strong>进行分层，本文针对<strong>OSI七层参考模型</strong>展开讨论。</p>
<h2 id="1-OSI七层参考模型"><a href="#1-OSI七层参考模型" class="headerlink" title="1. OSI七层参考模型"></a>1. OSI七层参考模型</h2><p>OSI（Open System Interconnection）七层网络模型是由国际标准化组织ISO提出的一个网络系统互连模型，是网络通信在逻辑上的定义，也可以理解为定义了通用的网络通信规范。数据在网络中传输的过程，实际上是通过下图的封装和解封装的过程，对数据进行一层层的封装，发送方把数据转换成比特流的形式在网络媒介中进行传输，接收方将比特流进行解封装处理，还原数据。</p>
<p><img src="https://images.ysfun.cn/mac-img/1061765-20161125200042800-2141541665.png"></p>
<p>在<strong>OSI七层参考模型</strong>的基础上，还派生出了<strong>五层模型</strong>和<strong>TCP&#x2F;IP四层模型</strong>，这三种分层方式的区别如下：</p>
<p><img src="https://images.ysfun.cn/mac-img/%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B.jpg"></p>
<blockquote>
<p>为什么要对网络进行分层？</p>
<p>与软件架构设计相似，要使系统具备高内聚、低耦合、可复用、可扩展等特性。如果没有对网络进行分层，当一个业务或协议需要进行修改时，就可能需要对整个系统进行修改。而对网路进行分层后，就可以很方便地把具有不同功能的模块分离开来，某个模块出现问题只需要修改对应模块即可，其他层还可以继续复用，只要确保各层满足相应的协议即可。</p>
</blockquote>
<p>OSI七层模型中各层功能概览：</p>
<img src="https://images.ysfun.cn/mac-img/image-20220719171558617.png" style="zoom: 50%;" />

<p>下面分别对OSI七层模型中的各层功能展开介绍。</p>
<h3 id="1-物理层"><a href="#1-物理层" class="headerlink" title="1. 物理层"></a>1. 物理层</h3><p>要进行网络通信，首先要解决的问题就是如何在两台主机设备上进行数据（有线&#x2F;无线）传输，否则通信无从谈起。物理层的作用是<strong>在主机之间搭建一条物理链路传输二进制流，为设备之间的数据通信提供传输媒介和互连设备</strong>。</p>
<blockquote>
<p><strong>典型的物理层标准和设备：</strong></p>
<p>物理层介质：双绞线、同轴电缆、光纤、无线电信号等。</p>
<p>局域网物理层：</p>
<blockquote>
<p>常见标准：10Base-T、100Base-TX&#x2F;FX、1000Base-T、1000Base-SX&#x2F;LX</p>
<p>常见设备：中继器、集线器</p>
</blockquote>
<p>广域网物理层：</p>
<blockquote>
<p>常见标准：RS-232、V.24、V.35</p>
<p>常见设备：Modem</p>
</blockquote>
</blockquote>
<p>物理层规定了如何为网络通信实现最底层的物理连接，以及物理设备的机械、电气、功能和过程特性。需要注意的是，网络通信过程中所用的物理媒介（网线、电缆等）并不属于物理层，因为物理层实际上是一种规定，规定这些物理媒介设备在连接网络时的各种参数、规格以及工作方式。但是同时，双绞线、电缆等物理媒介又是物理层的实现。</p>
<h3 id="2-数据链路层"><a href="#2-数据链路层" class="headerlink" title="2. 数据链路层"></a>2. 数据链路层</h3><p>物理链路连通后的主机之间具备数据传输的基本能力，但物理层是无协议的，传输的是二进制流。而二进制流没有起始和终止标识符，接收主机无法判断何时开始或终止数据的解析；于是<strong>在数据链路层对二进制流进行封装成帧（frame）</strong>，这样主机在接收二进制流时就知道什么时候开始、什么时候结束了。</p>
<p><strong>数据链路层协议有SLIP协议、CSLIP协议、PPP协议等</strong>。交换机对帧解码并根据帧中包含的信息把数据发送到正确的接收方，所以交换机是工作在数据链路层的。</p>
<p>每个<strong>帧</strong>由包头（head）和数据（data）两部分组成：</p>
<p><img src="https://images.ysfun.cn/mac-img/%E5%B8%A7.jpg"></p>
<p>其中head包含数据的说明信息，包括<strong>发送者、接收者、数据类型</strong>；</p>
<ul>
<li>发送者&#x2F;源地址：6字节</li>
<li>接收者&#x2F;目标地址：6字节</li>
<li>数据类型：6字节</li>
</ul>
<p>Data部分的长度，最长为1500字节，最短为46字节。因此，整个<strong>帧</strong>最短字节为64字节，最长为1518字节。如果数据过大，则需要分割成多个帧进行传输。</p>
<p>有了数据包的定义，那么计算机是如何标识谁是谁的？如何知道对方的地址的？这就设计到MAC地址和广播。</p>
<h4 id="2-1-MAC地址"><a href="#2-1-MAC地址" class="headerlink" title="2.1 MAC地址"></a>2.1 MAC地址</h4><p>以太网规定，连入网络的所有设备都必须具备网卡。数据包的发送地址和接收地址指的就是网卡地址，也就是MAC地址。</p>
<p><strong>MAC地址作为网络中计算机设备的唯一标识，从计算机在厂商中生产出来就被十六进制的数标识为MAC地址，MAC地址理论上是独一无二的。</strong>这也是为什么很多软件设备校验设备唯一性时，会用到MAC地址。</p>
<p>MAC地址长度为48位二进制，<strong>通常由12位十六进制树表示，前六位是厂商编号，后六位是流水号。</strong></p>
<img src="https://images.ysfun.cn/mac-img/image-20220718163630824.png" style="zoom: 33%;" />

<blockquote>
<p>查看MAC地址命令：</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure>

<p><img src="https://images.ysfun.cn/mac-img/image-20220718164132232.png"></p>
<p>有了MAC地址，那么两台机器之间是怎么找到对方进行通信的呢？</p>
<h4 id="2-2-广播"><a href="#2-2-广播" class="headerlink" title="2.2 广播"></a>2.2 广播</h4><p>在包含四个主机的一个子网中，主机1要向主机4发送一个数据包，数据包中包含接收方的MAC地址。计算机1会向子网中所有计算机都发送数据包（广播的方式），这时子网中的每台计算机（包括主机2和主机3）都会收到这个数据包，然后每台计算机都会把数据包中接收方的MAC地址取出来，与自身的MAC地址进行对比，如果二者相同则接收这个数据包，否则丢弃这个数据包。</p>
<img src="https://images.ysfun.cn/mac-img/image-20220718165514353.png" style="zoom:50%;" />

<h3 id="3-网络层"><a href="#3-网络层" class="headerlink" title="3. 网络层"></a>3. <strong>网络层</strong></h3><p>前面介绍了，通过广播机制可以实现在同一个子网内两台主机之间的寻址、通信；我们所处的网络由无数个子网构成，如果现实中的网络通信都通过广播这种原始的方式来实现，那么一台主机发送的数据包将会被全世界所有的主机收到，那将导致整个网络崩溃。为此，解决办法是<strong>如果在同一个子网内，就采用广播的方式发送数据包；如果不在同一个子网内，那就通过网关和路由向不同「广播域」&#x2F;「子网」分发数据包。</strong>那就有了网络层，提供网络路由寻址功能。</p>
<p><strong>网络层的作用是规定了通过哪些节点、什么样的网络路径来将数据（数据包）从发送方发送到接收方，向传输层提供最基本的主机到主机的数据传送服务。</strong>在网络层中，确定了从节点A发送数据到节点B的网络路径，经过哪些网络节点。网络层既可以建立LAN通信系统，更主要的是可以在WAN网络系统中建立通信，这是因为它有自己的路由地址结构，通过路由协议（或者可路由协议）进行网络通信的路由工作。网络层的协议包括：IP、ICMP和IGMP等协议。</p>
<blockquote>
<p>可路由协议（routed protocol）：定义数据包内各个字段的格式和用途，对数据进行网络层封装；</p>
<p>路由协议（routing protocol）：在路由器之间传递信息，计算路由并形成路由表，为可路由协议选择路径；</p>
</blockquote>
<p>网络层引入了一套新的协议来区分不同的广播域&#x2F;子网，于是就有了IP协议。</p>
<h4 id="3-1-IP协议"><a href="#3-1-IP协议" class="headerlink" title="3.1 IP协议"></a>3.1 IP协议</h4><p><strong>IP协议即互联网协议（Internet Protocol）</strong>。相对于上面提到的MAC地址，<strong>IP地址可以理解为逻辑地址，而MAC地址为物理地址；IP地址是动态分配的、不固定的，MAC地址是固定的。</strong>目前广泛采用的IPv4地址，同时IPv6地址正不断发展壮大。</p>
<p>IP发送的数据叫IP数据包，其也包含包头和数据两个部分：</p>
<ul>
<li>包头：版本，长度，IP地址等信息</li>
<li>数据：IP数据包的具体数据</li>
</ul>
<p>IP数据包的包头长度为20~60字节，整个数据包的最大长度为65535字节。</p>
<p>IP数据包的”包头”部分的长度为20到60字节，整个数据包的总长度最大为65535字节。</p>
<p><strong>IPv4地址是由32位的二进制数组成，一般把它分成4段的十进制表示</strong>，地址范围为0.0.0.0~255.255.255.255。</p>
<p>IP地址分成两部分：<strong>网络部分（标识子网）和主机部分（标识主机）</strong>。网络部分和主机部分所占用的二进制位数是不固定的。</p>
<p>IP地址段只是标识了IP地址的种类，从网络部分或主机部分都无法辨识一个IP所处的子网。如果两个IP的网络部分相同，则说明它们处于同一个子网中。例如192.168.33.1和192.168.33.2，如果它们的网络部分为24位，主机部分为8位，网络部分都为 192.168.33，处于同一个子网中。但如果像192.16.10.1与192.16.10.2，并不知道网络部分和主机部分各几位，就不能确定是否处于同一子网。于是就有了子网掩码。</p>
<h4 id="3-2-子网掩码"><a href="#3-2-子网掩码" class="headerlink" title="3.2 子网掩码"></a>3.2 子网掩码</h4><p>子网掩码是用来标识同一局域网中的IP地址信息的，它由32位二进制组成，前一部分都是1，后一部分都是0，例如：<code>11111111.11111111.11111111.00000000</code>，该子网掩码一共有24个1，也可以表示为<code>/24</code>。子网掩码的网络部分全部为1，主机部分全部为0。</p>
<p>比如IP地址为<code>192.16.10.1/24</code>，其中<code>/24</code>表示子网掩码有24个1，且子网掩码中的1均在前面，故该子网掩码为<code>11111111.11111111.11111111.00000000</code>，写成十进制为<code>255.255.255.0</code>；那么该IP地址的网络号为<code>192.16.10</code>，主机号为<code>1</code>。</p>
<h4 id="3-3-ARP协议"><a href="#3-3-ARP协议" class="headerlink" title="3.3 ARP协议"></a>3.3 ARP协议</h4><blockquote>
<p>需要注意的是，在OSI参考模型的分层划分中，ARP协议是位于数据链路层的，而对于TCP&#x2F;IP协议分层方式中ARP协议位于网络层层，此处为保证内容的连贯性，将ARP协议放在此处介绍。</p>
</blockquote>
<p>有了IP协议，就可以判断计算机属于哪个子网了；但在数据链路层是通过MAC地址进行通信的，现在只有目标IP地址，那么如何获取目标MAC地址呢？这就需要用到ARP协议。</p>
<p>ARP 协议是 <code>地址解析协议</code>，即 <code>Address Resolution Protocol</code>，它能够根据 IP 地址获取物理地址（MAC地址）。主机发送信息时会将包含目标 IP 的 ARP 请求广播到局域网络上的所有主机，并接受返回消息，以此来确定物理地址。收到消息后的物理地址和 IP 地址会在 ARP 中缓存一段时间，下次查询的时候直接从 ARP 中查询即可。</p>
<h4 id="3-4-ICMP协议"><a href="#3-4-ICMP协议" class="headerlink" title="3.4 ICMP协议"></a>3.4 ICMP协议</h4><p>我们知道IP协议并不能提供可靠传输，即如果发生丢包，IP协议并不能通知传输层是否丢包及丢包的原因，于是就有了ICMP协议。</p>
<p>ICMP协议（<code>Internet Control Message Protocol</code>）主要用于在IP主机和路由器之间传递控制消息。当遇到IP无法访问目标或IP路由器无法按照当前速率转发数据包时，会自动发送ICMP消息，从这个角度看，ICMP协议可以看做是<strong>错误侦测和回报机制</strong>，帮助我们检查网络状况、确保连线的准确性。</p>
<p>ICMP协议的主要功能：</p>
<ul>
<li>确认IP包是否成功抵达目标地址</li>
<li>通知在发送过程中IP包被丢失的原因</li>
</ul>
<blockquote>
<p>需要注意的是:</p>
<ol>
<li>ICMP是基于IP协议工作的，但是它并不是传输层的功能，因此仍然把它归结为网络层协议；</li>
<li>ICMP只能搭配IPv4使用，如果是IPv6的情况下, 需要是用ICMPv6。</li>
</ol>
<p>我们平时使用的<code>ping</code>命令其实就是使用到了ICMP协议。</p>
</blockquote>
<h3 id="4-传输层"><a href="#4-传输层" class="headerlink" title="4. 传输层"></a>4. 传输层</h3><p>经过数据链路层和网络层的支持，我们已经可以正常进行两台计算机之间的通信了，但是计算机上会同时运行多个程序，比如同时开着QQ和WX，那怎么区分消息是QQ还是WX的呢？这就需要依靠传输层来实现。</p>
<p>通常我们的计算机上运行的不同程序都会分配不同的<strong>端口</strong>，而<strong>传输层的功能就是建立端口到端口的通信，是数据能够传送到不同的应用程序。</strong>端口是每个使用网卡程序的编号，每个端口号标识一个可执行程序；端口号是0<del>65535之间的一个整数，正好是16个二进制位，0</del>1023为系统占用端口，其他应用程序只能占用端口号大于1023的端口。</p>
<p>至此，通过IP+端口号的方式就可以唯一确定互联网中的一个应用程序，进而实现网络间的通信。</p>
<p>传输层主要包含两大协议：</p>
<ul>
<li>TCP协议</li>
<li>UDP协议</li>
</ul>
<h4 id="4-1-UDP协议"><a href="#4-1-UDP协议" class="headerlink" title="4.1 UDP协议"></a>4.1 UDP协议</h4><p>UDP协议（User Datagram Protocol，用户数据报协议）就是在数据前面加上端口号。<strong>包头</strong>部分定义了发送方端口号和接收方端口号，共8个字节；<strong>数据</strong>部分就是具体内容，总长度不超过65535个字节，正好可以放进一个IP数据包中。</p>
<p>UDP协议提供一种不可靠的数据交付，即UDP协议不保证数据是否到达目标节点；UDP协议是一种无连接的协议，传输之前源端和终端是不需要建立连接的，不对数据报进行检查与修改，无需等待对方应答。</p>
<ul>
<li>缺点：不保证数据传输的可靠性，会出现分组丢失、重复、乱序等现象</li>
<li>优点：实现简单，具有较好的实时性，传输效率高</li>
</ul>
<h4 id="4-2-TCP协议"><a href="#4-2-TCP协议" class="headerlink" title="4.2 TCP协议"></a>4.2 TCP协议</h4><p><strong>TCP协议（Transmission Control Protocol，传输控制协议）是一种面向连接的、可靠的、基于字节流的传输协议，TCP协议通过序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠传输，同时还具备流量控制、拥塞控制等特点。</strong></p>
<ul>
<li>缺点：实现复杂，消耗更多资源</li>
<li>优点：保证数据可靠传输，具备拥塞控制功能</li>
</ul>
<p>TCP数据包没有长度限制，理论上是可以无限大的，但是为了保证网络传输的效率，通常TCP数据包的长度不会超过IP数据包的长度，即一般不超过65536字节。TCP协议是非常复杂的，本文不展开介绍。</p>
<h3 id="5-会话层"><a href="#5-会话层" class="headerlink" title="5. 会话层"></a>5. 会话层</h3><p>会话层建立在传输层之上，<strong>利用传输层提供的服务建立和维持会话，负责在网络中的两个节点之间建立、维持和终止通信。</strong>会话层利用检验点可使通信会话在通信失效时从检验点继续恢复通信，即对信息的交互实现控制，这种能力对于大文件的传输极为重要。</p>
<h3 id="6-表示层"><a href="#6-表示层" class="headerlink" title="6. 表示层"></a>6. 表示层</h3><p>表示层向上对应用进程服务，向下接收会话层提供的服务，其主要作用<strong>将设备固有数据格式转换为网络标准传输格式</strong>。除此之外，表示层还可以对数据进行加密和解密。</p>
<h3 id="7-应用层"><a href="#7-应用层" class="headerlink" title="7. 应用层"></a>7. 应用层</h3><p>应用层是 OSI 标准模型的最顶层，是直接为应用进程提供服务的。其作用是<strong>在实现多个系统应用进程相互通信的同时，完成一系列业务处理所需的服务</strong>，包括文件传输、电子邮件、远程登录、远程端口调用等。应用层协议包括<code>http</code>、<code>ftp</code>、<code>smtp</code>、<code>DNS</code>等协议。</p>
<h4 id="7-1-DNS协议"><a href="#7-1-DNS协议" class="headerlink" title="7.1 DNS协议"></a>7.1 DNS协议</h4><p>DNS协议（Domain Name System，域名系统协议）是一个将域名和IP相互映射的分布式数据库系统，DNS缓存能够加快网络资源的访问。</p>
<blockquote>
<p>DNS 不仅适用于 IPv4，还适用于 IPv6。</p>
</blockquote>
]]></content>
  </entry>
  <entry>
    <title>源码剖析：ThreadLocal</title>
    <url>/2022/07/26/%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%EF%BC%9AThreadLocal/</url>
    <content><![CDATA[<p><img src="https://images.ysfun.cn/mac-img/image-20220726223855837.png"></p>
<p><code>ThreadLocal</code>用来提供线程级别变量，变量只对当前线程可见。相比于<strong>使用锁控制共享变量访问顺序</strong>的解决方案，<code>ThreadLocal</code>通过<strong>空间换时间</strong>的策略，每个线程都有属于自己的线程私有变量，很好地规避了线程竞争的问题。</p>
<span id="more"></span>

<p>首先回答两个问题：</p>
<ol>
<li>什么是<code>ThreadLocal</code>？</li>
</ol>
<p><code>ThreadLocal</code>顾名思义可以理解为线程本地变量。也就是说如果定义了一个<code>ThreadLocal</code>，每个线程对这个<code>ThreadLocal</code>中数据的读写是线程隔离的，互相不影响的，它提供了一种将可变数据通过每个线程持有一份私有的独立副本从而实现线程隔离的机制。</p>
<ol start="2">
<li><code>ThreadLocal</code>的大致实现思路？</li>
</ol>
<p><code>Thread</code>类中有一个<code>ThreadLocal.ThreadLocalMap</code>类型的属性<code>threadLocals</code>，也就是说每个线程拥有一个自己的<code>ThreadLocalMap</code>。<code>ThreadLocalMap</code>是一种针对<code>ThreadLocal</code>定制化的<code>HashMap</code>，它的<code>Key</code>为<code>ThreadLocal</code>对象（实际是<code>ThreadLocal</code>的弱引用），<code>Value</code>为储存的线程私有数据。每个线程往<code>ThreadLocal</code>中添加值时，都会向线程专属的<code>ThreadLocalMap</code>里存，读数据也是以某个<code>ThreadLocal</code>作为引用，在自己的<code>Map</code>中寻找对应的<code>Key</code>，从而实现线程隔离。</p>
<p>下面从源码出发进行分析。</p>
<h2 id="1-源码剖析"><a href="#1-源码剖析" class="headerlink" title="1. 源码剖析"></a>1. 源码剖析</h2><h3 id="1-1-Thread类"><a href="#1-1-Thread类" class="headerlink" title="1.1 Thread类"></a>1.1 Thread类</h3><img src="https://images.ysfun.cn/mac-img/image-20220726155918812.png" style="zoom: 67%;" />

<p><code>Thread</code>类中包含<code>threadLocals</code>和<code>inheritableThreadLocals</code>两个属性，它们都是<code>ThreadLocal.ThreadLocalMap</code>类型。可以发现这两个属性默认初始化为<code>null</code>，只有当调用<code>ThreadLocal</code>的<code>set</code>或<code>get</code>方法时才会创建实例对象。</p>
<h3 id="1-2-ThreadLocalMap类"><a href="#1-2-ThreadLocalMap类" class="headerlink" title="1.2 ThreadLocalMap类"></a>1.2 ThreadLocalMap类</h3><p><code>ThreadLocalMap</code>是<code>ThreadLocal</code>的内部类，是定制化的<code>HashMap</code>，其也是使用<code>Entry</code>封装<code>K-V</code>存储数据的，不同的是<code>ThreadLocalMap</code>的<code>Entry</code>的<code>Key</code>只能是<code>ThreadLocal</code>类型，并且是一个「弱引用」（<a href="https://www.ysfun.cn/archives/jvmgc-la-ji-hui-shou#1.3-java%E4%B8%AD%E7%9A%84%E5%BC%95%E7%94%A8">Java中的引用</a>介绍过Java中的四种引用）。</p>
<img src="https://images.ysfun.cn/mac-img/image-20220726163635798.png" style="zoom:67%;" />

<blockquote>
<p>为什么<code>ThreadLocalMap</code>的<code>Key</code>要采用「弱引用」？</p>
</blockquote>
<h3 id="1-3-ThreadLocal类"><a href="#1-3-ThreadLocal类" class="headerlink" title="1.3 ThreadLocal类"></a>1.3 ThreadLocal类</h3><p>方法：</p>
<p><img src="https://images.ysfun.cn/mac-img/image-20220726185554654.png"></p>
<p>常用API有<code>get()</code>、<code>set(T)</code>、<code>remove()</code>。</p>
<h4 id="set"><a href="#set" class="headerlink" title="set"></a>set</h4><p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(T value)</span> &#123;</span><br><span class="line">  <span class="comment">// 获取当前线程</span></span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">  <span class="comment">// 拿到当前线程的ThreadLocalMap</span></span><br><span class="line">  <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">  <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">    <span class="comment">// Key 为当前ThreadLocal对象</span></span><br><span class="line">    map.set(<span class="built_in">this</span>, value);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    createMap(t, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadLocalMap <span class="title function_">getMap</span><span class="params">(Thread t)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">createMap</span><span class="params">(Thread t, T firstValue)</span> &#123;</span><br><span class="line">  t.threadLocals = <span class="keyword">new</span> <span class="title class_">ThreadLocalMap</span>(<span class="built_in">this</span>, firstValue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以发现，<code>ThreadLocal</code>中的<code>set(v)</code>方法实际上调用了<code>ThreadLocalMap</code>中的<code>set(this, v)</code>方法，<code>Entry</code>的<code>Key</code>为当前<code>ThreadLocal</code>对象。</p>
<h4 id="get"><a href="#get" class="headerlink" title="get"></a>get</h4><p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> T <span class="title function_">get</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 获取当前线程</span></span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">  <span class="comment">// 拿到当前线程的ThreadLocalMap</span></span><br><span class="line">  <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">  <span class="keyword">if</span> (map != <span class="literal">null</span>) &#123;</span><br><span class="line">    ThreadLocalMap.<span class="type">Entry</span> <span class="variable">e</span> <span class="operator">=</span> map.getEntry(<span class="built_in">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (e != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">      <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> (T)e.value;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 当前线程的ThreadLocalMap为空，进行初始化</span></span><br><span class="line">  <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> T <span class="title function_">setInitialValue</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 初始默认value为null</span></span><br><span class="line">  <span class="type">T</span> <span class="variable">value</span> <span class="operator">=</span> initialValue();</span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">  <span class="type">ThreadLocalMap</span> <span class="variable">map</span> <span class="operator">=</span> getMap(t);</span><br><span class="line">  <span class="keyword">if</span> (map != <span class="literal">null</span>)</span><br><span class="line">    map.set(<span class="built_in">this</span>, value);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    createMap(t, value);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> T <span class="title function_">initialValue</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ThreadLocal</code>类的<code>get()</code>方法的执行流程为：1. 拿到当前线程<code>ThreadLocalMap</code>类型的的私有属性<code>threadLocals</code>；2. 以当前<code>ThreadLocal</code>对象作为<code>threadLocals</code>的<code>Map</code>的<code>Key</code>，拿到并范围对应的<code>Value</code>。</p>
<h4 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h4><p>源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">remove</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">ThreadLocalMap</span> <span class="variable">m</span> <span class="operator">=</span> getMap(Thread.currentThread());</span><br><span class="line">  <span class="keyword">if</span> (m != <span class="literal">null</span>)</span><br><span class="line">    <span class="comment">// 删除当前线程ThreadLocalMap中key为当前ThreadLocal对象的Entry</span></span><br><span class="line">    m.remove(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ThreadLocal</code>类中的<code>remove()</code>方法是删除当前线程中<code>threadLocals</code>属性<code>Key</code>为当前<code>ThreadLocal</code>对象的<code>Entry</code>。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>每个线程内部都有一个名为<code>threadLocals</code>类型为<code>ThreadLocalMap</code>的成员变量，其中<code>key</code>为我们定义的<code>ThreadLocal</code>变量的<code>this</code>引用，<code>value</code>则为我们执行<code>set</code>方法设置的值。</p>
<ul>
<li>第一次操作线程的<code>ThreadLocalMap</code>属性时，会初始化一个<code>ThreadLocal.ThreadLocalMap</code>对象，<code>set(v)</code>会存入以参数为<code>value</code>的<code>K/V</code>数据；<code>get()</code>会存入以<code>null</code>为<code>value</code>的<code>K/V</code>数据。</li>
<li><code>ThreadLocalMap</code>存值操作的入口为<code>ThreadLocal.set(v)</code>方法，并以当前<code>ThreadLocal</code>对象为<code>key</code>，参数<code>v</code>为<code>value</code>。</li>
<li><code>ThreadLocalMap</code>取值操作的入口为<code>ThreadLocal.get()</code>方法，<code>key</code>为当前<code>ThreadLocal</code>对象。</li>
</ul>
<h2 id="2-代码实践"><a href="#2-代码实践" class="headerlink" title="2. 代码实践"></a>2. 代码实践</h2><p><strong>代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadLocalTest</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;Integer&gt; countThreadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;String&gt; nameThreadLocal = <span class="keyword">new</span> <span class="title class_">ThreadLocal</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            countThreadLocal.set(<span class="number">1</span>);</span><br><span class="line">            nameThreadLocal.set(<span class="string">&quot;alise&quot;</span>);</span><br><span class="line">            print(<span class="string">&quot;======thread-1  ThreadLocal赋值后:&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;thread-1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            print(<span class="string">&quot;======thread-2  ThreadLocal赋值前:&quot;</span>);</span><br><span class="line">            countThreadLocal.set(<span class="number">2</span>);</span><br><span class="line">            nameThreadLocal.set(<span class="string">&quot;bob&quot;</span>);</span><br><span class="line">            print(<span class="string">&quot;======thread-2  ThreadLocal赋值后:&quot;</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;thread-2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        System.out.println(str + <span class="string">&quot;\n&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;: \tcount: &quot;</span> + countThreadLocal.get() + <span class="string">&quot;\tname: &quot;</span> + nameThreadLocal.get());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>运行结果：</strong></p>
<p><img src="https://images.ysfun.cn/mac-img/image-20220726213051306.png"></p>
<p><strong>说明：</strong></p>
<ol>
<li>定义了两个<code>ThreadLocal</code>对象：<code>countThreadLocal</code>和<code>nameThreadLocal</code></li>
<li>线程一先执行，调用<code>ThreadLocal.set(v)</code>方法，此时为初次操作<code>ThreadLocal</code>，因此会给线程一的成员变量<code>threadLocals</code>进行初始化并给<code>ThreadLocalMap</code>对象中插入两个<code>Entry&lt;K,V&gt;</code>：<code>&lt;countThreadLocal, 1&gt;</code>和<code>&lt;nameThreadLocal, alise&gt;</code>；注意此时只对线程一的<code>threadLocals</code>进行初始化和赋值操作，线程二的<code>threadLocals</code>仍为<code>null</code></li>
<li>线程二在给<code>ThreadLocal</code>赋值前执行<code>ThreadLocal.get()</code>方法，此时会对线程二的成员变量<code>threadLocals</code>进行初始化，并插入两对默认<code>Entry</code>值：<code>&lt;countThreadLocal, null&gt;</code>和<code>&lt;nameThreadLocal, null&gt;</code></li>
<li>线程二调用<code>ThreadLocal.set(v)</code>方法，此时<code>threadLocals</code>中已经有了两个<code>Entry</code>，调用<code>ThreadLocalMap.set(this, v)</code>方法后，线程二<code>threadLocals</code>中的两个<code>Entry</code>变为：<code>&lt;countThreadLocal, 2&gt;</code>和<code>&lt;nameThreadLocal, bob&gt;</code>，调用<code>ThreadLocal</code>中的<code>get()</code>方法会执行<code>ThreadLocalMap.get(this)</code>，其中<code>this</code>为当前<code>ThreadLocal</code>对象</li>
</ol>
<p>从上面的过程我们可以发现，两个线程都有自己私有的<code>threadLocals</code>对象，在进行<code>ThreadLocal</code>操作时两个线程的数据互相隔离、互不干扰，从而有效解决了线程同步问题。</p>
<h2 id="3-ThreadLocal问题"><a href="#3-ThreadLocal问题" class="headerlink" title="3. ThreadLocal问题"></a>3. ThreadLocal问题</h2><h3 id="3-1-ThreadLocal内存泄漏问题"><a href="#3-1-ThreadLocal内存泄漏问题" class="headerlink" title="3.1 ThreadLocal内存泄漏问题"></a>3.1 ThreadLocal内存泄漏问题</h3><p><code>ThreadLocalMap</code>使用<code>ThreadLocal</code>的弱引用作为<code>key</code>，如果一个<code>ThreadLocal</code>没有外部强引用来引用它的话，那么在系统GC的时候，这个<code>ThreadLocal</code>会被回收，<strong>这样一来，<code>ThreadLocalMap</code>中会出现<code>key</code>为<code>null</code>的<code>Entry</code>，就无法访问这些<code>key</code>为<code>null</code>的<code>Entry</code>的<code>value</code>，如果当前线程迟迟不结束的话，那些<code>key</code>为<code>null</code>的<code>Entry</code>的<code>value</code>就会存在一条强引用链：<code>Thread Ref</code>-&gt;<code>Thread</code>-&gt;<code>ThreadLocalMap</code>-&gt;<code>Entry</code>-&gt;<code>value</code>，那这些<code>value</code>将一直都无法被回收，就会造成「内存泄漏」。</strong></p>
<p>其实，在<code>ThreadLocalMap</code>的设计中已经考虑到了这种情况，并加上了一些防护措施：在<code>ThreadLocal</code>的<code>get()</code>、<code>set()</code>、<code>remove()</code>的时候会清除<code>ThreadLocalMap</code>中<code>key</code>为<code>null</code>的所有<code>Entry</code>。为了代码更加规范，建议我们使用完<code>ThreadLocal</code>后最好手动调用<code>remove()</code>。</p>
<h3 id="3-2-ThreadLocalMap的key为何采用「弱引用」？"><a href="#3-2-ThreadLocalMap的key为何采用「弱引用」？" class="headerlink" title="3.2 ThreadLocalMap的key为何采用「弱引用」？"></a>3.2 ThreadLocalMap的key为何采用「弱引用」？</h3><p>当存在线程复用的场景（如线程池），一个线程的寿命很长，大对象长期不被回收会影响系统运行效率与安全。下面举例说明：</p>
<p>举例：三个线程中的每个线程的<code>ThreadLocalMap</code>的其中一个<code>Entry</code>中的<code>key</code>使用的是同一个<code>ThreadLocal</code>类型变量的地址，都指向了<code>ThreadLocal1</code>；</p>
<img src="https://images.ysfun.cn/mac-img/dc9600dd41084cc7b200982c11fe53ac~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp" style="zoom: 67%;" />

<p>此时假设是强引用：多个线程依赖同一个<code>ThreadLocal1</code>，此时线程1的<code>ThreadLocal</code>使用结束，想要释放其内存，但由于强引用（因为还有其他线程指向<code>ThreadLocal1</code>），这就导致线程1持有的<code>ThreadLocalMap</code>中<code>key</code>为<code>ThreadLocal1</code>的<code>Entry</code>所占有的内存无法释放；如果采用弱引用的话，就仍可将其释放。</p>
<p>我们知道，ThreadLocalMap的生命周期基本和Thread的生命周期一样，当前线程如果没有终止，那么ThreadLocalMap始终不会被GC回收。对比使用强引用，弱引用可以保证不会因为大量<code>key</code>的积累而导致OOM，而对应的<code>value</code>可以通过<code>get()</code>、<code>set()</code>、<code>remove()</code>在下一次调用时清除。可见，内存泄漏的根源不是「弱引用」，而是<code>ThreadLocalMap</code>的生命周期和<code>Thread</code>一样长，造成内存积累。</p>
<h3 id="3-3-ThreadLocal无法给子线程共享父线程的线程副本数据"><a href="#3-3-ThreadLocal无法给子线程共享父线程的线程副本数据" class="headerlink" title="3.3 ThreadLocal无法给子线程共享父线程的线程副本数据"></a>3.3 ThreadLocal无法给子线程共享父线程的线程副本数据</h3><p>异步场景下无法给子线程共享父线程的线程副本数据，可以通过 <code>InheritableThreadLocal</code> 类解决这个问题。</p>
<p>它的原理就是子线程是通过在父线程中调用 <code>new Thread()</code> 创建的，在 Thread 的构造方法中调用了 <code>Thread的init</code> 方法，在 <code>init</code> 方法中父线程数据会复制到子线程（<code>ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</code>）。</p>
<p>但是我们做异步处理都是使用线程池，线程池会复用线程会导致问题出现。遇到这种情况我们需要自己解决。</p>
]]></content>
  </entry>
</search>
